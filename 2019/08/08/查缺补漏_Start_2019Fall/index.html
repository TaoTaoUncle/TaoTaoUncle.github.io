<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="查缺补漏 模板特化 定位内存泄漏  valgrind memcheck 对应一个表 桶排序  排序算法稳定性  稳定：基数排序 冒泡排序 插入排序 归并排序 不稳定：堆排序 快速排序 希尔排序 选择排序  排序算法首推 快排 归并 冒泡排序思想：通过与相邻元素比较和交换把最小的数交换到最前面，这个过程类似于水泡向上升一样，因此而得名。 步骤： 从后往前冒泡，找到最小的那个数并拍到（当前要排序列的）">
<meta name="keywords" content="c++ algorithm Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="YDE&#39;s Daily">
<meta property="og:url" content="http://yoursite.com/2019/08/08/查缺补漏_Start_2019Fall/index.html">
<meta property="og:site_name" content="YDE&#39;s Daily">
<meta property="og:description" content="查缺补漏 模板特化 定位内存泄漏  valgrind memcheck 对应一个表 桶排序  排序算法稳定性  稳定：基数排序 冒泡排序 插入排序 归并排序 不稳定：堆排序 快速排序 希尔排序 选择排序  排序算法首推 快排 归并 冒泡排序思想：通过与相邻元素比较和交换把最小的数交换到最前面，这个过程类似于水泡向上升一样，因此而得名。 步骤： 从后往前冒泡，找到最小的那个数并拍到（当前要排序列的）">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://camo.githubusercontent.com/9602fa0fb65208b0f9e645028cdc36eccb37dc3a/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f32663066356336623563376230303762303066306433333432376137306462302e706e67">
<meta property="og:image" content="https://img-blog.csdn.net/20160717221704993">
<meta property="og:image" content="https://img-blog.csdn.net/20160718090407007">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-ba3efdd8525facefc81189ed6a958b4d_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-36d5aa8eeb765d559ba8d5e136d0b402_hd.jpg">
<meta property="og:image" content="http://www.cppblog.com/images/cppblog_com/hunter/z200777202049.jpg">
<meta property="og:image" content="http://hi.csdn.net/attachment/201110/22/0_13192967247f7E.gif">
<meta property="og:image" content="https://img-blog.csdn.net/20170523212059218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWR5YW5nMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-59224b90b60105a38b74de84e277254e_hd.jpg">
<meta property="og:image" content="https://static.oschina.net/uploads/img/201604/20150405_VKYH.png">
<meta property="og:image" content="https://static.oschina.net/uploads/img/201604/20152818_DXcj.png">
<meta property="og:image" content="https://static.oschina.net/uploads/img/201604/20164149_LD8E.png">
<meta property="og:image" content="https://static.oschina.net/uploads/img/201604/21091434_DsZb.png">
<meta property="og:image" content="https://static.oschina.net/uploads/img/201604/20175459_gtgw.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/0ef3106510e2e1630eb49744362999f8_hd.jpg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/195333v2cj2o6y92d2zp5z.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/195839s5hi3te5pxueq5ze.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/200048bgll2l41w72174ot.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/200650wun9j9ghkgk7ngna.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/200759gg777fr7v7wzcr7r.jpeg">
<meta property="og:image" content="https://img-blog.csdn.net/20180323193130814?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180323193406237?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:updated_time" content="2019-09-07T02:02:32.008Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YDE&#39;s Daily">
<meta name="twitter:description" content="查缺补漏 模板特化 定位内存泄漏  valgrind memcheck 对应一个表 桶排序  排序算法稳定性  稳定：基数排序 冒泡排序 插入排序 归并排序 不稳定：堆排序 快速排序 希尔排序 选择排序  排序算法首推 快排 归并 冒泡排序思想：通过与相邻元素比较和交换把最小的数交换到最前面，这个过程类似于水泡向上升一样，因此而得名。 步骤： 从后往前冒泡，找到最小的那个数并拍到（当前要排序列的）">
<meta name="twitter:image" content="https://camo.githubusercontent.com/9602fa0fb65208b0f9e645028cdc36eccb37dc3a/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f32663066356336623563376230303762303066306433333432376137306462302e706e67">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/08/查缺补漏_Start_2019Fall/">





  <title> | YDE's Daily</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YDE's Daily</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Welcome here!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/08/查缺补漏_Start_2019Fall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YDE">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YDE's Daily">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-08T11:14:42+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>查缺补漏</strong></p>
<p>模板特化</p>
<p>定位内存泄漏</p>
<p> valgrind memcheck 对应一个表</p>
<p>桶排序 </p>
<p><strong>排序算法稳定性</strong></p>
<ul>
<li><strong>稳定</strong>：基数排序 冒泡排序 插入排序 归并排序</li>
<li><strong>不稳定</strong>：堆排序 快速排序 希尔排序 选择排序</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>首推 快排 归并</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思想：通过与<strong>相邻元素比较和交换</strong>把最小的数交换到最前面，这个<strong>过程类似于水泡向上升</strong>一样，因此而得名。</p>
<p>步骤：</p>
<p>从后往前冒泡，找到最小的那个数并拍到（当前要排序列的）最前面，直到要排的序列为空，说明所有排序完成</p>
<p>代码（自己写的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp;a , <span class="keyword">int</span>&amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span>&amp; N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = N<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(numbers[j]&lt;numbers[j<span class="number">-1</span>])</span><br><span class="line">				swap(numbers[j],numbers[j<span class="number">-1</span>]);</span><br><span class="line">		&#125;				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	Bubble(numbers,N);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度：O(n^2)</strong>，——<strong>稳定</strong></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思想：有点和冒泡排序类似，都是<strong>在一次排序后把最小的元素放在最前面</strong>，</p>
<p>其实是对<strong>冒泡排序的优化</strong>，我们中间<strong>不需要交换那么多次</strong>，只需要找到<strong>要排序序列的最小值</strong>，然后把<strong>该值与要放到的位置交换</strong>即可，<strong>每次排序只交换一次</strong>，所以<strong>总共交换n-1次</strong></p>
<p>为什么<strong>叫选择呢</strong>，可能是<strong>选择了最小的来交换的意思</strong></p>
<p>代码（自己写的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp;a , <span class="keyword">int</span>&amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span>&amp; N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = N<span class="number">-1</span>; j&gt;i;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(numbers[j]&lt;numbers[minIndex])</span><br><span class="line">				minIndex = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(minIndex!=i)</span><br><span class="line">			swap(numbers[minIndex],numbers[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	Select_sort(numbers,N);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度——O(n^2)</strong></p>
<p>用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的。</p>
<p>不过，一般提到排序算法时，大家往往会默认是数组实现，所以选择排序是不稳定的</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思想：不是通过交换位置，而是通过<strong>找到合适的位置插入元素</strong>，来达到排序的目的，参考<strong>扑克牌</strong></p>
<p>步骤：第一个不用排序（类比第一张牌），从第二张牌开始插入（注意，我们插入的肯定是排好了的有序序列，程序执行步骤确定，参考摸牌）</p>
<p>保存当前值，因为要移位可能被占用，然后插入最终符合条件的空位，完成一次插入。</p>
<p><strong>关键看好边界条件——因为会有覆盖操作</strong></p>
<p>代码（自己写的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span>&amp; N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> target = numbers[i];</span><br><span class="line">		<span class="keyword">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; numbers[j]&gt;target)&#123;</span><br><span class="line">			numbers[j+<span class="number">1</span>] = numbers[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		numbers[j+<span class="number">1</span>] = target;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	Insert_sort(numbers,N);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想：其实是<strong>来自冒泡排序</strong>，通过比较和交换<strong>小数和大数</strong>，这样一来<strong>不仅把小数冒泡到上面同时也把大数沉到下面</strong></p>
<p><strong>冒泡+二分+递归分治</strong></p>
<p>代码（自己写的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> up)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = numbers[up];</span><br><span class="line">	<span class="keyword">int</span> index = low;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = low;i&lt;up;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(numbers[i]&lt;pivot)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i!=index)</span><br><span class="line">				swap(numbers[i],numbers[index]);</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(numbers[index],numbers[up]);</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> up)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;up)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = Partition(numbers,low,up);</span><br><span class="line">		quickSort(numbers, low, mid<span class="number">-1</span>);</span><br><span class="line">		quickSort(numbers, mid+<span class="number">1</span>, up);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">	quickSort(numbers,<span class="number">0</span>,numbers.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	qSort(numbers);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>O(nlgn) 不稳定</strong></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>借助堆</strong>来实现排序，<font color="blue">思想同简单的选择排序，从当前要排的序列里找一个最值，然后与要放到的位置交换即可</font></p>
<p>主要分两个步骤：</p>
<p>1.<strong>建堆</strong></p>
<p>如果想<strong>升序排序就使用大顶堆/最大堆</strong>，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。</p>
<p>我们可以用<strong>自底向上</strong>的方法将数组A[1..n]转换成最大堆。</p>
<p>首先，我们知道，i/2向下取整+1到n都是叶结点（从我们之前约定好的标号对应上来看） 可以看作是<strong>具有最大堆性质</strong>的结点，所以我们只需要堆1-n/2向下取整的结点调用一次<font color="blue">MAX-HEAPIFY</font>，便可以完成建堆过程。</p>
<p><strong>可以证明</strong> 这个过程是线性复杂度O(n)</p>
<p>关于<strong>堆的基本操作过程</strong>的<strong>时间复杂度</strong>为<strong>O(lgn)</strong></p>
<p>MAX-HEAPIFY:<strong>A[i]的左右孩子都是最大堆，使得A[i]变成一个最大堆</strong>，维护最大堆的性质，<strong><font color="blue">O(lgn)</font></strong></p>
<p>BUILD-MAX-HEAP：线性时间复杂度，从无序的输入数据中<strong>构造</strong>一个最大堆</p>
<p>HEAPSORT:O(nlgn)对一个数组进行<strong>原址排序</strong>。</p>
<p>MAX-HEAP-INSERT HEAP-EXTRACT-MAX HEAP-INCREASE-KEY HEAP-MAXIMUM：利用堆实现一个<strong>优先队列</strong>，O(lgn)</p>
<p>2.排序</p>
<p><strong>最大元素总是存在A[1]中</strong>，通过与<strong>A[n]</strong>互换，<strong>调用一次MAX-HEAPIFY</strong> 并去掉结点n(heapsize-1，但是还存储在数组中），<strong>通过这样的重复操作</strong>，可以不断排序</p>
<p><font color="blue">注意：写代码时，要利用/抽象堆的操作——MAX-HEAPIFY</font></p>
<p>代码(自己写的)</p>
<p>注意：<strong><font color="blue">swap函数肯定是引用 别晕</font></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = numbers[start];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2</span>*start+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i+<span class="number">1</span>&lt;=end &amp;&amp; numbers[i]&lt;numbers[i+<span class="number">1</span>])</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(numbers[i]&lt;tmp)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		numbers[start] = numbers[i];</span><br><span class="line">		start = i;</span><br><span class="line">		i = <span class="number">2</span>*start + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	numbers[start] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = numbers.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = length/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		max_heapify(numbers,i,length<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//	for(int i = 0;i&lt;length;i++)</span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; numbers[i] &lt;&lt; ' ' ;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		swap(numbers[<span class="number">0</span>],numbers[i]);</span><br><span class="line">		max_heapify(numbers,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	heap_sort(numbers);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>O(nlgn) 不稳定</strong></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>是<strong>插入排序的高效率实现</strong>，也叫缩小增量排序</p>
<p><em>插入排序中，如果待排序列是正序时，时间复杂度是O(n)</em></p>
<p>如果序列是基本有序的，使用直接插入排序效率就非常高</p>
<p><strong>思想</strong>：先将整个待排记录序列分割成为<strong>若干子序列分别进行直接插入排序</strong>，待整个序列中的记录<strong>基本有序时再对全体</strong>记录进行<strong>一次直接插入</strong>排序。</p>
<p><strong>希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。</strong></p>
<p>大量实验的基础上推出<strong>当n在某个范围内时，时间复杂度可以达到O(n^1.3)</strong>。</p>
<p><strong><font color="blue">代码思路</font></strong>：</p>
<ol>
<li><p><font color="blue">首先是增量的遍历，从length/2开始，每次除以2，直到1</font>    </p>
</li>
<li><p>其次是<font color="blue">对于每个增量d，有length/d个子序列，注意我们这里排序是从0到length-1，而不是一个个子序列来，d可以帮我们定位到当前元素在当前序列中的上一个元素</font></p>
<p>注意 插入排序是从第二个元素开始的，在这里是从d开始的，因为<font color="blue">增量从d变成了1</font></p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort_Core</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = d;i&lt;=numbers.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = i -d;</span><br><span class="line">		<span class="keyword">int</span> tmp = numbers[i];</span><br><span class="line">		<span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(numbers[j]&lt;tmp)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			numbers[j+d] = numbers[j];</span><br><span class="line">			j -= d;</span><br><span class="line">		&#125;</span><br><span class="line">		numbers[j+d] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">  length = numbers.size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> d = length/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d/=<span class="number">2</span>)</span><br><span class="line">		shell_sort_Core(numbers,d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	shell_sort(numbers);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>是<strong>另一种不同的排序方法</strong>，思想是<font color="blue">递归分治</font>，</p>
<p><strong>基本思想</strong>是，先<font color="blue">递归划分子问题，然后合并结果</font>。把待排序列看成由<font color="blue">两个有序的子序列，然后合并</font>两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。</p>
<p>或者也可以叫<font color="blue">合并排序</font></p>
<p>代码：自己写的</p>
<p><font color="blue">注意：mid的取值，在right=left+1的时候</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = left;</span><br><span class="line">	<span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_array(right-left+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">		<span class="keyword">if</span>(numbers[i]&lt;numbers[j])</span><br><span class="line">			tmp_array[k++] = numbers[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tmp_array[k++] = numbers[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">		tmp_array[k++] = numbers[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">		tmp_array[k++] = numbers[j++];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;tmp_array.size();i++)</span><br><span class="line">		numbers[left+i] = tmp_array[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(right==left)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">	mSort(numbers, left, mid);</span><br><span class="line">	mSort(numbers,mid+<span class="number">1</span>,right);</span><br><span class="line">	merge(numbers,left,mid,right);</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">	mSort(numbers, <span class="number">0</span>, numbers.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	merge_sort(numbers);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><font color="blue">O(n)时间复杂度的排序算法</font></p>
<p>有<strong>前提条件</strong>：待<strong>排序的数要满足一定的范围</strong>的整数，而且计数排序需要<strong>比较多的辅助空间</strong></p>
<p>基本思想：用<strong>待排序的数</strong>作为<strong>计数数组的下标</strong>，<strong>统计每个数字个数</strong>。然后<strong>依次输出即可</strong>得到<strong>有序</strong>序列</p>
<p><strong>最大的数决定了数组的长度</strong></p>
<p><font color="blue">这种特性也让技术排序适合于都是正整数的场景</font></p>
<p>step1:根据值new一个数组/vector，初始化全0，直接键值++</p>
<p>step2:根据得到的vector，遍历一遍并对给出的vector依序赋值即可</p>
<p>代码 自己写的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">-1</span>;<span class="comment">//针对的都是正整数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(numbers[i]&gt;max)</span><br><span class="line">			max = numbers[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length_ = max_(numbers);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_array(length_ + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.size();i++)</span><br><span class="line">		tmp_array[numbers[i]]++;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length_+<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;tmp_array[i];j++)&#123;</span><br><span class="line">			numbers[k++] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	count_sort(numbers);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>是<strong>计数排序的一种改进和推广</strong>，</p>
<p><font color="blue">桶排序的基本思想</font></p>
<p>假设有一组长度为<strong>N</strong>的待排<font color="blue">关键字序列</font>K[1…n]，</p>
<p>首先将这个序列<strong>划分为M个子区间(桶)</strong></p>
<p>基于<strong>某种映射函数</strong>，将<font color="blue">待排列的关键字k</font><strong>映射到第i个桶中</strong>(即同数组B的下标i)，那么该<strong>关键字k</strong>就作为<strong>B[i]的元素</strong>（每个桶B[i]都是一组大小为N/M的序列），接着对<strong>每个桶B[i]中的元素排序（可以使用快排）</strong>。然后<strong>依次枚举输出</strong>B[0]…B[M]中的<strong>全部序列即是一个有序序列</strong>。</p>
<p>bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。<strong><font color="blue">桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。</font></strong>也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。</p>
<p>也就是<strong><font color="blue">很大一部分的排序工作被映射函数做了</font></strong></p>
<p>所以<strong><font color="blue">桶排序高效</font></strong></p>
<p>桶排序分析：桶排序<strong>利用函数的映射关系，减少了几乎所有的比较工作</strong>。实际上，桶排序的<strong>f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题</strong>，已经把<strong>大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。</strong></p>
<p>假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序</p>
<p>如果是1-1000之间则需要100个桶，所以我们<strong><font color="blue">需要知道数目的范围 配合我们使用的映射函数</font></strong></p>
<p>对N个关键字进行桶排序的时间复杂度分为两个部分：</p>
<p>(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</p>
<p>(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为<strong><font color="blue"> ∑ O(Ni*logNi) </font></strong>。其中Ni 为第i个桶的数据量。</p>
<p>很显然，<strong>第(2)部分是桶排序性能好坏的决定因素</strong>。<strong>尽量减少桶内数据的数量是提高效率的唯一办法</strong>(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要<strong>尽量做到</strong>下面两点：</p>
<p>(1) 映射函数f(k)能够将N个数据<strong><font color="blue">平均的分配</font></strong>到M个桶中，这样每个桶就有[N/M]个数据量。</p>
<p>(2) 尽量的 <strong><font color="blue">增大桶的数量</font></strong>。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了</p>
<p><strong>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。</strong></p>
<p><strong>总结： 桶排序的<font color="blue">平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)</font>。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果<font color="blue">输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的</font>。此外，桶排序是稳定的。</strong></p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>又是一种和前面排序方式都不同的排序方式，不需要进行记录关键字之间的比较。</p>
<p><strong>基数排序是一个借助多关键字排序思想对单逻辑关键字进行排序的方法</strong></p>
<p>比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。<strong>如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字</strong>，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是<strong>通过多次的收分配和收集来实现</strong>的，关键字优先级低的先进行分配和收集</p>
<p><strong>最后进行的肯定是占比最大的也就是最高位</strong></p>
<p>所以这里我们<strong><font color="blue">最大值有几位</font></strong></p>
<p><strong><font color="blue">桶的个数是每位的取值也就是0-9共10个</font></strong></p>
<p><strong><font color="blue">最大值有几位我们就要比较多少次</font></strong></p>
<p>注意和桶排序区别开，虽然这里也是分成几类，但是这里是按照逻辑比较，桶排序是通过特殊函数映射然后每个桶内排序</p>
<p>代码(自己写的)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxBit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(max&lt;numbers[i])</span><br><span class="line">			max = numbers[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxBit = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(max/<span class="number">10</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">		maxBit++;</span><br><span class="line">		max /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSortCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> bit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bucketNum = <span class="number">10</span>; <span class="comment">//Obvious</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Buckets(bucketNum);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numbers.size();i++)</span><br><span class="line">		Buckets[(numbers[i]/<span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">10</span>,bit<span class="number">-1</span>)))%<span class="number">10</span>].push_back(numbers[i]);</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Buckets.size();i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;Buckets[i].size();j++)&#123;</span><br><span class="line">			numbers[k++] = Buckets[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max_bit = getMaxBit(numbers);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> bit = <span class="number">1</span>;bit&lt;=max_bit;bit++)</span><br><span class="line">		rSortCore(numbers,bit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(numbers[i]));</span><br><span class="line">	radix_sort(numbers);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numbers[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序、选择排序、插入排序三种简单的排序</p>
<p>快速排序、堆排序、希尔排序三种比较高效的排序</p>
<p>基于分治递归思想的归并排序</p>
<p>还有计数排序、桶排序、基数排序三种线性排序</p>
<p>排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。</p>
<p><img src="https://camo.githubusercontent.com/9602fa0fb65208b0f9e645028cdc36eccb37dc3a/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f32663066356336623563376230303762303066306433333432376137306462302e706e67" alt="img"></p>
<ol>
<li>从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。</li>
<li>上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。</li>
<li>基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。</li>
<li>从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。</li>
<li>上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。附：基于比较排序算法时间下限为O(nlogn)的证明：基于比较排序下限的证明是通过决策树证明的，决策树的高度Ω（nlgn），这样就得出了比较排序的下限。</li>
</ol>
<h2 id="红黑树-AVL树-B树-B-树-Tire树"><a href="#红黑树-AVL树-B树-B-树-Tire树" class="headerlink" title="红黑树 AVL树 B树 B+树 Tire树"></a>红黑树 AVL树 B树 B+树 Tire树</h2><p>二叉搜索树：</p>
<ul>
<li>任意节点左子树不为空,则左子树的值均小于根节点的值.</li>
<li>任意节点右子树不为空,则右子树的值均大于于根节点的值.</li>
<li>任意节点的左右子树也分别是二叉查找树.</li>
<li><strong>没有键值相等的节点.</strong></li>
</ul>
<p>某些情况,二叉查找树会退化成一个有n个节点的线性链.——<strong>不平衡</strong></p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>带有<strong>平衡条件</strong>的二叉查找树，一般是用<strong>平衡因子差值判断是否平衡</strong>并通过<strong>旋转来实现平衡</strong>，<font color="blue">左右子树树高不超过1</font>，严格的平衡二叉树。</p>
<p>只要不满足该条件，就要通过旋转实现平衡，而<font color="blue">旋转是非常耗时的</font></p>
<p>所以，AVL树适合于<font color="blue">插入删除次数少 查找多</font>的情况</p>
<p><strong>局限性</strong>：</p>
<p>维护这种高度平衡所付出的代<strong>价比从中获得的效率收益还大</strong>,故而<strong>实际的应用不多</strong></p>
<p>如果应用场景中对插入删除不频繁,只是对查找要求较高,那么AVL还是较优于红黑树.</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>在 <font color="blue">每个节点增加一个存储位表示节点的颜色,</font>可以是<font color="blue">red或black.</font>    </p>
<p>通过对任何一条从根到叶子的路径上<font color="blue">各个节点着色的方式的限制</font>,红黑树确保<font color="blue">没有一条路径会比其它路径长出两倍</font>.</p>
<p>是一种<strong>弱平衡二叉树</strong>（相同结点数的情况下，可以推出，AVL树的高度低于红黑树）。</p>
<p>相对于AVL树来讲，<font color="blue">旋转次数变少</font>，对于<font color="blue">搜索 插入 删除操作多的情况下</font>，我们使用红黑树</p>
<p><strong>性质</strong>：</p>
<p>1.每个结点是<strong>红 or 黑</strong></p>
<p>2.<strong>根结点</strong>是<strong>黑色</strong></p>
<p>3.<strong>叶结点</strong>是<strong>黑色</strong>（NIL）——这里的叶结点是指最后的左右空指针</p>
<p>4.红色结点的两个子结点是黑色</p>
<p>5.对<strong>每个结点</strong>，从该结点到其他后代叶结点的简单路径上，均包含<strong>相同数目</strong>的<strong>黑色</strong>结点</p>
<p><strong>应用</strong>：</p>
<ul>
<li>广泛用于C++的STL中,map和set都是用红黑树实现的.</li>
<li>著名的linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块,进程的虚拟内存区域都存储在一颗红黑树上,每个虚拟地址区域都对应红黑树的一个节点,左指针指向相邻的地址虚拟存储区域,右指针指向相邻的高地址虚拟地址空间.</li>
<li>IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.</li>
<li>ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.</li>
<li>java中TreeMap的实现</li>
</ul>
<h3 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B/B+树"></a>B/B+树</h3><p>ps B-树就是B树</p>
<p>B/B+树是<font color="blue">为了磁盘或其它存储设备而设计</font>的一种<font color="blue">平衡多路查找树</font>(相对于二叉,B树每个内<font color="blue">节点有多个分支</font>),与红黑树相比,在<strong>相同的的节点的情况下,一颗B/B+树的高度远远小于红黑树的高度</strong>(在下面B/B+树的性能分析中会提到).B/B+树上<strong>操作的时间</strong>通常由<strong>存取磁盘的时间</strong>和<strong>CPU计算时间</strong>这两部分构成,而<strong>CPU的速度非常快,所以B树的操作效率取决于访问磁盘的次数</strong>,关键字总数相同的情况下<font color="blue">B树的高度越小，磁盘I/O所花的时间越少</font>.</p>
<h4 id="B树的性质"><a href="#B树的性质" class="headerlink" title="B树的性质"></a>B树的性质</h4><ul>
<li><p>定义任意非叶子结点<strong>最多只有M个儿子</strong>；且<strong>M&gt;2</strong>；</p>
</li>
<li><p><font color="blue">最小度数t, t&gt;=2</font></p>
</li>
<li><p><strong>根结点</strong>的儿子数为<strong>[2, M]</strong>；</p>
</li>
<li><p><strong>除根结点以外的非叶子结点</strong>的儿子数为<strong>[M/2, M]</strong>；</p>
</li>
<li><p>每个结点<strong>存放至少M/2-1（取上整）和至多M-1个关键字</strong>；（至少2个关键字）</p>
</li>
<li><p><strong>非叶子结点的关键字个数=指向儿子的指针个数-1</strong>；</p>
</li>
<li><p><strong>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</strong>——<font color="blue">升序排列</font></p>
</li>
<li><p>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于<font color="blue">(K[i-1], K[i])</font>的子树；</p>
<p>注意是<font color="blue">开区间</font></p>
</li>
<li><p><strong>所有叶子结点位于同一层</strong>；</p>
</li>
</ul>
<p><strong><font color="blue">结合下面图看上面性质</font></strong></p>
<p><img src="https://img-blog.csdn.net/20160717221704993" alt="è¿éåå¾çæè¿°"></p>
<p>这里只是一个简单的B树,在实际中B树节点中关键字很多的.上面的图中比如35节点,35代表一个key(索引)，而<strong>小黑块</strong>代表的是这个key所指向的内容在内存中实际的存储位置.<strong>是一个指针.</strong></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是应文件系统所需而产生的一种B树的变形树(<strong>文件的目录一级一级索引,只有最底层的叶子节点(文件)保存数据</strong>.),<strong>非叶子节点只保存索引</strong>,不保存实际的数据,<strong>数据都保存在叶子节点</strong>中.这不就是文件系统文件的查找吗?我们就举个文件查找的例子:有3个文件夹,a,b,c, a包含b,b包含c,一个文件yang.c, a,b,c就是索引(存储在非叶子节点), a,b,c只是要找到的yang.c的key,而实际的数据yang.c存储在叶子节点上.<br><font color="blue">所有的非叶子节点都可以看成索引部分</font></p>
<h4 id="B-树的性质——提到的都是和B树不同的性质，其他相同"><a href="#B-树的性质——提到的都是和B树不同的性质，其他相同" class="headerlink" title="B+树的性质——提到的都是和B树不同的性质，其他相同"></a>B+树的性质——提到的都是和B树不同的性质，其他相同</h4><ul>
<li><strong>非叶子节点</strong>的子树<strong>指针与关键字个数相同</strong>;</li>
<li>非叶子节点的子树指针<strong>p[i],指向关键字值属于[k[i],k[i+1]]的子树</strong>.(B树是开区间,<font color="blue">也就是说B树不允许关键字重复,B+树允许重复)</font>；</li>
<li>为<font color="blue">所有叶子节点增加一个链指针</font>.</li>
<li><font color="blue">所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)</font>;</li>
<li><strong>非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层.</strong></li>
<li><font color="blue">更适合于文件系统</font>; </li>
</ul>
<p><img src="https://img-blog.csdn.net/20160718090407007" alt="è¿éåå¾çæè¿°"></p>
<p>非叶子节点(比如5,28,65)只是一个key(索引),<strong>实际的数据存在叶子节点上(5,8,9)才是真正的数据或指向真实数据的指针</strong>.</p>
<p><font color="blue">把实际的数据用一个链表链在一起，使得遍历整棵树只要遍历叶子结点就行</font></p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>B和B+树主要用在<strong>文件系统以及数据库做索引</strong>.比如Mysql;</p>
<h4 id="B-B-树性能分析"><a href="#B-B-树性能分析" class="headerlink" title="B/B+树性能分析　"></a>B/B+树性能分析　</h4><p>n个节点的平衡二叉树的高度为H(即logn),而n个节点的B/B+树的高度为</p>
<p><strong>log<sub>t</sub>((n+1)/2)+1;</strong> 　　<br>若要作为<strong>内存中的查找表,B树却不一定比平衡二叉树好</strong>,尤其当m较大时更是如此.因为查找操作CPU的时间在B-树上是O(mlogtn)=O(lgn(m/lgt)),而m/lgt&gt;1;所以m较大时O(mlogtn)比平衡二叉树的操作时间大得多. 因此在内存中使用B树必须取较小的m.（通常取最小值m=3，此时B-树中每个内部结点可以有2或3个孩子，这种3阶的B-树称为2-3树）。</p>
<h4 id="为什么说B-tree比B树更适合实际应用中操作系统的文件索引和数据索引"><a href="#为什么说B-tree比B树更适合实际应用中操作系统的文件索引和数据索引" class="headerlink" title="为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据索引.　"></a>为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据索引.　</h4><p>B+-tree的内部节点并没有指向关键字具体信息的指针,因此其内部节点相对B树更小,如果把所有同一内部节点的关键字存放在同一盘块中,那么盘块所能容纳的关键字数量也越多,一次性读入内存的需要查找的关键字也就越多,相对IO读写次数就降低了.<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。<br>ps:我在知乎上看到有人是这样说的,我感觉说的也挺有道理的:<br>他们认为数据库索引采用B+树的主要原因是:B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题,正是为了解决这个问题,B+树应用而生.B+树只需要去遍历叶子节点就可以实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）.　　</p>
<h3 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h3><p>首先，内存是快的，磁盘是慢的，所以<strong><font color="blue">磁盘I/O（也就是从磁盘和内存间I/O数据）是非常慢的</font></strong>，比在内存中直接操作数据慢几个数量级</p>
<p>注意我们<strong><font color="blue">上面的示意图都是索引，而每个索引对应数据，但在上面示意图中没有体现</font></strong></p>
<ul>
<li><strong><font color="blue">B树的中间结点 是会存储卫星数据的</font></strong></li>
<li><strong><font color="blue">B+树的中间结点不会存储，只有叶子结点存储，因为叶子结点包含了所有索引，可以允许B+树这么做</font></strong></li>
</ul>
<p><strong>B树卫星数据示意图</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-ba3efdd8525facefc81189ed6a958b4d_hd.jpg" alt="img"></p>
<p><strong>B+树卫星数据示意图</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-36d5aa8eeb765d559ba8d5e136d0b402_hd.jpg" alt="img"></p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>第一点：在 B 树中，节点的关键字用于在查询时确定查询区间，因此关键字数比子树数少一；而在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</p>
<p>第二点，除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</p>
<blockquote>
<p>根节点的最大关键字其实就表示整个 B+ 树的最大元素。(最大还是最小要看选取的是区间左端点还是右端点作为关键字)</p>
</blockquote>
<p>第三点，叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</p>
<p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，<strong><font color="blue">B+ 树会 B 树更加“矮胖”，因此查询效率更快</font>。</strong></p>
<p>B+ 树的查找必会查到叶子节点，更加稳定。</p>
<p>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p>
<p>B+ 树的三个优点：</p>
<ol>
<li><p><strong>层级更低，IO 次数更少</strong></p>
</li>
<li><p>每次都需要查询到叶子节点，查询性能<strong>稳定</strong></p>
</li>
<li><p>叶子节点形成有序链表，<strong>范围查询方便</strong></p>
<p><font color="blue">范围查询是指，查询位于一个范围内的所有数，比如9-30之间</font></p>
</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/54102723" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54102723</a></p>
<p><a href="https://juejin.im/entry/5b0cb64e518825157476b4a9" target="_blank" rel="noopener">https://juejin.im/entry/5b0cb64e518825157476b4a9</a></p>
<h3 id="Trie树-字典树"><a href="#Trie树-字典树" class="headerlink" title="Trie树 字典树"></a>Trie树 字典树</h3><p>又称单词查找树或者键树。</p>
<p>典型应用是<font color="blue">统计和排序大量字符串(但不仅限于字符串)</font>，经常<strong>被搜索引擎系统用于文本词频统计</strong></p>
<p><strong>优点</strong>：<font color="blue">最大限度的减少无谓的字符串比较，查询效率比哈希表高</font></p>
<p><strong>核心思想</strong>：空间换时间，利用<strong>字符串的公共前缀</strong>来降低查询时间的开销以达到提高效率的目的</p>
<h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h4><ol>
<li>根结点不包含字符，出根结点外每一个结点都只包含一个字符</li>
<li>从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串</li>
<li>每个结点的所有子结点包含的字符都不相同</li>
</ol>
<p><strong>题目</strong>：给你100000个长度不超过10的单词。对于每一个单词，我们要 <font color="blue">判断他是否出现过，如果出现了，求第一次出现在第几个位置</font>。</p>
<p> 现在回到例子中，如果我们用最傻的方法，对于<strong>每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)</strong>。显然对于100000的范围难以接受。现在我们换个思路想。假设我要查询的单词是<strong>abcd，那么在他前面的单词中，以b，c，d，f之类开头的我显然不必考虑</strong>。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，<strong><font color="blue">一次次缩小范围和提高针对性，这样一个树的模型</font></strong>就渐渐清晰了。</p>
<p><img src="http://www.cppblog.com/images/cppblog_com/hunter/z200777202049.jpg" alt="img"></p>
<p>如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果<font color="blue">这个节点被标记为红色，就表示这个单词存在，否则不存在</font>。<br>   那么，对于一个单词，我只要顺着他从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。</p>
<p>这样一来我们查询和插入可以一起完成（重点体会这个查询和插入是如何一起完成的，稍后，下文具体解释），<font color="blue">所用时间仅仅为单词长度</font>.<br>    我们可以看到，<strong>trie树每一层的节点数是26^i级别的。所以为了节省空间。我们用动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数×单词长度</strong></p>
<h4 id="前缀查询"><a href="#前缀查询" class="headerlink" title="前缀查询"></a>前缀查询</h4><p>已知n个由小写字母构成的平均长度为10的单词,判断其中<strong>是否存在某个串为另一个串的前缀子串</strong>。下面对比3种方法</p>
<p>哈希不好搞，但是trie还是很简单</p>
<ol>
<li>最容易想到的：即从字符串集中从头往后搜，看每个字符串是否为字符串集中某个字符串的前缀，复杂度为O(n^2)。</li>
<li>使用hash：我们用hash存下所有字符串的所有的前缀子串，<strong>建立</strong>存有子串<strong>hash的复杂度为O(nxlen)</strong>，而<strong>查询的复杂度为O(n)* O(1)= O(n)</strong>。</li>
<li>使用trie：因为当查询如字符串abc是否为某个字符串的前缀时，显然以b,c,d….等不是以a开头的字符串就不用查找了。所以建立trie的复杂度为O(nxlen)，而<strong>建立+查询在trie中是可以同时执行的</strong>，建立的过程也就可以成为查询的过程，hash就不能实现这个功能。<strong>所以总的复杂度为O(nxlen)，实际查询的复杂度也只是O(len)</strong>。（说白了，就是Trie树的平均高度h为len，所以Trie树的查询复杂度为O（h）=O（len）。好比一棵二叉平衡树的高度为logN，则其查询，插入的平均时间复杂度亦为O（logN））。</li>
</ol>
<p>下面解释下上述方法3中所说的为什么hash不能将建立与查询同时执行，而Trie树却可以：</p>
<ul>
<li>在hash中，例如现在要输入两个串911，911456，如果要同时查询这两个串，且查询串的同时若hash中没有则存入。那么，这个查询与建立的过程就是先查询其中一个串911，没有，然后存入9、91、911；而后查询第二个串911456，没有然后存入<strong>9、91、911</strong>、9114、91145、911456。因为程序没有记忆功能，所以并不知道911在输入数据中出现过，只是照常以例行事，存入9、91、911、9114、911…。也就是说用hash必须先存入所有子串，然后for循环查询。</li>
<li>而trie树中，存入911后，已经记录911为出现的字符串，在存入911456的过程中就能发现而输出答案；倒过来亦可以，先存入911456，在存入911时，当指针指向最后一个1时，程序会发现这个1已经存在，说明911必定是某个字符串的前缀。</li>
</ul>
<p><img src="http://hi.csdn.net/attachment/201110/22/0_13192967247f7E.gif" alt="img"></p>
<p> 可以看出：</p>
<ul>
<li><p>每条边对应一个字母。</p>
</li>
<li><p>每个节点对应一项前缀。叶节点对应最长前缀，即单词本身。</p>
</li>
<li><p>单词inn与单词int有共同的前缀“in”, 因此他们共享左边的一条分支，root-&gt;i-&gt;in。同理，ate, age, adv, 和ant共享前缀”a”，所以他们共享从根节点到节点”a”的边。</p>
</li>
</ul>
<p>查询操纵非常简单。比如要查找int，顺着路径i -&gt; in -&gt; int就找到了。</p>
<p>​    搭建Trie的基本算法也很简单，无非是逐一把每则单词的每个字母插入Trie。插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。比如要插入单词add，就有下面几步：</p>
<ol>
<li>考察前缀”a”，发现边a已经存在。于是顺着边a走到节点a。</li>
<li>考察剩下的字符串”dd”的前缀”d”，发现从节点a出发，已经有边d存在。于是顺着边d走到节点ad</li>
<li>考察最后一个字符”d”，这下从节点ad出发没有边d了，于是创建节点ad的子节点add，并把边ad-&gt;add标记为d。</li>
</ol>
<h4 id="Trie树的应用"><a href="#Trie树的应用" class="headerlink" title="Trie树的应用"></a>Trie树的应用</h4><p>除了本文引言处所述的问题能应用Trie树解决之外，Trie树还能解决下述问题（节选自此文：<strong><font color="blue">海量数据处理</font></strong>面试题集锦）：</p>
<ul>
<li>3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li>
<li>9、1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？</li>
<li>10、 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。</li>
<li>13、寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。<br>(1) 请描述你解决这个问题的思路；<br>(2) 请给出主要的处理流程，算法，以及算法的复杂度。</li>
</ul>
<p>红黑树 AVL树 B-树 B+树</p>
<p>Trie树(字典树)</p>
<p>海量数据问题：</p>
<ul>
<li>十亿整数（随机生成&amp;可重复）中前K最大的数</li>
<li>十亿整数（随机生成&amp;可重复）中出现频率最高的一千个</li>
</ul>
<p>快排 建堆 <strong>归并</strong> <strong>桶</strong></p>
<p>算法的时间空间复杂度，最好最差平均情况</p>
<p><strong>布隆过滤器</strong>：</p>
<p>几十亿个数经常要查找某一个数在不在里面，使用布隆过滤器，布隆过滤器的原理。布隆过滤器可能出现误判，怎么保证无误差？</p>
<p><strong>HTTP</strong>：</p>
<ul>
<li><strong>http/https 1.0、1.1、2.0的特点和区别</strong></li>
<li><strong>get/post 区别</strong></li>
<li><strong>HTTP返回状态码</strong></li>
<li><strong>http 协议头相关</strong></li>
</ul>
<p>http数据由请求行，首部字段，空行，报文主体四个部分组成<br>首部字段分为：通用首部字段，请求首部字段，响应首部字段，实体首部字段</p>
<ul>
<li><strong>https与http的区别？如何实现加密传输？加解密方式？</strong></li>
<li><strong>浏览器中输入一个URL发生什么，用到哪些协议？</strong></li>
</ul>
<p><strong>安全相关</strong></p>
<p>至少了解攻击的原理和基本的防御方法，常见的攻击方法有一下几种</p>
<ul>
<li>SQL注入</li>
<li>XSS</li>
<li>CSRF</li>
<li>SYN洪水攻击</li>
<li>APR欺骗</li>
</ul>
<p><strong>数据库</strong></p>
<p>主要参考书籍：《数据库系统概念》，《高性能MySQL》</p>
<ul>
<li>SQL语言(内外连接，子查询，分组，聚集，嵌套，逻辑)</li>
<li>MySQL索引方法？索引的优化？</li>
<li>InnoDB与MyISAM区别？</li>
<li>事务的ACID</li>
<li>事务的四个隔离级别</li>
<li>查询优化(从索引上优化，从SQL语言上优化)</li>
<li>B-与B+树区别？</li>
<li>MySQL的联合索引(又称多列索引)是什么？生效的条件？</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>++i是否是原子操作<br>明显不是，++i主要有三个步骤，把数据从内存放在寄存器上，在寄存器上进行自增，把数据从寄存器拷贝会内存，每个步骤都可能被中断。</li>
<li>判断大小端</li>
</ul>
<p><strong>设计模式</strong></p>
<ul>
<li>单利模式线程安全的写法</li>
<li>STL里的迭代器模式，适配器写法</li>
</ul>
<p><strong>分布式系统</strong></p>
<ul>
<li>map_reduce 原理</li>
<li>负载均衡</li>
<li>CDN</li>
</ul>
<p>算法和数据结构，数据结构我比较关注哈希、<strong>优先级队列</strong>等，算法则是<strong>字符串处理、简单的 DFS、BFS、动态规划</strong>都有</p>
<p>系统的知识：进程、线程、协程、锁的使用、消息队列、共享内存、还有网络协议、epoll、select等。顺便会考察一些处理问题的基本思路，比如<strong>通过哈希来划分、通过队列来序列化操作</strong>等等。此外，往往很多同学的项目经历中，有很多点可以结合系统的知识来考察，看看是否真的做过项目。比如我就碰到过自己写过 web server 的，搞过 key-value 数据库的，声称读过 redis 源码的，这些很适合配合系统知识考察，确认是不是真的做过这些项目，理解如何。</p>
<ol>
<li>一类是Linux基本操作，包括常用的Linux命令和工具的使用 shell脚本的编写，能通过脚本玩车给一些日常任务</li>
<li>另一类是<strong>重点</strong>，Linux环境编程，需要对Linux的API要熟悉(POSIX哪些函数，当然ANSI标准库的函数也要熟悉)。经常考察的就是IO 各类IPC的操作方式，socket通信的流程 select/poll/epoll等IO多路复用模型。socket和IO多路复用是网络编程的重点</li>
</ol>
<p>用template 写工厂模式</p>
<p>右值引用</p>
<p>哪些情况非用pointer不可。vector的增长 map的实现 iterator invalidation相关问题。 </p>
<p>![Screen Shot 2019-08-08 at 11.41.13 AM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-08 at 11.41.13 AM.png)</p>
<p><strong>C++类的内存布局</strong></p>
<p>然后是C++部分，基础语法是不会考的，很喜欢考类的内存布局，vtable的原理，虚继承的时候类内存布局，多继承的时候类的布局。另外一个重点在内存部分，只要跟内存相关的都喜欢考，对指针的理解，allocator的实现，vector内存分配的策略，各种智能指针实现原理及其使用注意事项, rule of three， RAII，内存泄漏的原油时候如何调试等等。</p>
<p>Linux这里主要考察进程调度和进程生命周期，特别是CFS调度算法，几乎是必问，进程部分还有进程间通信。还有文件系统，对VFS的结构很喜欢考，解释软链接和硬链接（从inode和dentry去解释），还有文件缓存，IO调度算法等等。Linux这里也喜欢问内存，slab，slub，伙伴算法，进程内存空间，线程内存空间等等。在系统编程层次主要考察各种IO系统调用、进程相关的系统调用、socket编程。然后把这些系统调用对应到进程生命周期和进程间通信的各个阶段去考。还会考查高级IO操作，IO多路复用，poll，epoll等等，AIO，零拷贝。另外就是Linux的各种使用命令等等，都是常用命令，sed，grep，top这种。</p>
<p>计算机网络主要集中在tcp/ip还有http上面，喜欢考tcp/ip的各种状态转移，把UNP中那副状态转移图中的11个状态背下来就可以应付，还有就是滑动窗口，慢启动，快恢复等等，偶尔会考路由算法。Http会考查一些状态码，各种http选项，重点考查缓存控制，考查keep-alive和pipe line等等。</p>
<p><strong>文件系统</strong></p>
<h1 id="补充部分"><a href="#补充部分" class="headerlink" title="补充部分"></a>补充部分</h1><p>通过讲int类型转换为char，获得低字节部分，可以得知cpu是大端还是小端</p>
<p>注意union联合体的共享内存的概念，不同类型指向同一快内存，输出值（有点类似于类型转换的感觉）</p>
<p>所以union可以用来判断cpu是大端还是小端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkCPU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> MyUnion&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">    &#125;test;</span><br><span class="line">    test.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (test.c == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"little endian"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"big endian"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    checkCPU();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> test</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">char</span> mark;</span><br><span class="line">     <span class="keyword">long</span> num;</span><br><span class="line">     <span class="keyword">float</span> score;</span><br><span class="line">&#125;a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// cout&lt;&lt;a&lt;&lt;endl; // wrong</span></span><br><span class="line">     a.mark = <span class="string">'b'</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.mark&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出'b'</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.num&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 98 字符'b'的ACSII值</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.score&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出错误值</span></span><br><span class="line"></span><br><span class="line">     a.num = <span class="number">10</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.mark&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出换行 非常感谢suxin同学的指正</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.num&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出10</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.score&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出错误值</span></span><br><span class="line"></span><br><span class="line">     a.score = <span class="number">10.0</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.mark&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出空</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.num&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出错误值</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;a.score&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出10</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>STL的内存管理</strong></p>
<p>ps：new一个对象的过程</p>
<p>step1: malloc分配一块内存</p>
<p>step2: 执行构造函数</p>
<p>在SGI中，allocate申请内存 construct调用构造函数</p>
<p>讲下简单的过程：<br>首先分为两层配置：</p>
<p>第一层使用malloc和free </p>
<p>第二层使用内存池</p>
<p>如果分配或释放的空间&gt;128BYTE，使用第一层</p>
<p>如果&lt;=128B，则调用第二层</p>
<p>第二层内存池：主要是维护了<strong>16个空闲链表</strong></p>
<p>注意这里内存池不等于16个空闲链表，内存池首先是从堆里配置一大块内存，然后用来维护16个链表，16个链表分别管理代销为8 16 24 …128的数据块，也就是对应链表的结点指向的内存都是8/16/24/…128</p>
<p>refill：填充的是没有可用区块的空闲链表，也就是这个链表直接指向了NULL</p>
<p>空间配置函数allocate：大于128B调用第一层，否则调用第二层，查找<strong>对应的空闲链表</strong>，有区块直接用，否则refill空闲链表</p>
<p>空间释放函数deallocate：</p>
<p>检查大小，大于128B调用第一层配置，否则调用第二层配置。首先根据回收数据块的大小判断应该将回收后的数据插入哪个空闲链表，把该结点指向的下一个地址修改为原链表指向的地址（这里是NULL），然后将原链表指向该结点。</p>
<p>4 重新填充空闲链表</p>
<p>如果空闲链表中没有可用数据块，也就是说这个链表只有一个NULL，这时候调用上面的refill来重新填充空间，<strong>新的空间取自内存池</strong>。默认取20个数据块，如果内存池空间不足，那么能取多少个就多少个</p>
<p>5 <strong>从内存池取空间</strong>，也就是去空间给空闲链表，第一步肯定是从内存池里申请，如果不够再用malloc从堆里申请给内存池，实在不行，从<strong>所有的空闲链表里找可用区块</strong>，把该数据块分给内存池，然后将该数据块从链表里删除。</p>
<p>几个过程的思路</p>
<ul>
<li><p>申请过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (用户申请的内存不大于<span class="number">128</span> bytes)   </span><br><span class="line">    查找对应的链表   </span><br><span class="line">    <span class="keyword">if</span> (对应链表拥有一块以上的区块)   </span><br><span class="line">        调整链表   </span><br><span class="line">        返回第一个区块地址   </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        准备重新填充链表   </span><br><span class="line">            向内存池申请内存(指定数量的区块)   </span><br><span class="line">            <span class="keyword">if</span> (内存池申请到一个区块)   </span><br><span class="line">                返回第一个区块地址   </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                调整链表，将区块串接起来   </span><br><span class="line">                返回第一个区块地址   </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    直接用<span class="built_in">malloc</span>()申请内存</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (用户释放的内存块大于<span class="number">128</span> bytes)   </span><br><span class="line">    直接用<span class="built_in">free</span>()释放   </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    查找对应的链表   </span><br><span class="line">    回收内存</span><br></pre></td></tr></table></figure>
</li>
<li><p>向内存池申请内存过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (内存池空间完全满足需求量)   </span><br><span class="line">    调整内存池起始位置   </span><br><span class="line">    返回空间地址   </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (内存池空间不能完全满足需求量，但能提供一个以上的区块)   </span><br><span class="line">    计算能够提供的最大内存   </span><br><span class="line">    调整内存池起始位置   </span><br><span class="line">    返回空间地址   </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    从内存池中压缩内存   </span><br><span class="line">    收集比size大的空间   </span><br><span class="line">    递归调用，修正nobjs   </span><br><span class="line">    再次申请内存，可能抛出异常</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>STL里的set和map是基于什么实现的</strong></p>
<p>红黑树的特点</p>
<p><strong>vector封装数组，list封装了链表，map和 set封装了二叉树</strong>等，在封装这些数据结构的时候，STL按照程序员的使用习惯，以成员函数方式提供的常用操作，如：插入、排序、删除、查找等。让用户在 STL使用过程中，并不会感到陌生。</p>
<p>vector（向量）——STL中标准而安全的数组。<strong>只能在vector 的“前面”增加数据</strong>。deque（双端队列double-ended queue）——在功能上和vector相似，但是可以在前后两端向其中添加数据。</p>
<p> list（列表）——游标一次只可以移动一步。如果你对链表已经很熟悉，那么STL中的<strong>list则是一个双向链表</strong>（每个节点有指向前驱和指向后继的两个指针）</p>
<p>set（集合）——包含了经过排序了的数据，这些数据的值(value)必须是唯一的。</p>
<p>map （映射）——经过排序了的二元组的集合，map中的每个元素都是由两个值组成，其中的key（键值，一个map中的键值必须是唯一的）是在排序或搜索时使用，它的值可以在容器中重新获取；而另一个值是该元素关联的数值。比如，除了可以ar[43] = “overripe”这样找到一个数据，map还可以通过ar[“banana”] = “overripe”这样的方法找到一个数据。如果你想获得其中的元素信息，通过输入元素的全名就可以轻松实现。</p>
<p>multiset（多重集）——和集合（set）相似，然而其中的值不要求必须是唯一的（即可以有重复）。</p>
<p>multimap（多重映射）——和映射（map）相似，然而其中的键值不要求必须是唯一的（即可以有重复）</p>
<p>STL map和set的使用虽不复杂，但也有一些不易理解的地方，如：</p>
<ul>
<li>为何map和set的插入删除效率比用其他序列容器高？</li>
<li>为何每次insert之后，以前保存的iterator不会失效？</li>
<li>为何map和set不能像vector一样有个reserve函数来预分配数据？</li>
<li>当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？</li>
</ul>
<p>C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树</p>
<ul>
<li><p>什么是<strong>红黑树</strong></p>
<p>红黑树是一棵<strong>二叉搜索树</strong>，每个结点增加了一个<strong>存储位来表示结点颜色</strong>，RED or BLACK，通过对任何一条从根到叶子的简单路径上的各个<strong>结点的颜色进行约束</strong>，确保<strong>没有一条路径会比其他路径长出两倍</strong>，近似于是<strong>平衡的</strong>。</p>
<p> 性质</p>
<p>1.每个结点是<strong>红 or 黑</strong></p>
<p>2.<strong>根结点</strong>是<strong>黑色</strong></p>
<p>3.<strong>叶结点</strong>是<strong>黑色</strong>（NIL）——这里的叶结点是指最后的左右空指针</p>
<p>4.红色结点的两个子结点是黑色</p>
<p>5.对<strong>每个结点</strong>，从该结点到其他后代叶结点的简单路径上，均包含<strong>相同数目</strong>的<strong>黑色</strong>结点</p>
<p>使用一个哨兵T.nil来代替所有NIL <strong>节省空间</strong></p>
<p>一般我们把有关键字的非NIL结点成为<strong>内部结点</strong>，这是我们所关心的部分</p>
<p>从某个结点x出发（<strong>不含该结点</strong>）到达任意一个叶结点的简单路径上的<strong>黑色结点个数</strong>称为<strong>黑高</strong>。</p>
<p>红黑树的黑高为根结点的黑高</p>
<p><em>一棵n个内部结点的红黑树的高度至多为2lg(n+1)</em></p>
<p> 旋转</p>
<p>INSERT DELETE操作可能违反红黑树的性质，这里需要<strong>旋转</strong>操作来维持这些性质</p>
<p><strong>右旋 左旋</strong>——O(1)时间内完成，只有指针改变，其他所有属性不变</p>
<p> 插入</p>
<p>可以证明在O(lgn)时间内完成</p>
<p>插入<strong>结点 颜色属性为红色</strong></p>
<p>利用二叉搜索树的插入<strong>TREE-INSERT之后调用</strong>一个辅助程序INSERT-FIXUP来对结点<strong>重新着色并旋转</strong></p>
<p><strong>分析</strong>：</p>
<p>TREE-INSERT插入红色结点后 哪些性质不能保持</p>
<p><strong>只有两种</strong>情况：</p>
<p>1.z是根结点，破坏了性质2</p>
<p>2.z的父结点是红色，破坏了性质4</p>
<p>我们保证我们当前的指向的结点z颜色是<strong>红色</strong>，所以我们循环的条件就是z.p.color==RED，因为这样破坏了性质4</p>
<p><strong>分情况操作</strong>：</p>
<p>父结点是右孩子和左孩子是对称的，所以我们这里只讨论父结点是左孩子的情况，右孩子的代码就是把右孩子中的left和right调换一下</p>
<p>情况一：叔结点是<strong>红色</strong>，爷肯定是黑色，那么叔 爸 变黑 爷变红，指针指到爷，在进行下一轮循环（符合z是红）</p>
<p>情况二：叔结点是<strong>黑色</strong>，如果z是右孩子，z上升为爸并左旋，否则不左旋，然后将爸变成黑色，爷变成红色，然后右旋。</p>
</li>
</ul>
<p>为何map和set的插入删除效率比用其他序列容器高？</p>
<p>插入和删除只需要做<strong>指针的变换</strong>，<strong>不需要内存的移动和拷贝</strong></p>
<p>为什么insert之后，以前保存的iterator不会失效？</p>
<p>iterator相当于指针，指针更换，但是内存没有变（发生移动拷贝释放），所以指向内存的指针也就是iterator不会失效。（当然被删除的那个元素本身失效了）</p>
<p>相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。<strong>因为为了保证内部数据的连续存放</strong>，iterator<strong>指向的那块内存在删除和插入过程中可能</strong>已经被其他内存<strong>覆盖或者</strong>内存已经<strong>被释放</strong>了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。</p>
<p>为何map和set不能像vector一样有个reserve函数来预分配数据？</p>
<p>引起它的原因在于在map和set内部存储的已经不是元素本身了，而是包含元素的结点</p>
<p>也就是说map内部使用的<code>Alloc</code>并不是<code>map&lt;Key, Data, Compare, Alloc&gt;</code>声明的时候从参数中传入的<code>Alloc</code>。例如：</p>
<p><code>map&lt;int, int, less&lt;int&gt;, Alloc&lt;int&gt; &gt; intmap;</code></p>
<p>这时候在<code>intmap</code>中使用的<code>allocator</code>并不是<code>Alloc&lt;int&gt;</code>, 而是通过了转换的<code>Alloc</code>，具体转换的方法时在内部通过<code>Alloc&lt;int&gt;::rebind</code>重新定义了新的节点分配器，详细的实现参看彻底学习STL中的<code>Allocator</code>。其实你就记住一点，在map和set内面的分配器已经发生了变化，reserve方法你就不要奢望了。</p>
<p>当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？</p>
<p>如果你知道log2的关系你应该就彻底了解这个答案。在map和set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。</p>
<p><font color="gray">最后，对于map和set Winter还要提的就是它们和一个c语言包装库的效率比较。在许多unix和linux平台下，都有一个库叫isc，里面就提供类似于以下声明的函数:</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void tree_init(void **tree);</span><br><span class="line">void *tree_srch(void **tree, int (*compare)(), void *data);</span><br><span class="line">void tree_add(void **tree, int (*compare)(), void *data, void (*del_uar)());</span><br><span class="line">int tree_delete(void **tree, int (*compare)(), void *data,void (*del_uar)());</span><br><span class="line">int tree_trav(void **tree, int (*trav_uar)());</span><br><span class="line">void tree_mung(void **tree, void (*del_uar)());</span><br></pre></td></tr></table></figure>

<p><font color="gray">许多人认为直接使用这些函数会比STL map速度快，因为STL map中使用了许多模板什么的。其实不然，它们的区别并不在于算法，而在于内存碎片。如果直接使用这些函数，你需要自己去new一些节点，当节点特别多，而且进行频繁的删除和插入的时候，内存碎片就会存在，而STL采用自己的Allocator分配内存，以内存池的方式来管理这些内存，会大大减少内存碎片，从而会提升系统的整体性能。Winter在自己的系统中做过测试，把以前所有直接用isc函数的代码替换成map，程序速度基本一致。当时间运行很长时间后（例如后台服务程序），map的优势就会体现出来。从另外一个方面讲，使用map会大大降低你的编码难度，同时增加程序的可读性。何乐而不为？学习STL map, STL set之数据结构基础</font></p>
<p><strong>linux上进程有5种状态:</strong> </p>
<ol>
<li><p>运行(正在运行或在运行队列中等待) </p>
</li>
<li><p>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) </p>
</li>
<li><p>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) </p>
</li>
<li><p>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) </p>
</li>
<li><p>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) </p>
</li>
</ol>
<p><strong>AVL树</strong></p>
<ul>
<li>任一结点对应的<strong>两颗子树的最大高度差为1</strong>，因此也被称为<strong>高度平衡树</strong></li>
<li>查找 插入和删除再平均和最坏情况下的时间复杂度都是O(lgn)</li>
</ul>
<p><strong>Linux定位内存泄漏</strong></p>
<p>Valgrind</p>
<p>Valgrind是一套Linux下，开源的<strong>仿真调试工具的集合</strong></p>
<p>Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。</p>
<p>Valgrind包括如下工具：</p>
<ol>
<li><strong>Memcheck</strong>。这是valgrind<strong>应用最广泛</strong>的工具，一个重量级的内存检查器，能够<strong>发现开发中绝大多数内存错误使用</strong>情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。 </li>
<li>Callgrind。它主要用来检查程序中函数调用过程中出现的问题。 </li>
<li>Cachegrind。它主要用来检查程序中缓存使用出现的问题。 </li>
<li>Helgrind。它主要用来检查多线程程序中出现的竞争问题。 </li>
<li>Massif。它主要用来检查程序中堆栈使用中出现的问题。 </li>
<li>Extension。可以利用core提供的功能，自己编写特定的内存调试工具</li>
</ol>
<p>Valgrind检测内存<strong>原理</strong>：</p>
<p><img src="https://img-blog.csdn.net/20170523212059218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWR5YW5nMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><strong>关键在于建立了两个全局表</strong></p>
<ol>
<li><p>Valid-Value表</p>
<p>对于进程的整个地址空间中的<strong>每一个字节(byte)</strong>，都有与之<strong>对应的 8 个 bits</strong>；对于 <strong>CPU 的每个寄存器</strong>，也有一个<strong>与之对应的 bit 向量</strong>。这些 bits 负责<strong>记录该字节或者寄存器</strong>值<strong>是否</strong>具有<strong>有效的、已初始化</strong>的值。</p>
</li>
<li><p>Valid-Address表</p>
<p>对于<strong>进程</strong>整个<strong>地址空间中的每一个字节(byte)</strong>，还有与之<strong>对应的 1 个 bit</strong>，负责<strong>记录</strong>该地址<strong>是否能够被读写</strong>。</p>
</li>
</ol>
<p><strong>检测原理：</strong><br>当要<strong>读写</strong>内存中某个字节时，首<strong>先检查这个字节对应的 A bit</strong>。如果该A bit<strong>显示该位置是无效位置</strong>，memcheck <strong>则报告读写错误</strong>。<br>内核（core）<strong>类似于一个虚拟的 CPU 环境</strong>，这样<strong>当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中</strong>。<strong>一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出</strong>，则 memcheck 会<strong>检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误</strong>。</p>
<p><strong>第十七讲 同步互斥</strong></p>
<p>进程并发执行的好处</p>
<ol>
<li>共享资源 降低成本</li>
<li>加速</li>
<li>模块化 易于扩展和复用，多个进程完成一个功能</li>
</ol>
<p>并发编程会出现问题，需要同步互斥来解决</p>
<p><strong>原子操作</strong>：</p>
<ul>
<li>要么操作成功完成</li>
<li>或者操作没有执行</li>
<li>不会出现部分执行的状态</li>
</ul>
<p><strong>再等待的时候，不能做其他事情</strong>——忙等待，占用cpu</p>
<p><strong>锁</strong></p>
<p>利用<strong>两个原子操作</strong>实现一个锁</p>
<ul>
<li><p>Lock.Acquire() 获取锁的拥有权</p>
<p>申请锁，如果没有获得，一直处于等待状态</p>
</li>
<li><p>Lock.Release() 释放锁的拥有权</p>
<p>解锁并<strong>唤醒</strong>任何等待中的进程</p>
</li>
</ul>
<p><strong>进程间的交互关系</strong>：<br>![Screen Shot 2019-08-15 at 4.52.28 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-15 at 4.52.28 PM.png)</p>
<p>互斥mutual exclusion：</p>
<ul>
<li>一个进程占用资源，其他进程不能占用</li>
</ul>
<p>死锁deadlock：</p>
<ul>
<li>多个进程个占用部分资源 形成循环等待</li>
</ul>
<p>饥饿</p>
<ul>
<li>其他进程轮流占用资源，一个进程一直得不到资源</li>
</ul>
<p>代码的<strong>四个区</strong></p>
<p><strong>临界区</strong></p>
<ul>
<li><p>是指进程中<strong>访问临界资源</strong>的一段<strong>需要互斥执行的代码</strong></p>
<p>访问临界资源当然要互斥执行</p>
</li>
</ul>
<p><strong>进入区</strong></p>
<p>检查可否进入临界区的一段代码</p>
<p>如可进入，设置正在访问临界区的标志</p>
<p><strong>退出区</strong></p>
<p>清除正在访问临界区的标志</p>
<p><strong>剩余区</strong></p>
<p>跟我们同步互斥没关系的代码</p>
<p><strong>临界区的访问规则</strong></p>
<ol>
<li><p>空闲则入</p>
</li>
<li><p>忙则等待</p>
</li>
<li><p>有限等待</p>
</li>
<li><p>让权等待（可选）</p>
<p>不能进入临界区的进程，应释放cpu（如转换到阻塞状态），而不是忙等占用cpu</p>
</li>
</ol>
<p><strong>临界区的实现方法</strong></p>
<ul>
<li>禁用中断</li>
<li>软件方法</li>
<li>更高级的抽象方法</li>
</ul>
<p><strong>禁用中断</strong></p>
<p>整个系统由当前进程独占，没有中断，没有上下文切换 因此没有并发</p>
<p><strong>基于软件的同步方法</strong>（可以简单的认为，同步就是有序执行，相互协调）</p>
<p>复杂 尤其是多线程多个临界区的时候，更难协调</p>
<p><strong>高级抽象的同步方法</strong></p>
<p>实际上是<strong>基于硬件提供的同步原语</strong></p>
<p>原子操作指令：由<strong>硬件保证其原子性</strong><br><strong>操作系统</strong>提供<strong>更高级的编程抽象</strong>来<strong>简化进程同步</strong></p>
<p>比如 <strong>锁lock</strong> <strong>信号量semaphore</strong></p>
<p><strong>锁是一个抽象的数据结构</strong>：一个二进制变量+两个原子操作（成员函数）</p>
<ol>
<li><p>一个二进制变量（锁定/解锁）</p>
</li>
<li><p>Lock::Acquire()——锁被释放前<strong>一直等待</strong>，然后<strong>得到锁</strong>，该函数<strong>返回时就已经获得这个锁了</strong></p>
</li>
<li><p>Lock::Release()</p>
<p><strong>释放锁，唤醒任何等待的进程</strong>。</p>
</li>
</ol>
<p>使用锁来控制临界区访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock_next_pid-&gt;Acquire();</span><br><span class="line">new_pid = next_pid++;</span><br><span class="line">lock_next_pid-&gt;Release();</span><br></pre></td></tr></table></figure>

<p><strong>简单介绍几个原子操作指令</strong></p>
<p><strong>TS原子操作指令</strong>Test-and-Set指令，<strong>测试和置位</strong>指令</p>
<ul>
<li>从内存单元中取值</li>
<li>测试该值是否为1（然后返回真或假）</li>
<li>内存单元值设置为1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean TestAndSet(boolean *target)&#123;</span><br><span class="line">		boolean rv = *target;</span><br><span class="line">		*target = true;</span><br><span class="line">		return rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>交换指令</strong>（exchange）</p>
<ul>
<li>交换内存中的两个值（内存都是二进制。。）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Exchange (boolean *a,boolean *b)&#123;</span><br><span class="line">	boolean tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用TS指令实现自旋锁spinlock</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock</span>&#123;</span></span><br><span class="line">	value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire()&#123;</span><br><span class="line">	<span class="keyword">while</span>(test-<span class="keyword">and</span>-<span class="built_in">set</span>(value))</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Release()&#123;</span><br><span class="line">  value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对Acquire的解读：如果value为1，则返回1，同时说明锁被占用，while</p>
<p>一只循环等待，当value为0时，置1并返回0，循环结束。完成了锁的Acquire</p>
<p>Release：将value置0</p>
<p>线程在等待时候要消耗cpu，也就是一直执行TS指令</p>
<p>实现<strong>无忙等待锁</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">	WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire()&#123;</span><br><span class="line">	<span class="keyword">while</span>(test-<span class="keyword">and</span>-<span class="built_in">set</span>(value))&#123;</span><br><span class="line">		add <span class="keyword">this</span> TCB to wait <span class="built_in">queue</span>;</span><br><span class="line">		schedule();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Release()&#123;</span><br><span class="line">	value = <span class="number">0</span>;</span><br><span class="line">	remove one thread t from q;</span><br><span class="line">	wakeup(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入一个等待队列，这样的话，Acquire时，如果锁被占用，我们可以先讲这个进程放到等待队列中去，等待过程放弃cpu的控制权，然后执行调度，使cpu执行其他进程，等到不被占用的时候，cpu再回来执行该线程</p>
<p>多个临界区：一个临界区可以用一把锁</p>
<p><strong>非阻塞和阻塞</strong> 对应<strong>异步和同步</strong></p>
<p><strong>同步</strong>，又称<strong>直接制约关系</strong>，是指多个线程（或进程）为了合作完成任务，<strong>必须严格按照规定的</strong> 某种先后次序来运行。</p>
<p><strong>互斥</strong>，又称<strong>间接制约关系</strong>，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。</p>
<ol>
<li>互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步是指在<strong>互斥的基础上</strong>（大多数情况），通过其它机制实现访问者对资源的<strong>有序访问</strong>。</li>
<li>同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。</li>
<li><strong>互斥是一种特殊的同步</strong>。</li>
</ol>
<p><font color="blue">前者(排队等候)就是同步等待消息，而后者(等待别人通知)就是异步等待消息。在异步消息处理中，等待消息者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码)找到等待该事件的人。</font><br>        <font color="red">而在实际的程序中,同步消息处理就好比简单的read/write操作,它们需要等待这两个操作成功才能返回；而异步处理机制就是类似于select/poll之类的多路复用IO操作，当所关注的消息被触发时，由消息触发机制通知触发对消息的处理。</font></p>
<p>阻塞 非阻塞：关注的是处理消息的机制，阻塞就是等待的时候不能做其他事情，非阻塞就是等待的时候可以做其他事情</p>
<p>异步同步：关注的是消息通知的机制，同步是等待方去询问，异步是被通知（被通知空闲，这时候你可以占用资源）</p>
<p>管道是基于内存文件的通信机制，（管道实际就是放在内存中的一种数据文件，）利用子进程继承父进程的文件描述符，该管道文件可以被父子进程读/写，但是管道本身并不care是谁读写，所以我们在使用时候</p>
<ul>
<li>关闭父进程读端，子进程写端</li>
<li>或者是关闭父进程写端 子进程读端</li>
</ul>
<p>这样才能构造一条父子或者子父之间的<strong>一条</strong>间接通路</p>
<p>我们的进程并不关心 另一端</p>
<p>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制</p>
<p>“消息”就是一个字节序列</p>
<p>消息队列独立于进程，所以进程退出并不会释放已经创建的消息队列</p>
<p>通过msgget创建消息队列，通过msgctl释放消息队列</p>
<p>共享内存是吧同一物理内存区域映射到多个进程虚拟地址空间的通信机制</p>
<p>同一进程的线程，天然共享内存，而不同进程就不一样了，拥有各自独立的内存空间，所以需要引入共享内存机制，来进行不同进程间的通信</p>
<p>共享内存：<strong>快速</strong>，<strong>方便</strong></p>
<p>不需要系统调用，不需要内核和用户的切换</p>
<p><strong>不足</strong>：必须调用额外的<strong>同步机制</strong>来<strong>协调数据访问</strong></p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。</p>
<p>这里的映射和之前的虚拟内存一样 使用<strong>页表</strong></p>
<ul>
<li><p>一个进程写，另一个进程可以立即看见</p>
</li>
<li><p>没有系统调用干预（无需陷入内核态？？）</p>
<ul>
<li>这里指的是访问数据的时候无需要系统调用，使用我们的读写指令就可以了</li>
<li>但是共享关系建立和销毁的时候仍然需要系统调用</li>
</ul>
</li>
<li><p>没有数据复制</p>
</li>
<li><p>不提供同步</p>
<ul>
<li>由程序员提供同步</li>
</ul>
<p>一般配合<strong>信号量</strong>使用</p>
</li>
</ul>
<p><strong>信号量</strong></p>
<p>用信号量表示系统资源的数量</p>
<p>信号量是一种抽象的数据类型，由<strong>一个整型变量sem</strong>和<strong>两个原子操作P V</strong>做成</p>
<p>P：申请资源的时候用的</p>
<p>先使sem<strong>减1</strong>，如果<strong>sem&lt;0</strong>，<strong>进入等待（&lt;0意味着没有响应资源）</strong>，<strong>否则继续执行</strong></p>
<p>V：释放资源的时候使用的</p>
<p>先使sem<strong>+1</strong>，如果<strong>sem&lt;=0</strong>，<strong>唤醒一个等待进程（&lt;=0说明有需要资源的进程在等待）</strong>，</p>
<p><strong>信号量</strong>是<strong>受保护</strong>的<strong>整数变量</strong></p>
<ul>
<li>初始化完成后，只能有P() V()修改</li>
<li>由操作系统保证 P V 是原子操作</li>
</ul>
<p>P可能阻塞（因为没有资源），V不会阻塞</p>
<p>信号量分为两类：</p>
<ul>
<li><p>二进制信号量</p>
<p>资源数目为<strong>0或1</strong></p>
</li>
<li><p>资源信号量</p>
<p>资源数目为任何<strong>非负值</strong></p>
</li>
</ul>
<p><strong>这两者等价，基于一个可以实现另外一个</strong></p>
<p>信号量的使用</p>
<ul>
<li>互斥访问<ul>
<li>临界区的互斥访问控制</li>
</ul>
</li>
<li>条件同步<ul>
<li>线程间的事件等待</li>
</ul>
</li>
</ul>
<p><strong>用信号量实现临界区的互斥访问</strong></p>
<p>一个信号量对应一个临界区</p>
<p>重要！！</p>
<ol>
<li>必须<strong>成对使用</strong>P() 操作和V()操作</li>
<li>P操作保证互斥访问临界资源</li>
<li>V操作在使用后释放临界资源</li>
<li>PV操作<strong>不能次序错误 重复或遗漏</strong></li>
</ol>
<p>![Screen Shot 2019-08-14 at 6.27.24 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 6.27.24 PM.png)</p>
<p>![Screen Shot 2019-08-14 at 6.30.37 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 6.30.37 PM.png)</p>
<p><strong>对信号量和PV操作的理解</strong></p>
<p><strong>信号量是一个类，包含一个数据成员和两个成员函数P操作和V操作</strong></p>
<p>首先信号量受保护，只能被PV操作改变</p>
<p>其次PV操作的一部分是（先）改变信号量的值，然后根据改变后的值的不同做进一步的操作。所以PV操作由两部分组成，一部分是对信号量的改变，二是根据改变后的信号量的值对进程/线程的操作</p>
<p>可以用来做<strong>临界区互斥访问</strong> 和 <strong>条件同步</strong></p>
<p>首先说一下什么是<strong>互斥访问</strong>和<strong>条件同步</strong></p>
<p><strong>互斥访问</strong>：同一时间仅能有一个进程/线程访问/占有某一资源</p>
<p><strong>条件同步</strong>：B线程需要等待A线程的某段代码执行完成后才能执行，否则阻塞</p>
<ul>
<li><p>临界区互斥访问</p>
<ul>
<li>P()操作保证互斥的访问（占据）临界资源</li>
<li>V()操作<strong>保证在使用后释放临界资源</strong></li>
</ul>
</li>
<li><p>条件同步</p>
<p>指的是两个线程A B其中A的一部分执行需要等待B的条件满足才可以继续下去</p>
<p>比如上面的B执行完X模块后，A才能执行N模块</p>
<p>假设P先执行，那么线程A会阻塞直到B执行完X后的V操作后才会唤醒线程A</p>
<p>假设V先执行，说明X模块已经执行，A执行P后继续执行N，没有问题</p>
</li>
</ul>
<p>关于<strong>生产者-消费者问题</strong></p>
<p>![Screen Shot 2019-08-14 at 7.13.29 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 7.13.29 PM.png)</p>
<p>涉及到三个问题：</p>
<ul>
<li>互斥访问（mutex）</li>
<li>缓冲区空的时候消费者不能取，必须等待生产者放入之后才可以（条件同步）</li>
<li>缓冲区满的时候生产者不能存，必须等待消费者取走之后才可以放入（条件同步）</li>
</ul>
<p>对应单个信号量：</p>
<p>mutex 初值1（没有人访问，所以是可以访问）</p>
<p>fullbuffers：填满的个数</p>
<p>emptybuffers：空的个数</p>
<p>假设buffer可以存放n个单位</p>
<p>fullbuffers：没有占位，所以是0 <strong>remove操作对应P -1，add操作对应V +1</strong></p>
<p>emptybuffers：全空，所以是n（n是指buffer可以存储n个单位），对应n个单位才能被填满，<strong>remove操作对应V+1 add操作对应P-1</strong></p>
<p>![Screen Shot 2019-08-14 at 7.26.33 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 7.26.33 PM.png)</p>
<p>上面的三个顺序不能改变 emptybuffer 和 fullbuffer部分，不然会形成死锁</p>
<p><strong>我们需要先检查 再去互斥访问</strong>，如果是满，然后我们去申请，这时候我们已经占用了临界资源，别人不能访问，而我们也没法继续下去（满了当然写不了了），我们会阻塞在fullbuffer/emptybuffer，而别人/别的进程会阻塞在互斥访问mutex上</p>
<p>![Screen Shot 2019-08-14 at 7.34.08 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 7.34.08 PM.png)</p>
<p>管程</p>
<p>改进信号量，处理临界区的麻烦，信号量的PV操作的配对，把这些配对的PV操作集中在一起，就是我们这里说的管程</p>
<p>![Screen Shot 2019-08-14 at 8.00.50 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 8.00.50 PM.png)</p>
<p>锁+信号量——临界区</p>
<p>锁+条件变量——管程</p>
<p>![Screen Shot 2019-08-14 at 8.20.35 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 8.20.35 PM.png)</p>
<p><strong>引入条件变量</strong></p>
<p>管程是一种用于多线程互斥访问共享资源的程序结构</p>
<p>![Screen Shot 2019-08-14 at 8.08.45 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 8.08.45 PM.png)</p>
<p>入口队列加锁，只允许一个线程在管程内部执行</p>
<p>介绍<strong>条件变量</strong>——是为了实现<strong>条件等待</strong></p>
<p>条件变量是一个类，包含了<strong>两个数据成员和两个成员函数</strong></p>
<ul>
<li><p>数据成员：</p>
<ol>
<li>waitQueue q：等待队列，用来放入等待状态的线程</li>
<li>int numWaiting: 整数，用来表示等待队列中正在等待的线程数目</li>
</ol>
</li>
<li><p>成员函数：</p>
<ol>
<li><p>Wait(lock)</p>
<p>首先numWaiting++，表示有一个等待线程要加入等待队列</p>
<p>把该线程放入q队列，并释放管程的互斥访问权lock，执行调度（其他线程可能执行），执行完成后，再重新获取管程的访问权</p>
<p>这里的lock是管程的互斥访问的锁</p>
</li>
<li><p>Signal</p>
<p>首先判断是否有等待的线程numWaiting&gt;0才能释放，</p>
<p>然后从等待队列里去一个线程出来，唤醒，然后numWaiting–</p>
</li>
</ol>
<p><strong>上面wait中的调度其他线程和signal中的唤醒其他线程都需要mutex来协调</strong></p>
<p>mutex：二进制信号量，实现互斥访问。</p>
</li>
</ul>
<p><strong>是一个类，包含numWaiting 和 q数据成员 以及 Wait(lock) Signal两个成员函数</strong></p>
<p><strong>条件变量</strong>是<strong>管程内</strong>的<strong>等待机制</strong></p>
<ul>
<li>进入管程的线程因<strong>资源占用</strong>而进入<strong>等待状态</strong></li>
<li>每个<strong>条件变量</strong>表示一种<strong>等待原因</strong>，对应<strong>一个等待队列</strong></li>
</ul>
<p><strong>Wait()</strong>操作——完成以下两个操作</p>
<ul>
<li><strong>将自己阻塞在等待队列中</strong></li>
<li><strong>唤醒一个等待着或者说释放管程的互斥访问</strong>，允许另一个线程进入管程</li>
</ul>
<p><strong>Signal()</strong>操作</p>
<ul>
<li>将等待队列中的一个线程唤醒</li>
<li>如果等待队列为空，则等同空操作</li>
</ul>
<p><strong>条件变量实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> numWaiting = <span class="number">0</span>;</span><br><span class="line">	WaitQueue q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和信号量不同：<strong>信号量的初值和你的资源数是一致的</strong></p>
<p>numWaiting为正表示<strong>有线程处于等待状态</strong></p>
<p>schedule：调度的意思</p>
<p>如下是<strong>条件变量的</strong>的wait 和 signal操作实现 以及维护的Condition类（一个整数和一个等待队列</p>
<p>![Screen Shot 2019-08-14 at 8.55.21 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-14 at 8.55.21 PM.png)</p>
<p><strong>条件变量</strong>维护一个整数numWaiting：表示处于等待状态的线程个数 和 一个等待队列q</p>
<p>release：释放管程的互斥访问权</p>
<p>require：获取管程的互斥访问权</p>
<p>两个成员函数：</p>
<p>Wait(lock):  </p>
<p>首先numWaiting++，表示有一个等待线程要加入等待队列</p>
<p>把该线程放入q队列，并释放管程的互斥访问权，执行调度（其他线程可能执行），执行完成后，条件满足，再<strong>重新获取管程的访问权</strong></p>
<p>Signal：</p>
<p>首先判断是否有等待的线程numWaiting&gt;0才能释放，</p>
<p>然后从等待队列里取一个线程出来，唤醒，然后numWaiting–</p>
<p><strong>用管程实现生产者—消费者问题</strong></p>
<p>记住：生产者-消费者问题中我们需要解觉：两个条件等待和一个互斥访问</p>
<p>首先我们维护一个类：</p>
<p><strong>两个条件变量来实现两个条件等待，一个入口队列的锁lock实现互斥访问，count是管程内部现有资源的数目，初始值为0</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&#123;</span></span><br><span class="line">	Lock lock;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	condition notFull , notEmpty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们生产者和消费者分别对应一个函数deposit和remove（同信号量的实现方法）</p>
<p>首先我们需要进入管程，这时候我们需要再进入时申请入口的锁，退出时释放锁</p>
<p><strong><em>信号量和管程在这里实现的区别：信号量是先判断是否空/满，再申请互斥访问权，而管程则是先申请再判断，管程是可以这样操作的，因为管程申请了判断如果不符合条件还可以放弃互斥访问权，但是信号量不可以，申请了之后不能放弃，这时有PV操作的工作机制决定的，申请了如果不行会阻塞。</em></strong></p>
<p>![Screen Shot 2019-08-15 at 10.01.59 AM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-15 at 10.01.59 AM.png)</p>
<p><strong>管程条件变量的释放处理方式</strong></p>
<p>两个线程T1和T2</p>
<p>T1进入等待 当T2的条件满足T1时有两种：</p>
<ul>
<li><p>Hansen管程：T2执行完后执行T1</p>
</li>
<li><p>Hoare管程：T2的条件变量满足后唤醒T1并放弃互斥访问权，这时候T1执行完后T2再获得互斥访问权继续执行</p>
<p>![Screen Shot 2019-08-15 at 10.20.02 AM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-15 at 10.20.02 AM.png)</p>
</li>
</ul>
<p>Hasen：连续执行 比Hoare切换少一次，效率更高，用于真是的OS和Java中</p>
<p>Hoare：原理和逻辑上更符合人类的思维，主要见于教材中</p>
<p><strong>Hasen和Hoare中生产者消费者问题的不同</strong></p>
<p>Hasen中时while  Hoare中时if</p>
<p>两个的不同在于，Hasen的while在执行完一次操作后还要继续检查，而if不需要</p>
<p>![Screen Shot 2019-08-15 at 10.57.40 AM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-15 at 10.57.40 AM.png)</p>
<h2 id="二十一讲-文件系统和文件"><a href="#二十一讲-文件系统和文件" class="headerlink" title="二十一讲 文件系统和文件"></a>二十一讲 文件系统和文件</h2><p>文件系统：负责管理持久数据保存的子系统</p>
<p>提供数据<strong>存储</strong>和<strong>访问</strong>功能</p>
<ul>
<li>组织 检索 读写访问数据</li>
<li>大多数计算机系统都有文件系统</li>
<li>google也是一个文件系统</li>
</ul>
<p>文件是具有符号名，由字节序列构成的数据项集合</p>
<ul>
<li>文件系统的基本数据单位</li>
<li>文件名是文件的标识符号 </li>
</ul>
<p>文件系统功能</p>
<ol>
<li><p>分配文件磁盘空间</p>
<p>管理文件块（位置和顺序）</p>
<p>管理空闲空间（位置）</p>
<p>分配算法（策略）</p>
</li>
<li><p>管理文件集合</p>
<p>定位：文件及其内容</p>
<p>命名：通过名字找到文件</p>
<p>文件系统结构：文件组织方式</p>
</li>
<li><p>数据可靠和安全</p>
<p>安全：多层次保护数据安全</p>
<p>可靠：</p>
<p>持久保存文件</p>
<p>避免系统崩溃 媒体错误 攻击等</p>
</li>
</ol>
<p>文件属性</p>
<p>文件头：文件系统元数据中的文件信息</p>
<ul>
<li>文件属性</li>
<li>文件存储位置和顺序</li>
</ul>
<p><strong>第二讲：文件描述符</strong></p>
<p>文件描述符是指<strong>打开的文件</strong>在<strong>内存</strong>当中<strong>所维护的相关信息</strong></p>
<p>文件<strong>访问模式</strong></p>
<p>进程访问文件数据<strong>前</strong>必须<strong>先“打开”文件</strong></p>
<p><strong>内核</strong>跟踪进程打开的所有文件</p>
<p>操作系统为<strong>每个进程</strong>维护<strong>一个打开文件表</strong></p>
<p><strong>文件描述符是打开文件的标识</strong>，是操作系统在打开文件表中维护的打开文件状态和信息</p>
<p>具体包括：</p>
<ol>
<li><p>文件指针</p>
<p>最近一次读写位置</p>
<p>每个进程分别维护自己的打开文件指针</p>
</li>
<li><p>文件打开计数</p>
<p>当前打开文件的次数</p>
<p>最后一个进程关闭文件时，将其从打开文件表中移除</p>
</li>
<li><p>文件的磁盘位置</p>
<p>缓存数据访问信息</p>
</li>
<li><p>访问权限</p>
<p>每个进程的文件访问模式信息</p>
</li>
</ol>
<p>文件的<strong>用户视图</strong>和<strong>系统视图</strong></p>
<p><strong>用户视图</strong>：持久的数据结构</p>
<p>系统访问接口：</p>
<ul>
<li>字节序列的集合（UNIX）</li>
<li>系统不关系存储在磁盘上的数据结构</li>
</ul>
<p>操作系统的文件视图</p>
<ul>
<li>数据块的集合</li>
<li>数据块是逻辑存储单元，而扇区是物理存储单元</li>
<li>块大小可能和扇区大小不一样</li>
</ul>
<p>进程访问文件<strong>最小单位是块</strong>——意味着即便是访问一字节，也需要缓存一个数据块（可能4096字节）</p>
<p>进程如何访问文件</p>
<ul>
<li><p>顺序访问：按字节依次读取</p>
</li>
<li><p>随机访问：</p>
</li>
<li><p>索引访问：依据数据特征索引</p>
<p>通常操作系统不完整提供索引访问</p>
<p>数据库是建立在索引内容的磁盘访问上</p>
</li>
</ul>
<p>文件的共享和访问控制</p>
<p>访问控制：每个用户能获得哪些文件的那些访问权限</p>
<p>访问模式：读 写 执行 删除 列表等</p>
<p>文件访问控制列表（ACL）</p>
<p>&lt;文件实体，权限&gt;</p>
<p>UNIX系统中：&lt;用户|组|所有人，读|写|可执行&gt;</p>
<p>用户表示ID</p>
<p>识别用户，表明每个用户所允许的权限及保护模式</p>
<p>用户标识ID：识别用户，表明每个用户所允许的权限及保护模式</p>
<p>组表示ID：允许用户组成组，并指定了组访问权限</p>
<p><strong>语义一致性</strong></p>
<p>规定多进程如何访问共享文件</p>
<ul>
<li>与同步算法相似</li>
<li>因磁盘IO和网络延迟而设计简单</li>
</ul>
<p>Unix文件系统（UFS）语义</p>
<ul>
<li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li>
<li>共享文件指针允许多用户同时读取和写入文件</li>
</ul>
<p>把一致性的问题<strong>甩给进程去处理</strong></p>
<p><strong>会话语义</strong></p>
<p>写入内容只有当文件关闭时可见</p>
<p><strong>读写锁：</strong></p>
<p>一些操作系统和文件系统提供该功能</p>
<p>目录 文件别名 文件系统</p>
<p>文件以目录的方式组织起来</p>
<p>——<strong>路径的形式</strong>来表示每一个文件</p>
<p>操作系统只允许<strong>内核修改目录</strong>，来确保映射的完整性</p>
<p>文件别名：两个或者多个文件名关联同一个文件——方便共享，减少存储空间</p>
<p>实现：硬链接：多个文件指向一个文件</p>
<p>软链接：功过存储真是文件的逻辑名称来实现（存储的是真实路径）</p>
<p>删除的时候不一样，硬是删除文件，软是删除别名</p>
<p>文件目录的循环：</p>
<ul>
<li>不允许子目录的链接，只允许文件的链接</li>
<li>增加链接时，用循环检测算法确定是否合理</li>
</ul>
<p>名字解析：把<strong>逻辑名字转换成物理资源</strong></p>
<ul>
<li>依据路径名，找到文件系统中的实际文件</li>
<li>遍历目录直到找到目标文件</li>
</ul>
<p>举例：解析”/bin/ls”</p>
<ul>
<li><p>读取根目录的文件头（磁盘<strong>固定位置</strong>）</p>
</li>
<li><p>读取根目录的数据块，搜索”bin”项</p>
</li>
<li><p>读取bin的文件头</p>
</li>
<li><p>读取bin的数据块，搜索ls项</p>
</li>
<li><p>读取ls的文件头</p>
</li>
</ul>
<p>当前工作目录PWD：每个进程都会指向一个文件目录用于解析文件名</p>
<p>相对路径：不必每次从头开始找</p>
<p><strong>文件系统挂载</strong></p>
<p>文件系统需要先挂载才能访问</p>
<h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><ul>
<li><p>磁盘文件系统</p>
<p>文件存储在存储设备上，比如磁盘</p>
</li>
<li><p>数据库文件系统</p>
<p>文件系统是可被寻址（辨识）的</p>
<p>比如WinFS</p>
</li>
<li><p>日志文件系统</p>
<p>记录文件系统的修改/事件</p>
</li>
<li><p>网络/分布式文件系统</p>
<p>NFS SMB AFS GFS</p>
</li>
<li><p>特殊/虚拟文件系统</p>
</li>
</ul>
<p>针对<strong>网络/分布式文件系统</strong></p>
<p>文件可以<strong>通过网络被共享</strong></p>
<ul>
<li><p>文件位于远程服务器</p>
</li>
<li><p>客户端远程挂载在服务器文件系统</p>
</li>
<li><p>标准系统文件访问转换成远程访问</p>
</li>
<li><p>标准文件共享协议</p>
<p>NFS for UNIX CIFS for WIndows</p>
</li>
</ul>
<p>分布式文件系统挑战：</p>
<ul>
<li><p>客户端和客户端上的用户辨别很复杂</p>
<p>例如 NFS不安全</p>
</li>
<li><p>一致性问题</p>
</li>
<li><p>错误处理模式</p>
</li>
</ul>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>VFS Virtual File System</p>
<p>分层结构</p>
<ul>
<li><p>虚拟文件系统，向上提供文件/文件系统API</p>
<p>向下对应各种不同的实际文件系统，提供相应访问接口</p>
</li>
</ul>
<p>目标：针对所有不同文件系统提供抽象</p>
<p>对上提供文件和文件系统接口</p>
<p>内部管理文件和关联的数据结构</p>
<p>高效查询例程 遍历文件系统</p>
<p>与特定文件系统模块的交互</p>
<p>文件系统基本数据结构</p>
<ul>
<li>文件卷控制块 superblock</li>
<li>文件控制块 inode</li>
<li>目录项</li>
</ul>
<h3 id="文件缓存和打开文件"><a href="#文件缓存和打开文件" class="headerlink" title="文件缓存和打开文件"></a>文件缓存和打开文件</h3><ul>
<li>数据块按需读入内存</li>
<li>数据块使用后被缓存</li>
<li>两种数据块缓存方式<ul>
<li>数据块缓存</li>
<li>页缓存：同一缓存数据块和内存页</li>
</ul>
</li>
</ul>
<p><strong>文件描述符</strong>：每个被打开的文件都有一个文件描述符</p>
<p>文件状态信息“目录项 当前文件指针 文件操作设置等</p>
<p><strong>打开文件表：</strong></p>
<ul>
<li>每个进程一个进程打开文件表</li>
<li>一个系统级的打开文件表</li>
<li>有文件被打开时，文件卷就不能被卸载（挂载的反义）</li>
</ul>
<p>一些文件系统提供<strong>文件锁</strong>，用于协调多进程的文件访问</p>
<h3 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h3><p>如何表示分配给一个文件数据块的位置和顺序</p>
<p>分配方式：</p>
<ul>
<li>连续分配</li>
<li>链式分配</li>
<li>索引分配</li>
</ul>
<p>组合到一起来用</p>
<ul>
<li>链式索引块</li>
<li>多级索引块</li>
</ul>
<h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>不需要记录顺序，只需要记录分布情况</p>
<p>跟踪记录文件卷中的未分配的数据块</p>
<h2 id="IO-子系统"><a href="#IO-子系统" class="headerlink" title="IO 子系统"></a>IO 子系统</h2><p>I/O特点：</p>
<ul>
<li>设备接口类型</li>
<li>同步和异步I/O</li>
</ul>
<p>I/O结构</p>
<p>I/O数据传输</p>
<p>磁盘调度</p>
<p>磁盘缓存</p>
<p>三种常见设备接口类型：</p>
<ul>
<li><p>字符设备 如键盘/鼠标 串口等</p>
</li>
<li><p>块设备 如 磁盘驱动器 磁带驱动器 光驱等</p>
</li>
<li><p>网络设备 如：以太网 无线 蓝牙等</p>
<p>访问特征：</p>
<ul>
<li>格式化报文交换</li>
</ul>
<p>I/O命令</p>
<ul>
<li>send/receive 网络报文</li>
<li>通过网络接口支持多种网络协议</li>
</ul>
</li>
</ul>
<p><strong>同步和异步I/O</strong></p>
<p><strong>阻塞I/O</strong>：<strong><font color="red">“Wait”</font></strong></p>
<p>读数据（read）时，<strong>进程</strong>将进入<strong>等待状态</strong>，<strong>直到完成</strong>数据读出</p>
<p>写数据（write）时，<strong>进程</strong>将进入<strong>等待状态</strong>，<strong>直到设备完成</strong>数据写入处理</p>
<p>![Screen Shot 2019-08-17 at 4.29.46 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-17 at 4.29.46 PM.png)</p>
<p><strong>非阻塞I/O</strong>：<strong><font color="red">“ Don’t Wait”</font></strong></p>
<p>命令发出后 我不等待</p>
<p><strong>立即从</strong>read或write<strong>系统调用返回</strong>，返回值为成功传输字节数</p>
<p>read或write的传输字节数可能为0——可能读写不成功后者数据量不一致</p>
<p>![Screen Shot 2019-08-17 at 4.29.32 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-17 at 4.29.32 PM.png)</p>
<p><strong>异步I/O</strong>：<strong><font color="red">“Tell Me Later”</font></strong></p>
<p>读数据时，使用<strong>指针标记</strong>好用户的缓冲区，<strong>立即返回</strong>；<strong>稍后内核</strong>将填充缓冲区并<strong>通知用户</strong></p>
<p>写数据时，使用<strong>指针标记</strong>好用户的缓冲区，<strong>立即返回</strong>；<strong>稍后内核</strong>讲处理数据并<strong>通知用户</strong></p>
<p>驱动程序会等待，但是上层应用程序不会等待，可以去干别的事情</p>
<p>![Screen Shot 2019-08-17 at 4.29.46 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-17 at 4.29.46 PM.png)</p>
<p><strong>I/O结构</strong></p>
<p>![Screen Shot 2019-08-17 at 4.38.05 PM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-17 at 4.38.05 PM.png)</p>
<p><strong>主板南北桥</strong>哈</p>
<p>CPU和设备的连接</p>
<ul>
<li><p>设备控制器</p>
<ul>
<li>CPU和I/O设备间的接口</li>
<li>向CPU提供特殊指令和寄存器</li>
</ul>
</li>
<li><p>I/O地址</p>
<p>CPU用来控制I/O硬件</p>
<p>内存地址或端口号</p>
<ul>
<li>I/O指令</li>
<li>内存映射I/O</li>
</ul>
</li>
<li><p>CPU和设备之间的通信方式</p>
<p>轮询 设备中断和DMA</p>
</li>
</ul>
<p>具体讨论一下I/O指令和内存映射I/O</p>
<p><strong>I/O指令</strong></p>
<ul>
<li>通过I/O端口号访问设备寄存器</li>
<li>特殊的cpu指令</li>
</ul>
<p><strong>内存映射I/O</strong></p>
<ul>
<li>设备的寄存器/存储被映射到内存物理空间中</li>
<li>通过内粗load/store 完成I/O操作</li>
<li>MMU设置映射</li>
</ul>
<p>软件-驱动-硬件</p>
<p>最底层是设备，每个设备对应一个设备控制器，然后在上面每个设备对应自己一个驱动</p>
<p>在上面是I/O子系统，然后上边是内核部分</p>
<p>![Screen Shot 2019-08-18 at 10.40.52 AM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-18 at 10.40.52 AM.png)</p>
<p>![Screen Shot 2019-08-18 at 11.10.38 AM](/Users/liutao/Desktop/screenshot/Screen Shot 2019-08-18 at 11.10.38 AM.png)</p>
<p><strong>I/O数据传输</strong></p>
<p>程序控制I/O（PIO，Programmed I/O）</p>
<ul>
<li><p>通过CPU的in/out或者load/store传输所有数据</p>
</li>
<li><p>特点：</p>
<p>硬件简单 编程容易</p>
<p>消耗的cpu时间和数据量成正比</p>
</li>
<li><p>适用于简单的 小型的设备I/O</p>
</li>
</ul>
<p>直接内存访问（DMA）</p>
<ul>
<li><p>设备控制器可直接访问系统总线</p>
</li>
<li><p>控制器直接与内存互相传输数据</p>
</li>
<li><p>特点</p>
<p>设备传输数据不影响CPU</p>
<p>需要CPU参与设置</p>
</li>
<li><p>适用于高吞吐量的I/O</p>
</li>
</ul>
<p>exit()和_exit()区别：exit()是对</p>
<p><code>_exit</code>的封装，exit()会先刷新流然后调用_exit</p>
<p>_exit调用后立即返回内核，</p>
<p>当程序执行到exit或_exit时，<strong>系统无条件的停止剩下所有操作，清除包括PCB在内的各种数据结构，并终止本进程的运行。</strong></p>
<p>由于Linux的标准函数库中，有一种被称作“缓冲I/O”的操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读取；同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如达到了一定数量或遇到特定字符等），再将缓冲区中的内容一次性写入文件。这种技术大大增加了文件读写的速度，但也给编程代来了一点儿麻烦。比如有一些数据，认为已经写入了文件，实际上因为没有满足特定的条件，它们还只是保存在缓冲区内，这时用_exit()函数直接将进程关闭，缓冲区的数据就会丢失。因此，<strong>要想保证数据的完整性，就一定要使用exit()函数</strong></p>
<p><strong>高性能网络中的IO模型</strong></p>
<p>设计服务端并发模型时，主要有以下<strong>两个关键点</strong>：</p>
<ol>
<li>服务器<strong>如何管理连接</strong>，<strong>获取输入数据</strong></li>
<li>服务器<strong>如何处理请求</strong></li>
</ol>
<p>ps：在 Linux 下实<strong>现高并发网络编程时都是以 IO 复用模型模式为主</strong>。</p>
<p><strong>I/O模型的基本认识</strong></p>
<p>四个概念：同步和异步 阻塞和非阻塞</p>
<p>1）阻塞调用与非阻塞调用；</p>
<p>2）阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回；</p>
<p>3）非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。</p>
<p><strong>阻塞</strong>是指调用方一直在等待而且别的事情什么都不做；<strong>非阻塞</strong>是指调用方先去忙别的事情。</p>
<p>同步：主动问询消息</p>
<p>异步：被通知消息</p>
<p><strong>recvfrom函数</strong>：经socket<strong>接收数据</strong>，视为系统调用</p>
<p>一个输入操作（指输入到socket）包括两个不同的阶段</p>
<ol>
<li><strong>等待</strong>数据准备好</li>
<li>从<strong>内核向进程复制数据</strong></li>
</ol>
<p>对于一个套接字上的输入操作，第一步通常涉及<strong>等待</strong>数据从网络中到达。当所等待分组到达时，它<strong>被复制到内核中的某个缓冲区</strong>。<strong>第二步就是把数据从内核缓冲区复制到应用进程缓冲区</strong>。</p>
<p>程序在系统调用完成上面两步操作（等待和复制），根据</p>
<ol>
<li>调用方式的阻塞 非阻塞——调用者（应用程序<strong>进程</strong>）</li>
<li>操作系统处理应用程序请求，处理方式的同步、异步处理的不同——被调用者（操作系统内核？或者说被调用的那个系统调用函数）处理的方式</li>
</ol>
<p>分为<strong>5种I/O模型</strong></p>
<ul>
<li><p>I/O模型1:<strong>阻塞I/O</strong> blocking I/O</p>
<p>应用程序在从调用recvfrom开始到该函数返回有数据包准备好这段时间时<strong>阻塞的</strong>，也就是<strong>等待</strong>，<strong>recvfrom返回成功</strong>后，应用进程<strong>开始处理</strong>数据报</p>
</li>
</ul>
<p><strong>优点：</strong>程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。</p>
<p><strong>缺点：</strong> <strong>每个连接需要独立的进程/线程单独处理</strong>，当<strong>并发请求量大时</strong>为了维护程序，内存、线程切换<strong>开销较大</strong>，这种模型在<strong>实际生产中很少使用。</strong></p>
<ul>
<li><p>I/O模型2:非阻塞式I/O non-blocking I/O</p>
<p>在非阻塞式 I/O 模型中，<strong>应用程序把</strong>一个<strong>套接口设置为非阻塞</strong>，就是<strong>告诉内核</strong>，当所请求的 <strong>I/O 操作无法完成时</strong>，<strong>不要将进程睡眠</strong>。</p>
<p><strong>而是返回一个错误</strong>，<strong>应用程序基于 I/O 操作函数</strong>将<strong>不断的轮询数据是否已经准备好</strong>，如果<strong>没有准备好，继续轮询，直到数据准备好为止</strong>。</p>
<p>轮询polling：由CPU定时发出询问<strong>，依序询问每一个周边设备是否需要其服务</strong>，有即给予服务，服务结束后再问下一个周边，接着不断周而复始</p>
<p><strong>优点：</strong>不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，<strong>不用阻塞等待，实时性较好。</strong></p>
<p><strong>缺点： ** **轮询将会不断地询问内核</strong>，这将<strong>占用大量的 CPU 时间，系统资源利用率较低</strong>，所以<strong>一般 Web 服务器不使用</strong>这种 I/O 模型。</p>
</li>
<li><p>I/O模型3: <strong>I/O复用模型</strong>（I/O multiplexing）</p>
<p>用到<strong>Select Poll Epoll</strong>函数</p>
<p>这几个函数可以<strong>同时阻塞多个 I/O 操作</strong>，而且可以<strong>同时对多个</strong>读操作，多个写操作的 <strong>I/O 函数进行检测</strong>，<strong>直到有数据可读或可写时，才真正调用 I/O 操作函数</strong>。</p>
<p><strong>优点：</strong>可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源。</p>
<p><strong>缺点：</strong>当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用，占用时间会有增加。</p>
</li>
<li><p>I/O模型4 ：<strong>信号驱动式I/O模型（signal-driven I/O）</strong></p>
<p>在信号驱动式 I/O 模型中，应用程序<strong>使用套接口进行信号驱动 I/O，并安装一个信号处理函数</strong>，<strong>进程继续运行并不阻塞</strong>。</p>
<p>在套接口安装一个信号处理函数</p>
<p>当数据准备好时，<strong>进程会收到一个 SIGIO 信号</strong>，可以<strong>在信号处理函数中调用 I/O 操作函数处理数据</strong>。</p>
<p><strong>优点：</strong>线程并没有在等待数据时被阻塞，可以提高资源的利用率。</p>
<p><strong>缺点：</strong>信号 I/O 在大量 IO 操作时可能会因为<strong>信号队列溢出导致没法通知</strong>。</p>
<p>信号驱动 I/O 尽管对于处理 UDP 套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。</p>
<p>但是，<strong>对于 TCP 而言，信号驱动的 I/O 方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源</strong>，与前几种方式相比优势尽失。</p>
</li>
<li><p>I/O模型5:<strong>异步I/O模型（AIO asynchronous I/O）</strong></p>
<p>由 POSIX 规范定义，应用程序告知内核启动某个操作，并<strong>让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序。</strong></p>
<p>这种模型<strong>与信号驱动模型的主要区别</strong>在于：<strong>信号驱动 I/O</strong> 是由内核<strong>通知</strong>应用程序<strong>何时启动</strong>一个 I/O 操作，而<strong>异步 I/O 模型是</strong>由内核<strong>通知</strong>应用程序 I/O 操作<strong>何时完成。</strong></p>
</li>
</ul>
<p>  这里进程只告诉os我要完成操作，os内核完成后告诉进程，中间不会有进程的recvfrom调用，意味着进程整个过程不会阻塞，效率极高</p>
<p>  优点：异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠。</p>
<p>  <strong>缺点：</strong>要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O。</p>
<p>  而在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时都是以 IO 复用模型模式为主。</p>
<p>关于一个I/O操作：一个是<strong>何时可以启动</strong>，另一个是<strong>启动后到完成</strong>，两个时间段</p>
<p>发起——&gt;等待——&gt;可以启动——&gt;操作——&gt;完成</p>
<p>一个是发起到可以启动的<strong>等待时间</strong>——</p>
<p><em>ps：这的等待是等待数据住呗，也就是拷贝到os内核缓冲区</em></p>
<p>另一个是启动到完成的<strong>操作时间</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-59224b90b60105a38b74de84e277254e_hd.jpg" alt="img"></p>
<p>五种I/O模型<strong>除了异步I/O模型剩下的都是同步I/O模型</strong></p>
<p>注意：阻塞不会占用cpu，阻塞I/O的开销主要在于进程/线程切换，高并发时，大量的进程/线程切换，会带来大量的开销</p>
<p>非阻塞是轮询但不阻塞，进程会一直占用cpu，直到数据准备好。实时性好，但是浪费cpu资源</p>
<p>所有模型中的r<strong>ecvfrom操作都会阻塞进程/线程</strong>，这是该系统调用决定的，<strong>针对于前四种</strong></p>
<p>第五种不会调用recvfrom函数，POSIX有其他定义。。但是不完善</p>
<p>more：</p>
<p>针对linux操作系统而言，将<strong>最高的1G字节</strong>（从虚拟地址0xC0000000到0xFFFFFFFF），<strong>供内核使用，称为内核空间</strong>，而将<strong>较低的3G字节</strong>（从虚拟地址0x00000000到0xBFFFFFFF），<strong>供各个进程使用，称为用户空间</strong></p>
<p><strong>网络IO的本质是socket的读取</strong>，socket在linux系统中<strong>被抽象为流</strong>，<strong>I/O可以理解为是对流的操作</strong>。</p>
<p>对于一次I/O操作（以<strong>read</strong>为例）：</p>
<p>step1:数据会<strong>先被拷贝到操作系统内核的缓冲区</strong>中，——数据到内核空间</p>
<p>step2:然后从<strong>操作系统内核缓冲区</strong> <strong>拷贝</strong> 到 <strong>应用程序地址空间</strong>——内核空间到用户空间——具体的某一个应用程序进程空间</p>
<p>所以相当于是：</p>
<p>step1:<strong>等待数据准备</strong>，先拷贝到os内核缓冲区</p>
<p>step2:<strong>数据拷贝</strong>，从内核拷贝到进程地址空间</p>
<p><strong>对于socket流</strong>而言：</p>
<ol>
<li>第一步：通常涉及<strong>等待网络上的数据分组到达</strong>，然后<strong>被复制到内核的某个缓冲区</strong>。</li>
<li>第二步：把数据<strong>从内核缓冲区复制到应用进程缓冲区</strong>。</li>
</ol>
<p>阻塞：就是被休息，cpu处理其他进程去了。</p>
<p><strong>阻塞I/O</strong>：两个阶段全部阻塞，该应用程序不再消费cpu而只是简单等待响应状态</p>
<p>数据接收到os内核缓冲区以及从os内核缓冲区搬运到进程缓冲区</p>
<p><img src="https://static.oschina.net/uploads/img/201604/20150405_VKYH.png" alt="è¾å¥å¾çè¯´æ"></p>
<p>当用户进程调用了recv()/recvfrom()这个系统调用，<code>kernel就开始了IO的第一个阶段：准备数据</code>（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。<code>第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存</code>，然后<strong>kernel返回结果，用户进程才解除block的状态，重新运行</strong>起来。——<strong><em>也就是kernel返回结果后，进程从阻塞到就绪，再到运行</em></strong></p>
<p><strong>非阻塞I/O</strong></p>
<p>特点：在等待（数据准备）阶段不阻塞，而是<strong>轮询polling</strong></p>
<p><code>设备是以非阻塞的形式打开的</code>。这意味着 IO 操作不会立即完成，<strong>read 操作可能会返回一个错误代码</strong>，<strong>说明</strong>这个命令<strong>不能立即满足</strong>（<strong>EAGAIN 或 EWOULDBLOCK</strong>）。</p>
<p>在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p>
<p><code>也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error</code>。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。<code>这个过程通常被称之为轮询</code>。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。<strong>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态</strong>。<br>如下：</p>
<p><img src="https://static.oschina.net/uploads/img/201604/20152818_DXcj.png" alt="è¾å¥å¾çè¯´æ"></p>
<p>轮询具体实现就是<strong>隔一段时间调用recvfrom</strong>，</p>
<ul>
<li>若无数据报准备好，<strong>内核立即返回EWOULDBLOCK</strong>，这个时候<strong>进程会继续轮询，隔段时间调用recvfrom</strong></li>
<li>知道数据报准备好，此时<strong>进程调用recvfrom会阻塞</strong>，直到<strong>kernel返回结果，用户进程才解除block的状态，重新运行</strong>起来。——<strong><em>也就是kernel返回结果后，进程从阻塞到就绪，再到运行</em></strong></li>
</ul>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并<strong>不需要等待，而是马上就得到</strong>了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p><strong>进程在第一阶段需要不断主动询问</strong></p>
<p><strong>同步非阻塞方式相比同步阻塞方式：</strong></p>
<blockquote>
<p>优点：能够<strong>在等待任务完成的时间里干其他活</strong>了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。<strong>但是也占用了cpu</strong>，但是不需要频繁切换进程/线程。</p>
<p>缺点：<strong>任务完成的响应延迟增大</strong>了，因为每<strong>过一段时间才去轮询</strong>一次read操作，而任务可能在两次轮询之间的任意时间完成。这会<strong>导致整体数据吞吐量的降低</strong>。</p>
</blockquote>
<p><strong>I/O多路复用</strong></p>
<p>轮询会消耗大量cpu时间，后台” 可能有多个任务在同时进行，人们就想到了<strong>循环查询多个任务的完成状态</strong>，只要有<strong>任何一个任务完成，就去处理</strong>它。</p>
<p>而且<strong>轮询不是由进程的用户态来做</strong>，而是<strong>有人帮忙</strong>。这就是所谓的<strong>“I/O多路复用”</strong></p>
<p>select poll和epoll就是做这件事情的——循环查询</p>
<p>epoll会比poll select效率高，，后面会逐步讲解</p>
<p>select调用是内核级别的，select的轮询和非阻塞I/O的轮询去呗在于：</p>
<p>select可以<strong>等待多个socket</strong>，<strong>同时对多个I/O端口监听</strong>，任何一个socket准备好了，就能返回成功，然后进行系统调用recvfrom，进行<strong>第二阶段，这个过程是阻塞的</strong></p>
<p>select或poll调用后，<strong>会阻塞进程</strong>——因为非阻塞I/O里面是进程进行轮询当然是非阻塞，这里是内核进行轮询，数据好了会告诉进程，进程这段时间阻塞，不占用cpu</p>
<p><strong><code>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作</code></strong>。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，<strong>直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数</strong>。</p>
<p>对于多路复用，也就是轮询多个socket。<strong><code>多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了</code></strong></p>
<p><img src="https://static.oschina.net/uploads/img/201604/20164149_LD8E.png" alt="è¾å¥å¾çè¯´æ"></p>
<p>最大的好处：<strong>单个process可</strong>以同时<strong>处理多个网络连接I/O</strong></p>
<p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，<strong>kernel会“监视”所有select负责的socket</strong>，<code>当任何一个socket中的数据准备好了，select就会返回</code>。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<blockquote>
<p>多路复用的特点是<code>通过一种机制一个进程能同时等待IO文件描述符</code>，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。</p>
</blockquote>
<p>相比于blocking I/O，<strong>单个连接</strong>需要调用<strong>两次system call</strong>，而blocking I/O只需要一次</p>
<p>在IO multiplexing Model中，<code>实际中，对于每一个socket，一般都设置成为non-blocking</code>，但是，如上图所示，整个用户的process其实是一直被block的。<code>只不过process是被select这个函数block，而不是被socket IO给block</code>。所以<strong>IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。</strong><br>注意<strong>socket一般设置non-blocking的</strong></p>
<p><strong>对于没有阻塞在recvfrom的理解</strong>：如同non-blocking I/O的过程，调用recvfrom不会阻塞，但是在多路复用I/O模型中，由于调用recvfrom的时候数据已经准备好了，所以直接进入第二阶段数据搬迁过程，这个时间段是阻塞的。</p>
<p>在I/O编程过程中，<code>当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理</code>。I/O多路复用技术<code>通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</code></p>
<p><strong>单线程同时处理多个客户端请求</strong>——系统开销小，不需要额外创建新的进程/线程也不需要维护</p>
<p>主要应用场景：</p>
<p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p>
<p>服务器需要同时处理多种网络协议的套接字。</p>
<p><strong>进程在这里调用select之后，处于阻塞等待的状态</strong>，所以可以归结为<strong>同步模型</strong></p>
<p><strong>从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。【此句很重要！！！】</strong></p>
<p>高并发程序：一般使用<strong>同步非阻塞</strong> 而不是 <strong>多线程 + 同步阻塞</strong></p>
<p>扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，<code>办事大厅里的人数就是并发数，而窗口个数就是并行度</code>。也就是说<code>并发数是指同时进行的任务数（如同时服务的 HTTP 请求）</code>，而<code>并行数是可以同时工作的物理资源数量（如 CPU 核数）</code>。</p>
<p>并发数：同时进行的任务数</p>
<p>并行数：可以同时工作的物理资源数</p>
<p>通过<strong>合理调度任务的不同阶段，并发数可以远远大于并行度</strong>，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种<strong>高并发的情况下</strong>，为<strong>每个任务</strong>（用户请求）<strong>创建一个进程或线程的开销非常大</strong>。<code>而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求</code></p>
<p>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息</p>
<p><code>IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞</code>。所以，<code>把IO多路复用归为同步阻塞模式</code>。</p>
<p><strong>信号驱动式I/O</strong></p>
<p>信号驱动式I/O：首先我们<strong>允许Socket进行信号驱动IO,并安装一个信号处理函数</strong>，<strong>进程继续运行并不阻塞</strong>。当<strong>数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</strong></p>
<p>第二阶段还是阻塞的</p>
<p><img src="https://static.oschina.net/uploads/img/201604/21091434_DsZb.png" alt="è¾å¥å¾çè¯´æ"></p>
<p><strong><em>ps 在某些地方大家会把立即返回和不立即返回混淆的原因，是因为如果不立即返回就会阻塞block。。这是程序/操作系统机制？？，返回后才能根据具体的返回做下一步</em></strong></p>
<p>——上述是自己感悟。。</p>
<p><strong>异步I/O 非阻塞</strong></p>
<p>最大特点：<strong>两个阶段都是非阻塞的</strong></p>
<p>相对于同步IO，异步IO不是顺序执行。<code>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情</code>。等到socket数据准备好了，内核直接复制数据给进程，<code>然后从内核向进程发送通知</code>。<code>IO两个阶段，进程都是非阻塞的</code>。</p>
<p>最后<strong>全部完成后，操作系统向进程发送通知。。</strong></p>
<p><img src="https://static.oschina.net/uploads/img/201604/20175459_gtgw.png" alt="è¾å¥å¾çè¯´æ"></p>
<p>用户进程发起<strong>aio_read操作</strong>之后，<strong>立刻就可以开始去做其它的事</strong>。而另一方面，从kernel的角度，当它<strong>收到到一个asynchronous read之后，<code>首先它会立刻返回，所以不会对用户进程产生任何block</code></strong>。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，<code>当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程</code>，告诉它read操作完成了。</p>
<p>这里就是另外的系统调用了，<strong>不再用recvfrom</strong></p>
<p><strong>在 Linux 中，通知的方式是 “信号”：</strong></p>
<blockquote>
<p><code>如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数</code>，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，<code>一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事</code>。</p>
<p><code>如果这个进程正在内核态忙着做别的事</code>，例如以同步阻塞方式读写磁盘，<code>那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知</code>。</p>
<p><code>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒</code>，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</p>
</blockquote>
<p>关于 select poll epoll</p>
<p>先谈一下wakeup和callback机制，I/O多路复用机制存在的<strong>本质</strong></p>
<p>Linux通过socket<strong>睡眠队列</strong>来管理所有等待socket的某个事件的process，同时通过wakeup机制来异步唤醒整个睡眠队列上等待事件的process，通知process相关事件发生。</p>
<p>socket的<strong>事件发生</strong>的时候，其<strong>会顺序遍历socket睡眠队列上的每个process节点</strong>，调用每个process节点挂载的callback函数。在遍历的过程中，如果遇到某个节点是排他的，那么就终止遍历，总体上会涉及两大逻辑：<strong>（1）睡眠等待逻辑；（2）唤醒逻辑。</strong></p>
<ol>
<li><p>睡眠等待逻辑：涉及select poll epoll_wait的阻塞等待逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1]select、poll、epoll_wait陷入内核，判断监控的socket是否有关心的事件发生了，如果没，则为当前process构建一个wait_entry节点，然后插入到监控socket的sleep_list</span><br><span class="line">[2]进入循环的schedule直到关心的事件发生了</span><br><span class="line">[3]关心的事件发生后，将当前process的wait_entry节点从socket的sleep_list中删除。</span><br></pre></td></tr></table></figure>
</li>
<li><p>唤醒逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]socket的事件发生了，然后socket顺序遍历其睡眠队列，依次调用每个wait_entry节点的callback函数</span><br><span class="line">[<span class="number">2</span>]直到完成队列的遍历或遇到某个wait_entry节点是排他的才停止。</span><br><span class="line">[<span class="number">3</span>]一般情况下callback包含两个逻辑：<span class="number">1.</span>wait_entry自定义的私有逻辑；<span class="number">2.</span>唤醒的公共逻辑，主要用于将该wait_entry的process放入CPU的就绪队列，让CPU随后可以调度其执行。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注意：每个进程可以监控多个socket，而一个socket也可以被多个进程监控，每个socket都有一个sleep_list，里面是多个进程的wait_entry节点</p>
<p>具体逻辑见上</p>
<h3 id="select——1024"><a href="#select——1024" class="headerlink" title="select——1024"></a>select——1024</h3><p>在一个高性能的网络服务上，大多情况下一个服务进程(线程)process需要同时处理多个socket，我们需要公平对待所有socket，对于read而言，那个socket有数据可读，process就去读取该socket的数据来处理。于是对于read，一个朴素的需求就是关心的N个socket是否有数据”可读”，也就是我们期待”可读”事件的通知，而不是盲目地对每个socket调用recv/recvfrom来尝试接收数据。我们应该block在等待事件的发生上，这个事件简单点就是”关心的N个socket中一个或多个socket有数据可读了”，当block解除的时候，就意味着，我们一定可以找到一个或多个socket上有可读的数据。另一方面，根据上面的socket wakeup callback机制，我们不知道什么时候，哪个socket会有读事件发生，<strong>于是，process需要同时插入到这N个socket的sleep_list上</strong>  <strong>等待任意一个socket可读事件发生而被唤醒</strong>，当<strong>process被唤醒的时候，其callback里面应该有个逻辑去检查具体那些socket可读</strong>了。</p>
<p>注意进程在系统调用select之后会阻塞</p>
<p>select的多路复用逻辑：select为<strong>每个socket引入一个poll逻辑</strong>，该<strong>poll逻辑用于收集socket发生的事件</strong></p>
<p>poll逻辑就是<strong>轮询</strong>，<strong>每个socket</strong>不断（有间隔时间）去问询<strong>事件</strong>是否准备好了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">poll()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//其他逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (recieve queque is not empty)</span><br><span class="line">    &#123;</span><br><span class="line">        sk_event |= POLL_IN；</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>select的逻辑</strong>：</p>
<p>select的函数原型：5个参数，后面4个参数都是in/out类型(值可能会被修改返回)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>

<p>当用户process<strong>调用select</strong>的时候，select会将<strong>需要监控的readfds集合拷贝到内核空间</strong>（假设监控的仅仅是socket可读），<strong>然后遍历</strong>自己监控的socket sk，挨个调用sk的poll逻辑以便检查该sk是否有可读事件，遍历完所有的sk后，<strong>如果没有任何一个sk可读，那么select会调用schedule_timeout进入schedule循环，使得process进入睡眠</strong>。如果在timeout时间内<strong>某个sk上有数据可读了，或者等待timeout了，则调用select的process会被唤醒</strong>，接下来<strong>select就是遍历监控的sk集合，挨个收集可读事件并返回给用户了</strong>（这里一个事件发生，还要全部遍历一遍），相应的伪码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (sk <span class="keyword">in</span> readfds)</span><br><span class="line">&#123;</span><br><span class="line">    sk_event.evt = sk.poll();</span><br><span class="line">    sk_event.sk = sk;</span><br><span class="line">    ret_event_for_process;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select存在两个问题：</p>
<p>这里的fds是文件描述符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] 被监控的fds需要从用户空间拷贝到内核空间</span><br><span class="line">    为了减少数据拷贝带来的性能损坏，内核对被监控的fds集合大小做了限制，并且这个是通过宏控制的，大小不可改变(限制为<span class="number">1024</span>)。</span><br><span class="line">[<span class="number">2</span>] 被监控的fds集合中，只要有一个有数据可读，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件</span><br><span class="line">    由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的socket有数据可读了，于是，只能挨个遍历每个socket来收集可读事件。</span><br></pre></td></tr></table></figure>

<p>有三个问题需要解决：</p>
<p>（1）被监控的fds集合限制为1024，<strong>1024太小</strong>了，我们希望<strong>能够有个比较大的可监控fds集合</strong> </p>
<p>（2）fds集合需要从用户空间拷贝到内核空间的问题，我们<strong>希望不需要拷贝</strong> </p>
<p>（3）当被监控的fds中某些有数据可读的时候，我们希望通知更加精细一点，就是我们希望能够<strong>从通知中得到有可读事件的fds列表，而不是需要遍历</strong>整个fds来收集。</p>
<h3 id="poll——鸡肋"><a href="#poll——鸡肋" class="headerlink" title="poll——鸡肋"></a>poll——鸡肋</h3><p>上面select的三个问题，第一个是用法限制，2和3则是性能问题</p>
<p>poll只解决了1024的限制问题</p>
<p>下面是poll的函数原型，poll<strong>改变了fds集合的描述方式</strong>，<strong>使用了pollfd结构而不是select的fd_set结构</strong>，使得poll支持的fds集合限制远大于select的1024。poll虽然解决了fds集合大小1024的限制问题，但是，它并没改变大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll随着监控的socket集合的增加性能线性下降，poll<strong>不适合用于大并发场景。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br></pre></td></tr></table></figure>

<h3 id="epoll——终极武功"><a href="#epoll——终极武功" class="headerlink" title="epoll——终极武功"></a>epoll——终极武功</h3><p>计算机行业中，有两种解决问题的思想：</p>
<ol>
<li>cs领域的任何问题，都可以通过<strong>添加一个中间层</strong>来解决</li>
<li>变集中（中央）处理为分散（分布式）处理</li>
</ol>
<p><strong>1. fds集合拷贝问题的解决</strong></p>
<p>I/O多路复用，必须做两件事</p>
<p>1）准备好**需要监控的fds集合</p>
<p>2）探测并返回fds集合中哪些fd刻度了。</p>
<p>细看select或poll的函数原型，我们会发现，每次调用select或poll都在重复地准备(集中处理)整个需要监控的fds集合。然而对于频繁调用的select或poll而言，<strong>fds集合的变化频率要低得多，我们没必要每次都重新准备(集中处理)整个fds集合</strong>。</p>
<p>于是，epoll<strong>引入了epoll_ctl系统调用</strong>，将高频调用的epoll_wait和低频的epoll_ctl隔离开。同时，epoll_ctl<strong>通过(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)三个操作来分散对需要监控的fds集合的修改，做到了有变化才变更</strong>，将select或poll高频、大块内存拷贝(集中处理)变成epoll_ctl的低频、小块内存的拷贝(分散处理)，避免了大量的内存拷贝。同时，对于<strong>高频epoll_wait的可读就绪的fd集合返回的拷贝问题</strong>，epoll通过<strong>内核与用户空间mmap(内存映射)同一块内存来解决</strong>。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得<strong>这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换</strong>。</p>
<p>另外，epoll<strong>通过epoll_ctl来对监控的fds集合来进行增、删、改</strong>，那么必须涉及到fd的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的fds集合是必不可少的了。在linux <strong>2.6.8之前</strong>的内核，epoll<strong>使用hash来组织fds集合</strong>，于是在创建epoll fd的时候，epoll需要初始化hash的大小。于是epoll_create(int size)有一个参数size，以便内核根据size的大小来分配hash的大小。在<strong>linux 2.6.8以后</strong>的内核中，epoll<strong>使用红黑树</strong>来组织监控的fds集合，于是epoll_create(int size)的参数size实际上已经没有意义了。</p>
<p><strong>2 按需遍历就绪的fds集合</strong></p>
<p>通过上面的socket的睡眠队列唤醒逻辑我们知道，socket唤醒睡眠在其睡眠队列的wait_entry(process)的时候会调用wait_entry的回调函数callback，并且，我们可以在callback中做任何事情。<strong>为了做到只遍历就绪的fd，我们需要有个地方来组织那些已经就绪的fd</strong>。为此，epoll引入了一个中间层，一个双向链表(ready_list)，一个单独的睡眠队列(single_epoll_wait_list)，并且，与select或poll不同的是，<strong>epoll的process不需要同时插入到多路复用的socket集合的所有睡眠队列中，相反process只是插入到中间层的epoll的单独睡眠队列中</strong>，process<strong>睡眠在epoll的单独队列上，等待事件的发生</strong>。</p>
<p>同时，引入一个中间的wait_entry_sk，它与某个socket sk密切相关，wait_entry_sk睡眠在sk的睡眠队列上，其<strong>callback函数逻辑是将当前sk排入到epoll的ready_list中，并唤醒epoll的single_epoll_wait_list</strong>。</p>
<p><strong>而single_epoll_wait_list上睡眠的process的回调函数就明朗了：遍历ready_list上的所有sk，挨个调用sk的poll函数收集事件，然后唤醒process从epoll_wait返回。</strong></p>
<p>引入两个：</p>
<p>一个是ready_list ，当某个socket事件到达时，</p>
<p>同时，引入一个中间的wait_entry_sk，它与某个socket sk密切相关，wait_entry_sk睡眠在sk的睡眠队列上，其callback函数逻辑是将当前sk排入到epoll的ready_list中，并唤醒epoll的single_epoll_wait_list。而single_epoll_wait_list上睡眠的process的回调函数就明朗了：遍历ready_list上的所有sk，挨个调用sk的poll函数收集事件，然后唤醒process从epoll_wait返回</p>
<p>也就是主要是有一个ready_list在socket事件到达后会有call_back的逻辑把当前sk（也就是socket事件到达的），放到ready_list中</p>
<p>那么后续唤醒single_epoll_wait_list上的睡眠的process的回调函数</p>
<p>只会爱个调用ready_list上的sk，挨个调用sk的poll函数收集事件，然后唤醒process从epoll_wait返回</p>
<p><strong>简单一句话，就是通过callback逻辑 维护了一个ready_list，这个list中保存了当前事件到达的socket</strong>，后面我们只需要遍历这个ready_list上的socket，然后返回给用户就可以了</p>
<p>于是，整个过来可以分为以下几个逻辑：</p>
<p>（1）epoll_ctl EPOLL_CTL_ADD逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] 构建睡眠实体wait_entry_sk，将当前socket sk关联给wait_entry_sk，并设置wait_entry_sk的回调函数为epoll_callback_sk</span><br><span class="line">[<span class="number">2</span>] 将wait_entry_sk排入当前socket sk的睡眠队列上</span><br></pre></td></tr></table></figure>

<p>回调函数epoll_callback_sk的逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] 将之前关联的sk排入epoll的ready_list</span><br><span class="line">[<span class="number">2</span>] 然后唤醒epoll的单独睡眠队列single_epoll_wait_list</span><br></pre></td></tr></table></figure>

<p>（2）epoll_wait逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] 构建睡眠实体wait_entry_proc，将当前process关联给wait_entry_proc，并设置回调函数为epoll_callback_proc</span><br><span class="line">[<span class="number">2</span>] 判断epoll的ready_list是否为空，如果为空，则将wait_entry_proc排入epoll的single_epoll_wait_list中，随后进入schedule循环，这会导致调用epoll_wait的process睡眠。</span><br><span class="line">[<span class="number">3</span>] wait_entry_proc被事件唤醒或超时醒来，wait_entry_proc将被从single_epoll_wait_list移除掉，然后wait_entry_proc执行回调函数epoll_callback_proc</span><br></pre></td></tr></table></figure>

<p>回调函数epoll_callback_proc的逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] 遍历epoll的ready_list，挨个调用每个sk的poll逻辑收集发生的事件，对于监控可读事件而已，ready_list上的每个sk都是有数据可读的，这里的遍历必要的(不同于select/poll的遍历，它不管有没数据可读都需要遍历一些来判断，这样就做了很多无用功。)</span><br><span class="line">[<span class="number">2</span>] 将每个sk收集到的事件，通过epoll_wait传入的events数组回传并唤醒相应的process。</span><br></pre></td></tr></table></figure>

<p>（3）epoll唤醒逻辑 整个epoll的协议栈唤醒逻辑如下(对于可读事件而言)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] 协议数据包到达网卡并被排入socket sk的接收队列</span><br><span class="line">[<span class="number">2</span>] 睡眠在sk的睡眠队列wait_entry被唤醒，wait_entry_sk的回调函数epoll_callback_sk被执行</span><br><span class="line">[<span class="number">3</span>] epoll_callback_sk将当前sk插入epoll的ready_list中</span><br><span class="line">[<span class="number">4</span>] 唤醒睡眠在epoll的单独睡眠队列single_epoll_wait_list的wait_entry，wait_entry_proc被唤醒执行回调函数epoll_callback_proc</span><br><span class="line">[<span class="number">5</span>] 遍历epoll的ready_list，挨个调用每个sk的poll逻辑收集发生的事件</span><br><span class="line">[<span class="number">6</span>] 将每个sk收集到的事件，通过epoll_wait传入的events数组回传并唤醒相应的process。</span><br></pre></td></tr></table></figure>

<p>epoll巧妙的引入一个中间层解决了大量监控socket的无效遍历问题。细心的同学会发现，epoll在中间层上为每个监控的socket准备了一个单独的回调函数epoll_callback_sk，而对于select/poll，所有的socket都公用一个相同的回调函数。正是这个单独的回调epoll_callback_sk使得每个socket都能单独处理自身，当自己就绪的时候将自身socket挂入epoll的ready_list。同时，epoll引入了一个睡眠队列single_epoll_wait_list，分割了两类睡眠等待。process不再睡眠在所有的socket的睡眠队列上，而是睡眠在epoll的睡眠队列上，在等待”任意一个socket可读就绪”事件。而中间wait_entry_sk则代替process睡眠在具体的socket上，当socket就绪的时候，它就可以处理自身了。</p>
<h3 id="5-3-ET-Edge-Triggered-边沿触发-vs-LT-Level-Triggered-水平触发"><a href="#5-3-ET-Edge-Triggered-边沿触发-vs-LT-Level-Triggered-水平触发" class="headerlink" title="5.3 ET(Edge Triggered 边沿触发) vs LT(Level Triggered 水平触发)"></a>5.3 ET(Edge Triggered 边沿触发) vs LT(Level Triggered 水平触发)</h3><p><strong>5.3.1 ET vs LT - 概念</strong></p>
<p>说到Epoll就不能不说说Epoll事件的两种模式了，下面是两个模式的基本概念</p>
<ul>
<li>Edge Triggered (ET) 边沿触发</li>
</ul>
<p>.socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件</p>
<p>.socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件</p>
<p>仅在缓冲区状态变化时触发事件，比如数据缓冲去从无到有的时候(不可读-可读)</p>
<ul>
<li>Level Triggered (LT) 水平触发</li>
</ul>
<p>.socket接收缓冲区不为空，有数据可读，则读事件一直触发</p>
<p>.socket发送缓冲区不满可以继续写入数据，则写事件一直触发</p>
<p>符合思维习惯，epoll_wait返回的事件就是socket的状态</p>
<p>通常情况下，大家都认为ET模式更为高效，实际上是不是呢？下面我们来说说两种模式的本质：</p>
<p>我们来回顾一下，5.2节（3）epoll唤醒逻辑 的第五个步骤</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>] 遍历epoll的ready_list，挨个调用每个sk的poll逻辑收集发生的事件</span><br></pre></td></tr></table></figure>

<p>大家是不是有个疑问呢：挂在ready_list上的sk什么时候会被移除掉呢？其实，sk从ready_list移除的时机正是区分两种事件模式的本质。因为，通过上面的介绍，我们知道ready_list是否为空是epoll_wait是否返回的条件。于是，在两种事件模式下，步骤5如下：</p>
<p>对于Edge Triggered (ET) 边沿触发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>] 遍历epoll的ready_list，将sk从ready_list中移除，然后调用该sk的poll逻辑收集发生的事件</span><br></pre></td></tr></table></figure>

<p>对于Level Triggered (LT) 水平触发：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5.1</span>] 遍历epoll的ready_list，将sk从ready_list中移除，然后调用该sk的poll逻辑收集发生的事件</span><br><span class="line">[<span class="number">5.2</span>] 如果该sk的poll函数返回了关心的事件(对于可读事件来说，就是POLL_IN事件)，那么该sk被重新加入到epoll的ready_list中。</span><br></pre></td></tr></table></figure>

<p>对于可读事件而言，在ET模式下，如果某个socket有新的数据到达，那么该sk就会被排入epoll的ready_list，从而epoll_wait就一定能收到可读事件的通知(调用sk的poll逻辑一定能收集到可读事件)。于是，我们通常理解的缓冲区状态变化(从无到有)的理解是不准确的，准确的理解应该是是否有新的数据达到缓冲区。</p>
<p>而在LT模式下，某个sk被探测到有数据可读，那么该sk会被重新加入到read_list，那么在该sk的数据被全部取走前，下次调用epoll_wait就一定能够收到该sk的可读事件(调用sk的poll逻辑一定能收集到可读事件)，从而epoll_wait就能返回。</p>
<p><strong>5.3.2 ET vs LT - 性能</strong></p>
<p>通过上面的概念介绍，我们知道对于可读事件而言，LT比ET多了两个操作：(1)对ready_list的遍历的时候，对于收集到可读事件的sk会重新放入ready_list；(2)下次epoll_wait的时候会再次遍历上次重新放入的sk，如果sk本身没有数据可读了，那么这次遍历就变得多余了。 在服务端有海量活跃socket的时候，LT模式下，epoll_wait返回的时候，会有海量的socket sk重新放入ready_list。如果，用户在第一次epoll_wait返回的时候，将有数据的socket都处理掉了，那么下次epoll_wait的时候，上次epoll_wait重新入ready_list的sk被再次遍历就有点多余，这个时候LT确实会带来一些性能损失。然而，实际上会存在很多多余的遍历么？</p>
<p>先不说第一次epoll_wait返回的时候，用户进程能否都将有数据返回的socket处理掉。在用户处理的过程中，如果该socket有新的数据上来，那么协议栈发现sk已经在ready_list中了，那么就不需要再次放入ready_list，也就是在LT模式下，对该sk的再次遍历不是多余的，是有效的。同时，我们回归epoll高效的场景在于，服务器有海量socket，但是活跃socket较少的情况下才会体现出epoll的高效、高性能。因此，在实际的应用场合，绝大多数情况下，ET模式在性能上并不会比LT模式具有压倒性的优势，至少，目前还没有实际应用场合的测试表面ET比LT性能更好。</p>
<p><strong>5.3.3 ET vs LT - 复杂度</strong></p>
<p>我们知道，对于可读事件而言，在阻塞模式下，是无法识别队列空的事件的，并且，事件通知机制，仅仅是通知有数据，并不会通知有多少数据。于是，在阻塞模式下，在epoll_wait返回的时候，我们对某个socket_fd调用recv或read读取并返回了一些数据的时候，我们不能再次直接调用recv或read，因为，如果socket_fd已经无数据可读的时候，进程就会阻塞在该socket_fd的recv或read调用上，这样就影响了IO多路复用的逻辑(我们希望是阻塞在所有被监控socket的epoll_wait调用上，而不是单独某个socket_fd上)，造成其他socket饿死，即使有数据来了，也无法处理。</p>
<p>接下来，我们只能再次调用epoll_wait来探测一些socket_fd，看是否还有数据可读。在LT模式下，如果socket_fd还有数据可读，那么epoll_wait就一定能够返回，接着，我们就可以对该socket_fd调用recv或read读取数据。然而，在ET模式下，尽管socket_fd还是数据可读，但是如果没有新的数据上来，那么epoll_wait是不会通知可读事件的。这个时候，epoll_wait阻塞住了，这下子坑爹了，明明有数据你不处理，非要等新的数据来了在处理，那么我们就死扛咯，看谁先忍不住。</p>
<p>等等，在阻塞模式下，不是不能用ET的么？是的，正是因为有这样的缺点，ET强制需要在非阻塞模式下使用。在ET模式下，epoll_wait返回socket_fd有数据可读，我们必须要读完所有数据才能离开。因为，如果不读完，epoll不会在通知你了，虽然有新的数据到来的时候，会再次通知，但是我们并不知道新数据会不会来，以及什么时候会来。由于在阻塞模式下，我们是无法通过recv/read来探测空数据事件，于是，我们必须采用非阻塞模式，一直read直到EAGAIN。因此，ET要求socket_fd非阻塞也就不难理解了。</p>
<p>另外，epoll_wait原本的语意是：监控并探测socket是否有数据可读(对于读事件而言)。LT模式保留了其原本的语意，只要socket还有数据可读，它就能不断反馈，于是，我们想什么时候读取处理都可以，我们永远有再次poll的机会去探测是否有数据可以处理，这样带来了编程上的很大方便，不容易死锁造成某些socket饿死。相反，ET模式修改了epoll_wait原本的语意，变成了：监控并探测socket是否有新的数据可读。</p>
<p>于是，在epoll_wait返回socket_fd可读的时候，我们需要小心处理，要不然会造成死锁和socket饿死现象。典型如listen_fd返回可读的时候，我们需要不断的accept直到EAGAIN。假设同时有三个请求到达，epoll_wait返回listen_fd可读，这个时候，如果仅仅accept一次拿走一个请求去处理，那么就会留下两个请求，如果这个时候一直没有新的请求到达，那么再次调用epoll_wait是不会通知listen_fd可读的，于是epoll_wait只能睡眠到超时才返回，遗留下来的两个请求一直得不到处理，处于饿死状态。</p>
<p><strong>5.3.4 ET vs LT - 总结</strong></p>
<p>最后总结一下，ET和LT模式下epoll_wait返回的条件</p>
<ul>
<li>ET - 对于读操作</li>
</ul>
<p>[1] 当接收缓冲buffer内待读数据增加的时候时候(由空变为不空的时候、或者有新的数据进入缓冲buffer)</p>
<p>[2] 调用epoll_ctl(EPOLL_CTL_MOD)来改变socket_fd的监控事件，也就是重新mod socket_fd的EPOLLIN事件，并且接收缓冲buffer内还有数据没读取。(这里不能是EPOLL_CTL_ADD的原因是，epoll不允许重复ADD的，除非先DEL了，再ADD) 因为epoll_ctl(ADD或MOD)会调用sk的poll逻辑来检查是否有关心的事件，如果有，就会将该sk加入到epoll的ready_list中，下次调用epoll_wait的时候，就会遍历到该sk，然后会重新收集到关心的事件返回。</p>
<ul>
<li>ET - 对于写操作</li>
</ul>
<p>[1] 发送缓冲buffer内待发送的数据减少的时候(由满状态变为不满状态的时候、或者有部分数据被发出去的时候) [2] 调用epoll_ctl(EPOLL_CTL_MOD)来改变socket_fd的监控事件，也就是重新mod socket_fd的EPOLLOUT事件，并且发送缓冲buffer还没满的时候。</p>
<ul>
<li>LT - 对于读操作 LT就简单多了，唯一的条件就是，接收缓冲buffer内有可读数据的时候</li>
<li>LT - 对于写操作 LT就简单多了，唯一的条件就是，发送缓冲buffer还没满的时候</li>
</ul>
<p>在绝大多少情况下，ET模式并不会比LT模式更为高效，同时，ET模式带来了不好理解的语意，这样容易造成编程上面的复杂逻辑和坑点。因此，建议还是采用LT模式来编程更为舒爽。</p>
<p><strong><em>ps：回调函数</em></strong> </p>
<p>当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为<strong>回调函数</strong>（callback function）。</p>
<p>打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为<strong>登记回调函数</strong>（to register a callback function）</p>
<p><img src="https://pic4.zhimg.com/80/0ef3106510e2e1630eb49744362999f8_hd.jpg" alt="img"></p>
<p>可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再<strong>回</strong>过头来<strong>调</strong>用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因</p>
<p><strong>网络编程中的线程模型</strong></p>
<p>具体选择线程还是进程，更多是与<strong>平台及编程语言相关</strong></p>
<p> C 语言使用线程和进程都可以(例如 Nginx 使用进程，Memcached 使用线程)，Java 语言一般使用线程(例如 Netty)，</p>
<h3 id="线程模型1-传统阻塞I-O服务模型"><a href="#线程模型1-传统阻塞I-O服务模型" class="headerlink" title="线程模型1:传统阻塞I/O服务模型"></a><strong>线程模型1:传统阻塞I/O服务模型</strong></h3><p><img src="http://www.52im.net/data/attachment/forum/201809/06/195333v2cj2o6y92d2zp5z.jpeg" alt="é«æ§è½ç½ç»ç¼ç¨(å­)ï¼ä¸æè¯»æé«æ§è½ç½ç»ç¼ç¨ä¸­ççº¿ç¨æ¨¡å_1.jpeg"></p>
<p><strong>特点</strong></p>
<ol>
<li>采用阻塞式I/O模型获取输入数据</li>
<li>每个连接都需要<strong>独立的线程</strong>来完成数据输入，业务处理，数据返回的<strong>完整操作</strong></li>
</ol>
<p><strong>存在问题</strong></p>
<ol>
<li>并发数较大时，需要创建<strong>大量线程</strong>，系统资源占用较大</li>
<li>连接建立后，如果当前线程没有数据可读，线程就<strong>阻塞在</strong>Read<strong>操作上</strong>，造成线程资源浪费</li>
</ol>
<h3 id="线程模型2-Reactor模式"><a href="#线程模型2-Reactor模式" class="headerlink" title="线程模型2:Reactor模式"></a><strong>线程模型2:Reactor模式</strong></h3><p>针对上面传统阻塞I/O服务模型的两个缺点，有如下<strong>解决方案</strong></p>
<ol>
<li><font color="blue">基于I/O复用模型</font></li>
<li><font color="blue">基于线程池复用线程资源</font></li>
</ol>
<p>I/O复用<strong>结合</strong>线程池，这就是<strong>Reactor模式</strong>的基本设计思想</p>
<p><img src="http://www.52im.net/data/attachment/forum/201809/06/195839s5hi3te5pxueq5ze.jpeg" alt="é«æ§è½ç½ç»ç¼ç¨(å­)ï¼ä¸æè¯»æé«æ§è½ç½ç»ç¼ç¨ä¸­ççº¿ç¨æ¨¡å_2.jpeg"></p>
<p>dispatch：调度</p>
<p>Reactor 模式，是指通过一个或多个输入<strong>同时传递</strong>给服务处理器的服务请求的事件驱动处理模式。 </p>
<p>服务端程序处理传入多路请求，并将它们<strong>同步分派给请求对应的处理线程</strong>，Reactor 模式也叫 <strong>Dispatcher</strong> 模式。</p>
<p>即</p>
<p><strong><font color="blue">I/O复用监听事件，收到事件后分发（Dispatch给某进程），是编写高性能网络服务器的必备技术之一</font></strong></p>
<p>两个部分：监听 &amp; 分发</p>
<p><strong>Reactor模式中有两个关键组成：</strong></p>
<ul>
<li>1）Reactor：Reactor 在一个<strong>单独的线程</strong>中运行，负责<strong>监听和分发</strong>事件，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li>2）Handlers：<strong>处理程序</strong>执行 I/O 事件要<strong>完成的实际事件</strong>，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行<strong>非阻塞操作</strong>。</li>
</ul>
<p><strong>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</strong></p>
<ol>
<li>单Reactor单线程</li>
<li>单Reactor多线程</li>
<li>主从Reactor多线程</li>
</ol>
<h4 id="单Reactor-单线程"><a href="#单Reactor-单线程" class="headerlink" title="单Reactor 单线程"></a>单Reactor 单线程</h4><p><img src="http://www.52im.net/data/attachment/forum/201809/06/200048bgll2l41w72174ot.jpeg" alt="é«æ§è½ç½ç»ç¼ç¨(å­)ï¼ä¸æè¯»æé«æ§è½ç½ç»ç¼ç¨ä¸­ççº¿ç¨æ¨¡å_3.jpeg"></p>
<p>1）Reactor 对象通过 <strong>Select 监控</strong>客户端请求事件，收到事件后通过 <strong>Dispatch 进行分发</strong>；</p>
<p>2）如果是<strong>建立连接请求</strong>事件，则<strong>由 Acceptor 通过 Accept 处理</strong>连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理；</p>
<p>3）如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应；</p>
<p>4）Handler 会完成 Read→业务处理→Send 的完整业务流程。</p>
<p>一个handler对应一个连接的处理，但同一时刻只能有一个handler处理（单线程模式）</p>
<p><strong>优点：</strong>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。<br><strong>缺点：</strong>性能问题，<strong>只有一个线程，无法完全发挥多核 CPU 的性能。</strong>Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。</p>
<p>可靠性问题，线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</p>
<p><strong>使用场景：</strong>客户端的数量有限，业务处理非常快速，比如 Redis，业务处理的时间复杂度 O(1)。</p>
<h4 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h4><p><img src="http://www.52im.net/data/attachment/forum/201809/06/200650wun9j9ghkgk7ngna.jpeg" alt="é«æ§è½ç½ç»ç¼ç¨(å­)ï¼ä¸æè¯»æé«æ§è½ç½ç»ç¼ç¨ä¸­ççº¿ç¨æ¨¡å_4.jpeg"></p>
<ul>
<li>1）Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发；</li>
<li>2）如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后续的各种事件；</li>
<li>3）如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应；</li>
<li>4）<strong>Handler 只负责响应事件，不做具体业务处理</strong>，通过 <strong>Read 读取数据后，会分发给后面的 Worker 线程池进行业务处理</strong>；</li>
<li>5）<strong>Worker 线程池</strong>会分配<strong>独立的线程完成真正的业务处理</strong>，然后将<strong>响应结果发给 Handler</strong> 进行处理；</li>
<li>6）Handler 收到响应结果后通过 Send 将响应结果返回给 Client。</li>
</ul>
<p><strong>优点：</strong>可以充分利用多核 CPU 的处理能力。<br><strong>缺点：</strong>多线程数据共享和访问比较复杂；<strong>Reactor 承担所有事件的监听和响应，在单线程中运行</strong>，<strong>高并发场景下容易成为性能瓶颈。</strong></p>
<h4 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h4><p><img src="http://www.52im.net/data/attachment/forum/201809/06/200759gg777fr7v7wzcr7r.jpeg" alt="é«æ§è½ç½ç»ç¼ç¨(å­)ï¼ä¸æè¯»æé«æ§è½ç½ç»ç¼ç¨ä¸­ççº¿ç¨æ¨¡å_5.jpeg"></p>
<p>针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以<strong>让 Reactor 在多线程中运行。</strong></p>
<p><strong>方案说明：</strong></p>
<ul>
<li>1）Reactor 主线程 MainReactor 对象通过 Select 监控建立连接事件，收到事件后通过 Acceptor 接收，处理建立连接事件；</li>
<li>2）Acceptor 处理建立连接事件后，MainReactor 将连接分配 Reactor 子线程给 SubReactor 进行处理；</li>
<li>3）SubReactor 将连接加入连接队列进行监听，并创建一个 Handler 用于处理各种连接事件；</li>
<li>4）当有新的事件发生时，SubReactor 会调用连接对应的 Handler 进行响应；</li>
<li>5）Handler 通过 Read 读取数据后，会分发给后面的 Worker 线程池进行业务处理；</li>
<li>6）Worker 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 Handler 进行处理；</li>
<li>7）Handler 收到响应结果后通过 Send 将响应结果返回给 Client。</li>
</ul>
<p><strong>优点：</strong>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</p>
<p>父线程与子线程的数据交互简单，<strong>Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</strong></p>
<p>这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>3 种模式可以用个比喻来理解：</strong>（餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务）</p>
<ul>
<li>1）单 Reactor 单线程，接待员和侍应生是同一个人，全程为顾客服务；</li>
<li>2）单 Reactor 多线程，1 个接待员，多个侍应生，接待员只负责接待；</li>
<li>3）主从 Reactor 多线程，多个接待员，多个侍应生。</li>
</ul>
<p><strong>Reactor 模式具有如下的优点：</strong></p>
<ul>
<li>1）响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的；</li>
<li>2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</li>
<li>3）可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源；</li>
<li>4）可复用性，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性。</li>
</ul>
<p><strong>内存碎片</strong></p>
<p>分为内部碎片和外部碎片</p>
<p>这里的内部和外部指的是进程的内部和外部</p>
<ol>
<li>内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就产生了内部碎片，通常内部碎片难以完全避免；<ol start="2">
<li>外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。</li>
</ol>
</li>
</ol>
<p>段页式虚拟存储系统：</p>
<p>段：是分配给进程的一段空间</p>
<p>页：组成段的部分</p>
<p>段页式系统中：页可以不连续（通过页表维护），所以避免了外部碎片</p>
<p>但是一个页中（最后一页）也有用不到的空间，称为内部碎片</p>
<p>针对内存碎片：有两种方法 <strong>伙伴算法</strong> 和 <strong>高速缓存slab层</strong></p>
<p><strong>页的大小固定且由系统确定</strong>, 将逻辑地址划分为页号和页内地址是<strong>由机器硬件实现的</strong>. 而<strong>段的长度却不固定, 决定于用户所编写的程序</strong>, 通常由编译程序在对源程序进行编译时根据信息的性质来划分.</p>
<p>分页的作业地址空间是一维的. 分段的地址空间是二维的.</p>
<p>作业的<strong>最后一页中仍有部分空间被浪费掉</strong>了. 由此可知, 页式虚拟存储系统中存在<strong>内碎片</strong>.</p>
<p>linux kernel会把<strong>物理内存</strong>划分成一个个<strong>page</strong>进行管理，</p>
<p>但是如果对小于page的内存分配，直接分配一个page是一个很大的浪费。linux kernel<strong>通过slab实现对小于page大小的内存分配</strong>。<strong>slab把page按2的m次幂进行划分一个个字节块</strong>，当kmalloc申请内存时，通过slab管理器返回需要满足申请大小的最小空闲内存块。</p>
<p>所以综上，linux kernel的内存管理是个<strong>二层分层系统</strong>，<strong>从下往上</strong>为：</p>
<p>第一层：全部物理内存，管理器为<strong>伙伴系统</strong>，<strong>最小管理单位</strong>为<strong>page</strong></p>
<p>第二层：<strong>slab page</strong>，管理器为<strong>slab/slub</strong>，<strong>最小管理单位为2的m次幂的字节块</strong></p>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p><strong>解决外碎片</strong></p>
<p>所有的<strong>空闲页</strong>分组为<strong>11个链表</strong>，每个链表包含1 2 4 8 16 32 64 128 256 512 1024个<strong>连续的页</strong>。1024个页框的最大请求对应着4MB大小的连续RAM（每页大小为4KB）。</p>
<p>每个块的<strong>第一个页框</strong>的<strong>物理地址是该块大小的整数倍</strong>，例如，大小为16个页框的块，其起始地址是16*2^12的倍数</p>
<p>我们通过一个例子来说明伙伴算法的工作原理，假设现在要<strong>请求一个256个页</strong>框的块（1MB），算法步骤如下：<br>• <strong>在256个页框的链表中检查</strong>是否有一个空闲快，<strong>如果没有，查找下一个更大的块，如果有，请求满足。</strong><br>• <strong>在512个页框的链表中检查是否有一个空闲块</strong>，如果<strong>有，把512个页框的空闲块分为两份</strong>，<strong>第一份用于满足</strong>请求，<strong>第二份链接到256个页框的链表中</strong>。如果没有空闲块，继续寻找下一个更大的块。<br>下图比较形象地描述了该过程。<br><img src="https://img-blog.csdn.net/20180323193130814?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="è¿éåå¾çæè¿°"></p>
<p>以上过程的逆过程，就是页框块的释放过程，也是该算法名字的由来，<strong>内核试图把大小为B的一对空闲伙伴块合并为一个2B的单独块</strong>，满足<strong>以下条件的两个块称之为伙伴</strong>： </p>
<ul>
<li><p>两个块具有<strong>相同的大小</strong> </p>
</li>
<li><p>他们的<strong>物理地址是连续</strong>的</p>
</li>
</ul>
<p>第一块的第一个页框的物理地址是2 * B * 2^12 该<strong>算法是递归的</strong>，如果<strong>它成功合并了B，就会试图去合并2B，</strong>以再次<strong>试图形成更大的块。</strong></p>
<h4 id="高速缓存Slab层"><a href="#高速缓存Slab层" class="headerlink" title="高速缓存Slab层"></a>高速缓存Slab层</h4><p>针对经常分配并且释放的对象，如<strong>进程描述符</strong>，<strong>一般比较小</strong>，如果用伙伴系统进行分配和释放，不仅会造成大量内存碎片，而且处理速度也太慢</p>
<p>而slab分配器是<strong>基于对象进行管理</strong>的，<strong>相同类型的对象归为一类(如进程描述符就是一类)</strong>，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免这些内碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。（有点像内存池？？）</p>
<p>对象高速缓存的组织如右下图所示，高速缓存的内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。</p>
<p> 对象高速缓存的组织如右下图所示，高速缓存的内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。</p>
<p>在cache和object中加入slab分配器，是在时间和空间上的折中方案。</p>
<p> <img src="https://img-blog.csdn.net/20180323193406237?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="è¿éåå¾çæè¿°"></p>
<p>slab分配算法<br>slab分配算法采用cache 存储内核对象。当创建cache 时，起初包括若干标记为空闲的对象。对象的数量与slab的大小有关。开始，所有对象都标记为空闲。当需要内核数据结构的对象时，可以直接从cache 上直接获取，并将对象初始化为使用。<br>下面考虑内核如何将slab分配给表示进程描述符的对象。在Linux系统中，进程描述符的类型是struct task_struct ，其大小约为1.7KB。当Linux 内核创建新任务时，它会从cache 中获得struct task_struct 对象所需要的内存。Cache 上会有已分配好的并标记为空闲的struct task_struct 对象来满足请求。<br>Linux 的slab 可有三种状态：<br>满的：slab 中的所有对象被标记为使用。<br>空的：slab 中的所有对象被标记为空闲。<br>部分：slab 中的对象有的被标记为使用，有的被标记为空闲。<br>slab 分配器首先从部分空闲的slab 进行分配。如没有，则从空的slab 进行分配。如没有，则从物理连续页上分配新的slab，并把它赋给一个cache ，然后再从新slab 分配空间。</p>
<ul>
<li><strong>Linux是如何避免内存碎片的</strong></li>
</ul>
<ol>
<li>伙伴算法，用于管理物理内存，避免内存碎片;</li>
<li>高速缓存Slab层用于管理内核分配内存，避免碎片。</li>
</ol>
<ul>
<li><strong>共享内存的实现原理？</strong> </li>
<li>系统调用与库函数(open, close, create, lseek, write, read)</li>
<li>同步方法有哪些？</li>
</ul>
<h2 id="关于共享内存"><a href="#关于共享内存" class="headerlink" title="关于共享内存"></a>关于共享内存</h2><p>共享内存针对的通过数据共享来实现的进程间通信</p>
<p>首先我们说一下<font color="blue">普通的读写文件原理</font>，进程<strong>调用read或write</strong>后<strong>陷入内核</strong>，因为这是<strong>系统调用</strong>，内核开始读写文件，假设内核在读取文件，内核首先把文件读入自己的内核空间，读完之后进程在内核回归用户态，内核把读入内核内存的数据再copy进入进程的用户态内存空间。实际上我们同一份文件内容相当于读了两次，先读入内核空间，再从内核空间读入用户空间。</p>
<p><font color="blue">数据先搬迁到内核空间，再从内核空间搬迁到用户空间</font>，相当于<strong>两次操作</strong></p>
<p>共享内存</p>
<p>共享内存是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递<strong>不再涉及到内核</strong>，换句话说是进程<strong>不再通过执行进入内核的系统调用</strong>来传递彼此的数据。</p>
<p><strong>mmap函数要求内核创建一个新的虚拟存储器区域，最好是从地址start开始的一个区域，并将文件描述符fd指定对象的一个连续的片（chunk）映射到这个新的区域。</strong></p>
<p> <strong>SHMMNI为128，表示系统中最多可以有128个共享内存对象。</strong></p>
<p>需要某种同步机制，互斥锁和信号量都可以</p>
<p>Linux的2.2.x内核支持多种共享内存方式，如<strong>mmap()系统调用，Posix共享内存，以及系统V共享内存</strong></p>
<p>主要介绍mmap()系统调用及系统V共享内存API的原理及应用。</p>
<p>​      <strong><font color="blue">内存映射函数mmap, 负责把文件内容映射到进程的虚拟内存空间, 通过对这段内存的读取和修改，来实现对文件的读取和修改,而不需要再调用read，write等操作。</font></strong></p>
<p>我们这里是不同进程通过mmap这个系统调用来完成共享内存这件事情的</p>
<p><strong>内核</strong>怎样保证各个进程<strong>寻址到同一个共享内存区域的内存页面</strong></p>
<ol>
<li><p><strong><font color="blue">cache中page的区分</font></strong>（cache分为page cache和swap cache），一个访问的物理page都驻留在page cache<strong>或者</strong>swap cahche中，</p>
<p>一个page的所有信息由<strong>struct page</strong>来描述，</p>
<p>struct page中<strong>有一个</strong>域为<strong>指针mapping</strong>，<strong>指向一个struct address_space。</strong>——<strong><font color="blue">一个文件对应一个address_space</font></strong></p>
<p>page cache或swap cache中的所有页面就是<strong><em>根据address_space结构以及一个偏移量</em></strong>来区分的。</p>
</li>
<li><p><strong><font color="blue">文件与address_space结构的对应</font></strong>，</p>
<p>一个具体的<strong>文件打开后</strong>，内核会在内存中为其建立一个<strong>struct inode</strong>结构，<strong>其中的i_mapping域指向</strong>一个<strong>address_page</strong>结构。这样，</p>
<p><strong>一个文件对一个address_space</strong>，<strong><em>一个address_space 和 一个偏移量就能够确定一个page cache或swap cache的一个页面</em></strong>，</p>
<p>当要<strong>寻址某个数据</strong>，通过<strong>给定文件及数据在文件中的偏移量</strong>找到对应的page</p>
</li>
<li><p>进程<strong>调用mmap()</strong>时，<strong>只是在进程空间内新增了一块</strong>相应大小的<strong>缓冲区</strong>，并<strong>设置了相应的访问标识</strong>，但<strong>并没有建立</strong>进程空间到物理页面的<strong>映射</strong>。因此，<strong>第一次访问</strong>该空间时，会引发一个<strong>缺页异常</strong></p>
</li>
<li><p>对于共享内存映射情况，<strong>缺页异常</strong>处理程序<strong>首先在swap cache</strong>中寻找目标页（符合address_space以及偏移量的物理页），如果找到，则直接返回地址；如果没有找到，则判断该页是否在<strong>交换区(swap area)</strong>，如果在，则执行一个换入操作；如果上述两种情况都不满足，<strong>处理程序将分配新的物理页面，并把它插入到page cache中</strong>。<strong>进程最终将更新进程页表。</strong><br>注：对于映射普通文件情况（非共享映射），缺页异常处理程序首先会在page cache中根据address_space以及数据偏移量寻找相应的页面。如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时，进程页表也会更新</p>
</li>
<li><p>所有进程在映射同一个共享内存区域时，情况都一样，在建立线性地址与物理地址之间的映射之后，不论进程各自的返回地址如何，实际访问的必然是同一个共享内存区域对应的物理页面。<br>注：<strong>一个共享内存区域可以看作是特殊文件系统shm中的一个文件，shm的安装点在交换区（swap）上</strong>。</p>
</li>
</ol>
<p>二、mmap()及其相关系统调用</p>
<p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。</p>
<p>注：实际上，<strong>mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作</strong>。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。</p>
<p>1、mmap()系统调用形式如下：</p>
<p>void* mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset )<br>参数<font color="blue">fd为即将映射到进程空间的文件描述字，一般由open()返回</font>，同时，fd可以指定为-1，此时须指定flags参数中的MAP_ANON，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信）。<font color="blue">len是映射到调用进程地址空间的字节数，它从被映射文件开头offset个字节开始算</font>起。prot 参数指定共享内存的访问权限。可取如下几个值的或：PROT_READ（可读） , PROT_WRITE （可写）, PROT_EXEC （可执行）, PROT_NONE（不可访问）。flags由以下几个常值指定：MAP_SHARED , MAP_PRIVATE , MAP_FIXED，其中，MAP_SHARED , MAP_PRIVATE必选其一，而MAP_FIXED则不推荐使用。<font color="blue">offset参数一般设为0，表示从文件头开始映射</font>。参数<font color="blue">addr指定</font>文件应被映射到进程空间的<font color="blue">起始地址</font>，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。这里不再详细介绍mmap()的参数，读者可参考mmap()手册页获得进一步的信息。</p>
<p>2、系统调用mmap()用于共享内存的两种方式：</p>
<p>（1）<strong>使用普通文件提供的内存映射</strong>：适用于任何进程之间；此时，需要打开或创建一个文件，然后再调用mmap()；典型调用代码如下： </p>
<pre><code>fd=open(name, flag, mode);</code></pre><p>if(fd&lt;0)<br>        …</p>
<p>ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED , fd , 0); 通过mmap()实现共享内存的通信方式有许多特点和要注意的地方，我们将在范例中进行具体说明。 </p>
<p>（2）<strong>使用特殊文件提供匿名内存映射</strong>：适用于具有亲缘关系的进程之间；由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。<br>对于具有亲缘关系的进程实现共享内存最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可，参见范例2。</p>
<p>3、系统调用munmap()</p>
<p>int munmap( void * addr, size_t len )<br>该调用在进程地址空间中<font color="blue">解除一个映射关系</font>，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。</p>
<p>4、系统调用msync()</p>
<p>int msync ( void * addr , size_t len, int flags)<br>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过<font color="blue">调用msync()实现磁盘上文件内容与共享内存区的内容一致</font>。</p>
<p>范例1:两个进程通过映射普通问价实现共享内存通信</p>
<p>两个程序通过<strong>命令行参数指定同一个文件来实现</strong>共享内存方式的进程间通信。</p>
<p>从程序的运行结果中可以得出的结论</p>
<p>1、 最终被映射文件的内容的长度不会超过文件本身的初始大小，即映射不能改变文件的大小；</p>
<p>2、 可以用于进程通信的有效地址空间大小大体上受限于被映射文件的大小，但不完全受限于文件大小。打开文件被截短为5个people结构大小，而在map_normalfile1中初始化了10个people数据结构，在恰当时候（map_normalfile1输出initialize over 之后，输出umap ok之前）调用map_normalfile2会发现map_normalfile2将输出全部10个people结构的值，后面将给出详细讨论。<br>注：在linux中，内存的保护是以页为基本单位的，即使被映射文件只有一个字节大小，内核也会为映射分配一个页面大小的内存。当被映射文件小于一个页面大小时，进程可以对从mmap()返回地址开始的一个页面大小进行访问，而不会出错；但是，如果对一个页面以外的地址空间进行访问，则导致错误发生，后面将进一步描述。因此，可用于进程间通信的有效地址空间大小不会超过文件大小及一个页面大小的和。</p>
<p>3、 文件一旦被映射后，调用mmap()的进程对返回地址的访问是对某一内存区域的访问，暂时脱离了磁盘上文件的影响。所有对mmap()返回地址空间的操作只在内存中有意义，只有在调用了munmap()后或者msync()时，才把内存中的相应内容写回磁盘文件，所写内容仍然不能超过文件的大小。</p>
<p>Linux有两种共享内存，一种是我们的<strong><font color="blue">IPC通信System V版本</font></strong>的共享内存，另一种就是<strong><font color="blue">存储映射I/O(mmap)</font></strong></p>
<p>系统V共享内存指的是<strong>把所有共享数据放在共享内存区域</strong>（IPC shared memory region），<strong>任何想要访问该数据的进程都必须在本进程的地址空间新增一块内存区域，用来映射存放共享数据的物理内存页面</strong>。</p>
<p><strong>系统调用mmap()</strong>通过<strong>映射一个普通文件</strong>实现共享内存。<strong>系统V</strong>则是通过<strong>映射特殊文件系统shm中的文件</strong>实现进程间的共享内存通信。也就是说，每个共享内存区域对应<strong>特殊文件系统shm</strong>中的一个文件（这是<strong>通过shmid_kernel结构联系起来</strong>的），后面还将阐述。</p>
<p>每一个<strong>共享内存区</strong>都有<strong>一个控制结构struct shmid_kernel</strong>，是<strong>存储管理和文件系统结合</strong>起来的桥梁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> /* <span class="title">private</span> <span class="title">to</span> <span class="title">the</span> <span class="title">kernel</span> */</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>        <span class="title">shm_perm</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *                <span class="title">shm_file</span>;</span></span><br><span class="line">        <span class="keyword">int</span>                        id;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>                shm_nattch;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>                shm_segsz;</span><br><span class="line">        <span class="keyword">time_t</span>                        shm_atim;</span><br><span class="line">        <span class="keyword">time_t</span>                        shm_dtim;</span><br><span class="line">        <span class="keyword">time_t</span>                        shm_ctim;</span><br><span class="line">        <span class="keyword">pid_t</span>                        shm_cprid;</span><br><span class="line">        <span class="keyword">pid_t</span>                        shm_lprid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ps：内存对齐，无论是地址对齐还是最后的总大小的对齐，对齐单位都是较小值的整数倍</p>
<p>地址对齐：当前类型的大小和预编译制定的大小的<strong>较小值的整数倍</strong></p>
<p>总大小的对齐：结构中最长类型的大小和预编译制定的大小的<strong>较小值的整数倍</strong></p>
<p>该结构中最重要的一个域应该是<strong>shm_file，它存储了将被映射文件的地址</strong>。每个共享内存区对象都对应特殊文件系统shm中的一个文件，一般情况下，<strong>特殊文件系统shm中的文件是不能用read()、write()等方法访问</strong>的，当采取共享内存的方式把其中的文件映射到进程地址空间后，可<strong>直接采用访问内存的方式对其访问</strong>。</p>
<p><strong>内核通过</strong>数据结构struct <strong>ipc_ids shm_ids维护系统</strong>中的<strong><font color="blue">所有共享内存区域</font></strong>。上图中的<font color="blue">shm_ids.entries变量指向一个ipc_id结构数组</font>，而<font color="blue">每个ipc_id结构数组中有个指向kern_ipc_perm结构的指针</font>。到这里读者应该很熟悉了，对于系统V共享内存区来说，<font color="blue">kern_ipc_perm的宿主是shmid_kernel结构，shmid_kernel是用来描述一个共享内存区域的</font>，这样<strong><font color="blue">内核就能够控制系统中所有的共享区域</font></strong>。同时，在<font color="blue">shmid_kernel结构的file类型指针shm_file指向文件系统shm中相应的文件</font>，这样，<strong>共享内存区域就与shm文件系统中的文件对应</strong>起来</p>
<p>创建了一个共享内存区域后，还要将它映射到进程地址空间，<strong>系统调用shmat()完成共享内存映射到进程地址空间</strong>此项功能，在调用<strong>shmget()时，已经创建了文件系统shm中的一个同名文件与共享内存区域相对应</strong>，因此，调用s<strong>hmat()的过程相当于映射文件系统shm中的同名文件过程</strong>，原理与mmap()大同小异。</p>
<p>systemV 共享内存<strong><font color="blue">API</font></strong></p>
<p><strong>shmget（）</strong>用来获得共享内存区域的ID，如果<strong>不存在指定的共享区域就创建</strong>相应的区域。<strong>shmat()</strong>把共享内存区域<strong>映射</strong>到调用进程的地址空间中去，这样，进程就可以方便地对共享区域进行访问操作。<strong>shmdt()</strong>调用用来<strong>解除</strong>进程对共享内存区域的<strong>映射</strong>。<strong>shmctl实现对共享内存区域的控制</strong>操作。这里我们不对这些系统调用作具体的介绍，读者可参考相应的手册页面，后面的范例中将给出它们的调用方法。</p>
<p>系统V<strong><font color="blue">共享内存限制</font></strong></p>
<p>在/proc/sys/kernel/目录下，记录着系统V共享内存的一下限制，如<strong>一个共享内存区的最大字节数shmmax</strong>，系统范围内<strong>最大共享内存区标识符数shmmni</strong>等，可以手工对其调整，但不推荐这样做。</p>
<p>通过对试验结果分析，对比系统V与mmap()映射普通文件实现共享内存通信，可以得出如下结论：</p>
<p>1、 <strong>系统V共享内存中的数据</strong>，从<strong>来不写入到实际磁盘文件中</strong>去；而通过<strong>mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中</strong>。注：前面讲到，<font color="blue">系统V共享内存机制实际是通过映射特殊文件系统shm中的文件实现的，文件系统shm的安装点在交换分区上，系统重新引导后，所有的内容都丢失</font>。</p>
<p>2、 <strong>系统V共享内存是随内核</strong>持续的，即使<strong>所有访问共享内存的进程都已经正常终止</strong>，<strong>共享内存区仍然存在</strong>（除非显式删除共享内存），在<strong>内核重新引导之前</strong>，对该共享内存区域的任何改写操作都<strong>将一直保留</strong>。</p>
<p>3、 通过调用<strong>mmap()映射普通文件</strong>进行进程间通信时，<strong>一定要注意考虑进程何时终止对通信的影响</strong>。而通过系统V共享内存实现通信的进程则不然。注：这里没有给出shmctl的使用范例，原理与消息队列大同小异。</p>
<p>结论：</p>
<p>共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号灯等同步机制共同使用。</p>
<p>共享内存涉及到了存储管理以及文件系统等方面的知识，深入理解其内部机制有一定的难度，关键还要紧紧抓住内核使用的重要数据结构。系统V共享内存是以文件的形式组织在特殊文件系统shm中的。通过shmget可以创建或获得共享内存的标识符。取得共享内存标识符后，要通过shmat将这个内存区映射到本进程的虚拟地址空间。</p>
<p><strong><em>上文中的信号灯就是信号量semaphore</em></strong></p>
<p>System V版本的共享内存和存储映射I/O(mmap)区别</p>
<p>1<strong>、mmap是在磁盘上建立一个文件</strong>，每个进程地址空间中开辟出一块空间进行映射。<br>而对于shm而言，shm每个进程最终会映射到同一块物理内存。shm保存在物理内存，这样读写的速度要比磁盘要快，但是存储量不是特别大。<br>2、相对于shm来说，mmap更加简单，调用更加方便，所以这也是大家都喜欢用的原因。<br>3、另外mmap有一个好处是当机器重启，因为mmap把文件保存在磁盘上，这个文件还保存了操作系统同步的映像，所以mmap不会丢失，但是shmget就会丢失。</p>
<p>在使用虚拟内存的情况下，<font color="blue">写时复制（Copy-On-Write）是以页为基础进行的</font>。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。</p>
<p>写时复制在内核中的实现非常简单。与<font color="blue">内核页相关的数据结构可以被标记为只读和写时复制</font>。<strong>如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</strong></p>
<p>现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。</p>
<p>在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。</p>
<p>fork和vfork的区别：</p>
<ol>
<li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段</p>
</li>
<li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。</p>
</li>
<li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
</li>
<li><p>当需要改变共享数据段中变量的值，则拷贝父进程。</p>
</li>
</ol>
<p> <strong><font color="red">异常和中断</font></strong></p>
<p>内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p>
<p><strong>如何设计server，使得能够接收多个客户端的请求</strong></p>
<p>参考回答：</p>
<p>多线程，线程池，io复用</p>
<p>怎样确定当前进程繁忙还是阻塞：使用ps命令</p>
<p>就绪状态的进程在等待什么：等待被唤醒，也就是被调度使用cpu的运行权</p>
<p><strong><font color="red">各种问题:生产者消费者 哲学家就餐</font></strong></p>
<p>1、内存溢出</p>
<p>指程序申请内存时，没有足够的内存供申请者使用。<font color="blue">内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</font></p>
<p>2、内存泄漏</p>
<p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是<font color="blue">应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</font></p>
<p><strong><font color="red">协程</font></strong></p>
<p>概念：</p>
<p>协程，又称微线程，纤程，英文名Coroutine。<font color="blue">协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行</font>。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def A() :</span><br><span class="line">print &apos;1&apos;</span><br><span class="line">print &apos;2&apos;</span><br><span class="line">print &apos;3&apos;</span><br><span class="line">def B() :</span><br><span class="line">print &apos;x&apos;</span><br><span class="line">print &apos;y&apos;</span><br><span class="line">print &apos;z&apos;</span><br></pre></td></tr></table></figure>

<p>由协程运行结果<font color="blue">可能是12x3yz</font>。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p>
<p>2）协程和线程区别</p>
<p>那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p><strong><font color="blue">用户态到内核态的切换操作</font></strong></p>
<p>1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/02/剑指offer_201904/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/01/编程之法：面试和算法心得201909/" rel="prev" title>
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">YDE</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法"><span class="nav-number">1.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#冒泡排序"><span class="nav-number">1.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择排序"><span class="nav-number">1.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入排序"><span class="nav-number">1.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">1.4.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序"><span class="nav-number">1.5.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序"><span class="nav-number">1.6.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序"><span class="nav-number">1.7.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计数排序"><span class="nav-number">1.8.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桶排序"><span class="nav-number">1.9.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基数排序"><span class="nav-number">1.10.</span> <span class="nav-text">基数排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#红黑树-AVL树-B树-B-树-Tire树"><span class="nav-number">2.</span> <span class="nav-text">红黑树 AVL树 B树 B+树 Tire树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL树"><span class="nav-number">2.1.</span> <span class="nav-text">AVL树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树"><span class="nav-number">2.2.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-B-树"><span class="nav-number">2.3.</span> <span class="nav-text">B/B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B树的性质"><span class="nav-number">2.3.1.</span> <span class="nav-text">B树的性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树"><span class="nav-number">2.3.2.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-树的性质——提到的都是和B树不同的性质，其他相同"><span class="nav-number">2.3.3.</span> <span class="nav-text">B+树的性质——提到的都是和B树不同的性质，其他相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用"><span class="nav-number">2.3.4.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-B-树性能分析"><span class="nav-number">2.3.5.</span> <span class="nav-text">B/B+树性能分析　</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么说B-tree比B树更适合实际应用中操作系统的文件索引和数据索引"><span class="nav-number">2.3.6.</span> <span class="nav-text">为什么说B+tree比B树更适合实际应用中操作系统的文件索引和数据索引.　</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入分析"><span class="nav-number">2.4.</span> <span class="nav-text">深入分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#区别"><span class="nav-number">2.4.1.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie树-字典树"><span class="nav-number">2.5.</span> <span class="nav-text">Trie树 字典树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本性质"><span class="nav-number">2.5.1.</span> <span class="nav-text">基本性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前缀查询"><span class="nav-number">2.5.2.</span> <span class="nav-text">前缀查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Trie树的应用"><span class="nav-number">2.5.3.</span> <span class="nav-text">Trie树的应用</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#补充部分"><span class="nav-number"></span> <span class="nav-text">补充部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二十一讲-文件系统和文件"><span class="nav-number">1.</span> <span class="nav-text">二十一讲 文件系统和文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统种类"><span class="nav-number">1.1.</span> <span class="nav-text">文件系统种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟文件系统"><span class="nav-number">1.2.</span> <span class="nav-text">虚拟文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件缓存和打开文件"><span class="nav-number">1.3.</span> <span class="nav-text">文件缓存和打开文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件分配"><span class="nav-number">1.4.</span> <span class="nav-text">文件分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空闲空间管理"><span class="nav-number">1.5.</span> <span class="nav-text">空闲空间管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-子系统"><span class="nav-number">2.</span> <span class="nav-text">IO 子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select——1024"><span class="nav-number">2.1.</span> <span class="nav-text">select——1024</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll——鸡肋"><span class="nav-number">2.2.</span> <span class="nav-text">poll——鸡肋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll——终极武功"><span class="nav-number">2.3.</span> <span class="nav-text">epoll——终极武功</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-ET-Edge-Triggered-边沿触发-vs-LT-Level-Triggered-水平触发"><span class="nav-number">2.4.</span> <span class="nav-text">5.3 ET(Edge Triggered 边沿触发) vs LT(Level Triggered 水平触发)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程模型1-传统阻塞I-O服务模型"><span class="nav-number">2.5.</span> <span class="nav-text">线程模型1:传统阻塞I/O服务模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程模型2-Reactor模式"><span class="nav-number">2.6.</span> <span class="nav-text">线程模型2:Reactor模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单Reactor-单线程"><span class="nav-number">2.6.1.</span> <span class="nav-text">单Reactor 单线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单Reactor多线程"><span class="nav-number">2.6.2.</span> <span class="nav-text">单Reactor多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主从Reactor多线程"><span class="nav-number">2.6.3.</span> <span class="nav-text">主从Reactor多线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.7.</span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#伙伴系统"><span class="nav-number">2.7.1.</span> <span class="nav-text">伙伴系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高速缓存Slab层"><span class="nav-number">2.7.2.</span> <span class="nav-text">高速缓存Slab层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于共享内存"><span class="nav-number">3.</span> <span class="nav-text">关于共享内存</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YDE</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
