<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Note,C++,">










<meta name="description" content="final 面经 C++ extern关键字的作用 第一，置于变量/函数前，表示在别的文件中定义了该变量/函数，本文件中找不到去其他文件中寻找 注意，在定义的部分不加extern，以及那些想要共享/使用的文件中也要有加上extern的声明。 你没include该文件还想使用某变量/函数的时候，用extern，到时候编译器会在你编译链接的其他文件中寻找 注意：在同一文件中，变量不可重复声明，但是函数">
<meta name="keywords" content="Note,C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++_Start_2019Fall">
<meta property="og:url" content="http://yoursite.com/2019/09/29/C++_Start_2019Fall/index.html">
<meta property="og:site_name" content="YDE&#39;s Daily">
<meta property="og:description" content="final 面经 C++ extern关键字的作用 第一，置于变量/函数前，表示在别的文件中定义了该变量/函数，本文件中找不到去其他文件中寻找 注意，在定义的部分不加extern，以及那些想要共享/使用的文件中也要有加上extern的声明。 你没include该文件还想使用某变量/函数的时候，用extern，到时候编译器会在你编译链接的其他文件中寻找 注意：在同一文件中，变量不可重复声明，但是函数">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.35.01%20PM.png">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.48.07%20PM.png">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.42.45%20PM.png">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.48.54%20PM.png">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.49.15%20PM.png">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%204.00.13%20PM.png">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%204.00.20%20PM.png">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%204.17.43%20PM.png">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%204.18.50%20PM.png">
<meta property="og:updated_time" content="2019-09-30T06:54:41.303Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++_Start_2019Fall">
<meta name="twitter:description" content="final 面经 C++ extern关键字的作用 第一，置于变量/函数前，表示在别的文件中定义了该变量/函数，本文件中找不到去其他文件中寻找 注意，在定义的部分不加extern，以及那些想要共享/使用的文件中也要有加上extern的声明。 你没include该文件还想使用某变量/函数的时候，用extern，到时候编译器会在你编译链接的其他文件中寻找 注意：在同一文件中，变量不可重复声明，但是函数">
<meta name="twitter:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.35.01%20PM.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/29/C++_Start_2019Fall/">





  <title>C++_Start_2019Fall | YDE's Daily</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YDE's Daily</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Welcome here!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/29/C++_Start_2019Fall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YDE">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YDE's Daily">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++_Start_2019Fall</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-29T19:29:20+08:00">
                2019-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/201909/" itemprop="url" rel="index">
                    <span itemprop="name">201909</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>final</strong> 面经</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><ul>
<li><p>extern关键字的作用</p>
<p>第一，置于<strong>变量/函数前</strong>，表示在别的文件中定义了该变量/函数，本文件中找不到去其他文件中寻找</p>
<p><strong>注意</strong>，在<strong>定义的部分不加</strong>extern，以及那些<strong>想要共享/使用的文件中也要有加上</strong>extern的声明。</p>
<p><strong>你没include该文件还想使用某变量/函数的时候，用extern，到时候编译器会在你编译链接的其他文件中寻找</strong></p>
<p>注意：在同一文件中，变量不可重复声明，但是函数可以。</p>
<p>我们一般include头文件.h，头文件里所有我们都是可以访问的，但是cpp的话我们一般不include，如果我们想要使用其他cpp里的变量，就要在本文件中extern该变量声明，因为这样编译器在本文件中找不到的时候就会去其他文件（指一起编译链接的文件）里找。</p>
<p>第二，<code>extern &quot;C&quot; void fun(int a,int b)</code> 告诉编译器在编译fun这个函数时，按照C的规则而不是C++，</p>
<p>　　<font color="gray">C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</font></p>
<p> extern 和 static</p>
<p> (1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.<br> (2) static 表示静态的变量，分配内存的时候, <strong>存储在静态区,不存储在栈上面.</strong></p>
<p>extern和const可以连用</p>
</li>
<li><p>static关键字作用</p>
<ul>
<li><p>static修饰<strong>局部变量</strong></p>
<p>被修饰的变量成为静态变量，存储在<strong>静态区</strong>，数据<strong>生命周期与程序相同</strong>，<strong>main函数之前</strong>初始化，<strong>程序退出</strong>时销毁</p>
<p>生命周期<strong>不代表</strong>可以<strong>一直被访问</strong>，因为变量的访问还受到其<strong>作用域的限制</strong></p>
<p>局部静态变量在退出函数后不会被销毁，所以<strong>该变量的值</strong>与退出函数与否无关</p>
</li>
<li><p>static修饰<strong>全局变量</strong></p>
<p>全局变量本来就存在于静态区域，所以<strong>不改变存储位置</strong>，但是，static<strong>限制了其链接属性</strong>。</p>
<p>被statci修饰的全局变量<strong>只能被包含该定义的文件访问</strong>。</p>
</li>
<li><p>static修饰<strong>函数</strong></p>
<p>使得该函数<strong>只能在包含该函数定义的文件中被调用</strong></p>
</li>
<li><p>static在<strong>C++中的作用</strong></p>
<p>在类中创建的静态成员变量和静态成员函数。<strong>所有对象只维持一个实例</strong>，——因此，采用static可以实现<strong>不同数据之间的数据共享</strong></p>
</li>
</ul>
</li>
<li><p>volatile限定符</p>
<p><strong>直接处理硬件</strong>的程序常常包含这样的<strong>数据元素</strong>，他们的值由<strong>程序直接控制之外的过程控制</strong>，</p>
<p>当对象的值可能在程序的控制或检测之外被改变时，应将对象声明成volatile。——<strong>告诉编译器不应对这样的对象进行优化</strong></p>
</li>
<li><p>const</p>
<ul>
<li><p>定义常量</p>
<p>const修饰的变量value是不可变的</p>
</li>
<li><p>指针使用const</p>
<p>顶层const：指针本身不可变</p>
<figure class="highlight plain"><figcaption><span>const ptr;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">底层const：指针指向的内容不可变</span><br><span class="line"></span><br><span class="line">```const int* ptr;</span><br></pre></td></tr></table></figure>

<p>既有底层又有顶层：两者都不可变</p>
<figure class="highlight plain"><figcaption><span>int* const ptr;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意const的相互转换/传递，顶层const没啥问题</span><br><span class="line"></span><br><span class="line">  但是底层const：const对象可以接受非const，但是不能将const对象赋给非const对象</span><br><span class="line"></span><br><span class="line">- 接上一条，函数中使用const</span><br><span class="line"></span><br><span class="line">  形参可以是：常量，顶层const，底层const，const引用，注意存在常量引用，但是不存在引用常量</span><br><span class="line"></span><br><span class="line">  这样可以保证常量..在函数内部不被改变</span><br><span class="line"></span><br><span class="line">- const也可以修饰返回值——但很少见</span><br><span class="line"></span><br><span class="line">  多用于操作符的重载</span><br><span class="line"></span><br><span class="line">- 拷贝赋值运算符必须返回const引用，因为返回const会造成无限循环</span><br><span class="line"></span><br><span class="line">- 类相关const</span><br><span class="line"></span><br><span class="line">  - const修饰成员变量</span><br><span class="line"></span><br><span class="line">    表示成员常量不能被修改，**且只能在初始化列表中赋值**</span><br><span class="line"></span><br><span class="line">  - const修饰成员函数</span><br><span class="line"></span><br><span class="line">    类中的this指针默认是顶层const不是底层const，所以**无法绑定常量对象——实例中的常量部分以及常量对象实例**</span><br><span class="line"></span><br><span class="line">    这里与const修饰符与const修饰形参和返回类型不冲突，这里const修饰的是函数调用</span><br><span class="line"></span><br><span class="line">    常量成员函数：不改变对象的成员变量，也不能调用类中任何非const成员函数</span><br><span class="line"></span><br><span class="line">    const成员函数不被允许改它所在对象的任何一个数据成员</span><br><span class="line"></span><br><span class="line">    const成员函数可以访问对象的const成员（对象的常量部分），而其他函数不可以</span><br><span class="line"></span><br><span class="line">  - const修饰类对象/对象指针/对象引用</span><br><span class="line"></span><br><span class="line">    const修饰的类对象表示该对象为常量对象，其中的任何成员都不能修改。对于对象指针和对象引用也是一样</span><br><span class="line"></span><br><span class="line">    const修饰的对象，该对象的任何非const成员函数都不能调用，因为任何非const成员函数都会有修改成员变量的企图</span><br><span class="line"></span><br><span class="line">- 将const类型转换为非const的方法</span><br><span class="line"></span><br><span class="line">  使用**const_cast**转换只能改变运算对象的**底层const**</span><br><span class="line"></span><br><span class="line">  常量指针变非常量指针，并且仍然指向原来对象</span><br><span class="line"></span><br><span class="line">  常量引用变非常量引用，并且仍然绑定原来对象</span><br><span class="line"></span><br><span class="line">  ```C++</span><br><span class="line">  const int constant = 21;</span><br><span class="line">  const int* const_p = &amp;constant;</span><br><span class="line">  int* modifier = const_cast&lt;int*&gt;(const_p);</span><br><span class="line">  *modifier = 7;</span><br></pre></td></tr></table></figure>

<p>如果指针指向的是<strong>非常量对象</strong>，可以通过const_cast后的指针进行值的修改，如果指向的是<strong>常量对象</strong>，则是未定义的行为</p>
</li>
<li><p>建议</p>
<ul>
<li>大胆使用const，但要搞清楚原委</li>
<li>避免一般的赋值/指向/绑定错误</li>
<li>在函数参数中要使用<strong>引用/指针</strong>，而不是对象实例</li>
<li>不要轻易的将函数的返回值类型定为const</li>
<li>除了<strong>重载操作符</strong>和<strong>拷贝赋值运算符</strong>（也属于重载操作符）之外<strong>一般不要将</strong>返回值类型定为<strong>某个对象的const引用</strong></li>
<li>任何不会修改数据成员的<strong>函数</strong>都应该声明为<strong>const类型</strong></li>
</ul>
</li>
<li><p>其他</p>
<p>非const成员函数：this指针是一个<strong>类类型</strong>的</p>
<p>const成员函数中：this指针是一个<strong>const类型</strong>的</p>
<p>volatile成员函数中：this指针是一个<strong>volatile类型</strong>的</p>
</li>
</ul>
</li>
<li><p>new和malloc的区别</p>
<p><strong>动态分配内存</strong>是指<strong>程序运行时/即时对内存的分配</strong>，<strong>不是预先分配</strong>。</p>
<p>new 和 malloc 内存分配在<strong>堆</strong>上</p>
<ul>
<li><p>malloc和free是<strong>库函数</strong>，new和delete是<strong>c++操作符</strong></p>
</li>
<li><p>new<strong>自己计算需要空间大小</strong>，<figure class="highlight plain"><figcaption><span>a </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">malloc需要**指定大小**，```int* a = malloc(sizeof(int));</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>new在动态分配内存时可以<strong>初始化对象</strong>，调用<strong>其构造函数</strong>，delete释放内存时<strong>调用对象的析构函数</strong></p>
<p>而malloc<strong>只</strong>分配一段内存，<strong>返回该内存首地址指针</strong>，失败则返回NULL</p>
<p>C++ <strong>operator</strong>关键字——用于<strong>重载操作符</strong></p>
</li>
<li><p>operator new和operator delete<strong>可以重载</strong>，而<strong>malloc不行</strong></p>
</li>
<li><p>new可以调用malloc实现，但malloc不能调用new来实现</p>
</li>
<li><p>对于数据C++定义new[]专门进行<strong>动态数组分配</strong>，用delete[]进行销毁。<strong>new[]会一次分配内存，然后多次调用构造函数；delete[]会先多次调用析构函数，然后一次性释放</strong></p>
<p>即分配和释放都是<strong>一次性</strong>的</p>
</li>
</ul>
</li>
<li><p><strong>C++多态性和虚函数表</strong></p>
<p><strong>多态</strong>——<strong>一个接口，多种方法</strong>，程序在<strong>运行时才决定</strong>调用的函数，polymorphism</p>
<p>C++多态性是通过<strong>虚函数</strong>来实现的</p>
<p>这里注意<strong>重载overload 隐藏hide 覆盖override</strong></p>
<p>重载：同一类中，相同函数名，不同形参列表</p>
<p>隐藏：<strong>针对非虚成员函数</strong>，派生类中（基类/派生类），和基类相同函数名，此时在<strong>派生类作用域中</strong>该函数名<strong>隐藏了</strong>基类中的函数名，但<strong>不代表没有了</strong>，因为<strong>派生类继承了</strong>，所以可以在Derived类中，通过作用域运算符来访问——Base::func()，<strong>即该函数仍然存在</strong></p>
<p>覆盖：也叫做重写，针对虚函数，实现C++多态，下面看详解</p>
<p><strong><em>！！！多态与非多态的实质区别就是函数地址是早绑定还是晚绑定</em></strong></p>
<p>函数的<strong>调用</strong>在<strong>编译期间</strong>就可以<strong>确定函数的调用地址</strong>，并<strong>生产代码</strong>，是静态的，此时我们说<strong>地址是早绑定的</strong></p>
<p>而函数的调用的地址<strong>不能在编译期间</strong>确定，<strong>运行时才能确定</strong>，这就属于<strong>晚绑定</strong></p>
<p><strong><em>ps：</em></strong></p>
<ul>
<li>封装可以使代码模块化</li>
<li>继承可以扩展已经存在的代码</li>
<li>都是为了<strong>代码重用</strong></li>
</ul>
<p><strong>多态</strong>的目的是为了<strong>接口重用</strong>，<strong>不论传递过来的是哪个类的对象</strong>，通过<strong>同一个接口</strong>调用到<strong>适应各自对象</strong>的实现方法</p>
<p>声明<strong>基类的指针</strong>，可以指向<strong>任意一个子类对象</strong>，<strong>调用相应的虚函数</strong>，根据<strong>指向子类的不同实现不同的方法</strong>。</p>
<p>如果<strong>没有使用虚函数</strong>，基类指针调用相应的函数时，总被<strong>限制在基类本身</strong>，也就是<strong>子类的基类函数部分</strong>，而<strong>虚函数是重写/覆盖了基类的虚函数</strong>，所以也就不存在基类的同名函数部分</p>
<p>（1）如果派生类的函数与基类的函数<strong>同名，但是参数不同</strong>。此时，<strong>不论有无virtual</strong>关键字，基类的函数将被<strong>隐藏</strong>（注意别与重载混淆）。<br>（2）如果派生类的函数与基类的函数<strong>同名，并且参数也相同</strong>，但是基类函数<strong>没有virtual关键字</strong>。此时，基类的函数被<strong>隐藏</strong>（注意别与覆盖混淆）。</p>
<p><strong>纯虚函数</strong>，虚函数后面 <strong>= 0</strong>，<br>w<br>含有纯虚函数的类称为<strong>抽象基类</strong>，<strong>不能创建对象实例</strong></p>
<p>纯虚函数要求<strong>派生类必须重写</strong>。</p>
<p>纯虚函数<strong>提供接口</strong></p>
<p><strong>虚函数表</strong></p>
<p>编译器为每<strong>一个类</strong>维护<strong>一个虚函数表</strong>，注意，这里的<strong>VTable是和类绑定的，不是对象实例</strong>，所以<strong><em>！！！同一个类的不同对象实际指向同一张虚函数表！！！</em></strong></p>
<p>虚函数是通过一张虚函数表<strong>V-Table</strong>来实现的。</p>
<p>主要是一个<strong>类的虚函数的地址表</strong>，</p>
<p>在<strong>有虚函数的类</strong>的<strong>实例</strong>中这个<strong>表被分配</strong>在了<strong>这个实例的内存</strong>中</p>
<p>就像一个<strong>地图map</strong>一样，<strong>指明了实际</strong>所应该<strong>调用的函数</strong></p>
<p>C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）</p>
<p>:我们可以通过<strong>对象实例的地址</strong>得到这张<strong>虚函数表</strong>，并<strong>调用相应函数</strong></p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.35.01%20PM.png" alt="Screen Shot 2019-07-30 at 3.35.01 PM"></p>
<p>最后一个结点是虚函数表的<strong>结束结点</strong>，类似于字符串的’\0’</p>
<p>ok，接下来我们将<strong>继承时的虚函数表</strong></p>
<p>继承分两种：有覆盖继承和无覆盖继承，无覆盖没有意义，重点讨论有覆盖</p>
<ul>
<li><p>无覆盖继承</p>
</li>
<li><p>注意 这里的函数<strong>都是虚函数</strong></p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.48.07%20PM.png" alt="Screen Shot 2019-07-30 at 3.48.07 PM"></p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.42.45%20PM.png" alt="Screen Shot 2019-07-30 at 3.42.45 PM"></p>
<p>可以看到在派生类实例 Derive d中，虚函数<strong>按照声明顺序</strong>放于表中。<strong>基类的虚函数放在子类的虚函数前面</strong></p>
</li>
<li><p>有函数覆盖</p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.48.54%20PM.png" alt="Screen Shot 2019-07-30 at 3.48.54 PM"></p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%203.49.15%20PM.png" alt="Screen Shot 2019-07-30 at 3.49.15 PM"></p>
<p><strong>覆盖的虚函数</strong>放到了<strong>虚表中原来父类虚函数的位置</strong></p>
<p><strong>未被覆盖的函数依旧</strong></p>
<p>所以根据<strong>实际调用的实例不同</strong>，<strong>调用的虚函数不同</strong>，因为<strong>基类和派生类</strong>的<strong>虚表的同样位置</strong>对应的<strong>虚函数不同</strong></p>
</li>
</ul>
<p>多重继承</p>
<ul>
<li><p>无虚函数覆盖</p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%204.00.13%20PM.png" alt="Screen Shot 2019-07-30 at 4.00.13 PM"></p>
<p>派生类实例中的VTable：</p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%204.00.20%20PM.png" alt="Screen Shot 2019-07-30 at 4.00.20 PM"></p>
<p>1.每个<strong>基类都有</strong>自己的<strong>虚表</strong></p>
<p>2.派生类的<strong>虚函数</strong>被放到了<strong>第一个基类的表</strong>中，基类的顺序是按照<strong>派生列表的顺序来说明的</strong></p>
</li>
<li><p>有虚函数<strong>覆盖</strong></p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%204.17.43%20PM.png" alt="Screen Shot 2019-07-30 at 4.17.43 PM"></p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-07-30%20at%204.18.50%20PM.png" alt="Screen Shot 2019-07-30 at 4.18.50 PM"></p>
<p>​     多重继承会有多个虚函数表，几重继承，就会有几个虚函数表。这些表按照派生的顺序依次排列，如果子类改写了父类的虚函数，那么就会用子类自己的虚函数覆盖虚函数表的相应的位置，如果子类有新的虚函数，那么就添加到第一个虚函数表的末尾</p>
</li>
</ul>
</li>
<li><p>动态绑定实现原理</p>
<p>当编译器发现类中有虚函数的时候，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在<strong>类中增加一个指针：vpointer，这个指针是指向对象的虚函数表</strong>。在多态调用的时候，根<strong>据vpointer指针，找到虚函数表</strong>来实现动态绑定。</p>
<p>也就是在<strong>运行时根据vpointer指向的虚表来调用具体的函数</strong>——运行时绑定</p>
</li>
<li><p>静态多态和动态多态</p>
<p>静态多态是指通过<strong>模板技术或者函数重载技术</strong>实现的多态，其在编译器确定行为。动态多态是指通过<strong>虚函数技术</strong>实现在运行期动态绑定的技术。</p>
</li>
<li><p>纯虚函数如何定义，<strong>为什么对于存在虚函数的类中析构函数要定义成虚函数</strong></p>
<p><strong>构造函数</strong> <strong>不可以是虚函数</strong></p>
<p>显然，如果构造函数是虚函数，我们需要一个<strong>虚函数表来调用</strong>，但是<strong>类还没有实例化对象，就没有内存空间，就没有虚函数表</strong>，这是个<strong>死循环</strong></p>
<p><strong>析构函数</strong> <strong>要定义成虚函数</strong></p>
<p>如果不是虚函数的话：</p>
<figure class="highlight plain"><figcaption><span>p </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```delete p;</span><br></pre></td></tr></table></figure>

<p>这样的话我们效用的是Base基类的析构函数，只会释放掉基类部分的内存，派生类部分没有释放，造成<strong>内存泄漏</strong></p>
<p>而如果将<strong>析构函数定义成虚函数</strong></p>
<p><strong>虚析构函数的地址存在于虚函数表</strong>中，和普通虚函数别无二致，同时也会像普通的虚函数一样进行覆盖</p>
<p><strong>虽然父子的析构函数名字不一样，但是他们占同一个坑</strong>（即<strong>父子析构函数在虚函数表中的位置是一样的，否则就不存在多态</strong>了）</p>
<p>析构时，到特定的坑中调用该类型的析构函数，其<strong>析构函数中又嵌套了很多对父类的析构函数的调用</strong></p>
<p><strong>派生类析构函数中嵌套了基类析构函数的调用</strong></p>
</li>
<li><p>析构函数能抛出异常吗</p>
<p>对象在运行期间<strong>出现了异常</strong>，异常处理模型应该<strong>调用这些对象的析构函数来完成释放资源的任务</strong>，所以<strong>析构函数已经变成了异常处理的一部分</strong>——所以我们假定析构函数是不会抛出异常的，因为如果这个过程出现异常，，会无限递归下去</p>
<p>1）C++中析构函数的执行不应该抛出异常；</p>
<p>2）假如析构函数中抛出了异常，那么你的系统将变得非常危险，也许很长时间什么错误也不会发生；但也许你的系统有时就会莫名奇妙地崩溃而退出了，而且什么迹象也没有，崩得你满地找牙也很难发现问题究竟出现在什么地方；</p>
<p>3）当在某一个析构函数中会有一些可能（哪怕是一点点可能）发生异常时，那么就<strong>必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外</strong>（这招简直是绝杀！呵呵！）；</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~ClassName()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      do_something();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>()&#123;  <span class="comment">//这里可以什么都不做，只是保证catch块的程序抛出的异常不会被扔出析构函数之外。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数和析构函数调用虚函数吗</p>
<p><strong>不要再类的构造或者析构函数中调用虚函数</strong></p>
<p><strong>不要在类的构造或者析构过程中调用虚函数，因为这样的调用永远不会沿类继承树往下传递到子类中去。</strong></p>
</li>
<li><p>指针和引用区别</p>
<ul>
<li>引用是一个变量别名 指针是一个对象</li>
<li>引用必须初始化 指针不是必须</li>
<li>引用一定不为空 相对于指针<strong>不需要检查所指对象为空</strong>，这<strong>增加了效率</strong></li>
</ul>
</li>
<li><p>指针和数组</p>
<p>函数返回类型不可以是<strong>数组</strong>或者<strong>函数</strong>类型</p>
<p>但可以是<strong>指向数组或者函数的指针</strong></p>
<ul>
<li><strong>数组不允许拷贝</strong>，所以<strong>函数形参不能值传递</strong></li>
<li>使用数组时，通常会<strong>转化为指针</strong></li>
</ul>
<p>数组会被转换为指针，所以我们为函数传递一个数组时，实际上传递的是<strong>指向数组首元素的指针</strong></p>
<p>我们对应的形参可以是：</p>
<ul>
<li>const int* </li>
<li>const int[]</li>
<li>const int[10]</li>
</ul>
<p>注意！<strong>不存在引用的数组，但存在数组的引用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptrs[<span class="number">10</span>] = <span class="comment">/*...*/</span> <span class="comment">//包含十个整数指针的数组</span></span><br><span class="line"><span class="keyword">int</span>  (*ptr)[<span class="number">10</span>] = &amp;arr <span class="comment">//ptr指向一个包含十个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>&amp; Parray[<span class="number">10</span>] = <span class="comment">/*...*/</span> <span class="comment">//错误：不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr <span class="comment">//一个包含十个整数数组的引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>智能指针</strong>是怎么实现的，<strong>什么时候改变引用计数</strong></p>
<p>自己管理内存，可能<strong>不小心忘了delete</strong>，导致内存泄露</p>
<ul>
<li>这里引入一个知识点，我们把<figure class="highlight plain"><figcaption><span>ptr;```后，ptr指向的对象释放了，但是**ptr指针仍旧在并指向那块内存**，这里我们需要**附加操作**```ptr </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  除了上边考虑到的两个问题，上边程序还存在另一问题：如果内存申请不成功，new会抛出异常，而我们却什么都没有做！所以对这程序我们还得继续改进（也可用try...catch…()</span><br><span class="line"></span><br><span class="line">当我们**使用智能指针**：</span><br><span class="line"></span><br><span class="line">- 智能指针能够**帮助我们处理资源泄漏**的问题</span><br><span class="line">- 帮我们处理**空悬指针** 的问题</span><br><span class="line">- 处理比较隐晦的**由异常造成的资源泄漏**</span><br><span class="line"></span><br><span class="line">1. **class shared_ptr**实现**共享式拥有**（shared ownership）概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用（reference）被销毁”时候释放。为了在结构复杂的情境中执行上述工作，标准库提供了weak_ptr、bad_weak_ptr和enable_shared_from_this等辅助类。</span><br><span class="line">2. **class unique_ptr**实现**独占式拥有**（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露（resourece leak）——例如“以new创建对象后因为发生异常而忘记调用delete”——特别有用。</span><br><span class="line"></span><br><span class="line">**shared_ptr**</span><br><span class="line"></span><br><span class="line">在多个地点指向同一对象的需求场景</span><br><span class="line"></span><br><span class="line">多个shared_ptr可以共享（或说拥有）同一对象。对象的最末一个拥有者有责任销毁对象，并清理与该对象相关的所有资源</span><br><span class="line"></span><br><span class="line">shared_ptr的目标就是，在其所指向的对象不再被使用之后（而非之前），自动释放与对象相关的资源。</span><br><span class="line"></span><br><span class="line">**unique_ptr**</span><br><span class="line">这个智能指针实现了独占式拥有概念，意味着它可确保**一个对象和其相应资源同一时间只被一个指针拥有**。一旦拥有者**被销毁或变成空，或开始拥有另一个对象**，**先前**拥有的那个对象就会**被销毁**，其任何相应资源也会被释放</span><br><span class="line"></span><br><span class="line">**什么时候改变引用计数**</span><br><span class="line"></span><br><span class="line">- 当创建类的**新对象时，初始化指针**，并将引用计数设置**为1**</span><br><span class="line"></span><br><span class="line">- 当对象作为另一个对象的副本时，**拷贝构造函数**复制副本指针，并增加与指针相应的引用计数（加1）</span><br><span class="line"></span><br><span class="line">- 使用赋值操作符对一个对象进行赋值时，处理复杂一点：**先使左操作数的指针的引用计数减1（为何减1：因为指针已经指向别的地方），如果减1后引用计数为0，则释放指针所指对象内存。然后增加右操作数所指对象的引用计数（为何增加：因为此时做操作数指向对象即右操作数指向对象）。**</span><br><span class="line"></span><br><span class="line">- 析构函数：调用析构函数时，析构函数先使引用**计数减1，如果减至0则delete对象**。</span><br><span class="line"></span><br><span class="line">  ps：减1肯定要接上check是否为0</span><br><span class="line"></span><br><span class="line">**weak_ptr**</span><br><span class="line"></span><br><span class="line">我们要用一个share_ptr来初始化一个weak_ptr</span><br><span class="line"></span><br><span class="line">不影响动态对象的生命周期，不影响对象的**引用计数器**</span><br><span class="line"></span><br><span class="line">由于底层对象上的引用计数不会随weak_ptr引用而增加，因此**循环引用不会导致底层对象未被删除**</span><br><span class="line"></span><br><span class="line">- 关于循环引用</span><br><span class="line"></span><br><span class="line">  两个对象互相使用一个shared_ptr成员变量指向对方的会造成循环引用。导致引用计数失效。</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  class A &#123; shared_ptr&lt;B&gt; b; ... &#125;;</span><br><span class="line">  class B &#123; shared_ptr&lt;A&gt; a; ... &#125;;</span><br><span class="line">  shared_ptr&lt;A&gt; x(new A);  // +1</span><br><span class="line">  x-&gt;b = new B;            // +1</span><br><span class="line">  x-&gt;b-&gt;a = x;             // +1</span><br><span class="line">  // Ref count of &apos;x&apos; is 2.</span><br><span class="line">  // Ref count of &apos;x-&gt;b&apos; is 1.</span><br><span class="line">  // When &apos;x&apos; leaves the scope, there will be a memory leak:</span><br><span class="line">  // 2 is decremented to 1, and so both ref counts will be 1.</span><br><span class="line">  // (Memory is deallocated only when ref count drops to 0)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C++四种类型转换，static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<p>一个<strong>命名的强制类型转换</strong>有如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **static_cast**</span><br><span class="line"></span><br><span class="line">    任何具有明确定义的类型转换，只要**不包含底层const**，都可以使用static_cast</span><br><span class="line"></span><br><span class="line">    和**C风格强制转换**效果**基本一样**</span><br><span class="line"></span><br><span class="line">    C++的**任何隐式转换**都是使用**static_cast**来实现</span><br><span class="line"></span><br><span class="line">    - 用于**基本数据类型**的转换，和C风格的强制转换都**有安全隐患**</span><br><span class="line"></span><br><span class="line">    - 基类和派生类之间的**指针或者引用的转换**</span><br><span class="line"></span><br><span class="line">      派生类转基类 安全。但是基类转派生类时没有动态类型检查是不安全的。</span><br><span class="line"></span><br><span class="line">      所以最好只用派生类转基类</span><br><span class="line"></span><br><span class="line">    - static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)</span><br><span class="line"></span><br><span class="line">  - **const_cast**</span><br><span class="line"></span><br><span class="line">    const_cast**只能改变**运算对象的**底层const**，也就是**去掉const性质**</span><br><span class="line"></span><br><span class="line">    **上述是它唯一的功能**</span><br><span class="line"></span><br><span class="line">    - 常量指针被转化成非常量的指针，并且仍然指向原来的对象；</span><br><span class="line">    - 常量引用被转换成非常量的引用，并且仍然指向原来的对象；</span><br><span class="line">    - const_cast一般用于修改指针。如const char *p形式。</span><br><span class="line"></span><br><span class="line">    如果原来对象是**常量对象**，那么使用const_cast执行**写操作**会产生**未定义**的后果</span><br><span class="line"></span><br><span class="line">    如果指向对象不是**常量对象**，那么是**合法行为**</span><br><span class="line"></span><br><span class="line">  - **dynamic_cast**</span><br><span class="line"></span><br><span class="line">    dynamic_cast运算符可以在**执行期决定真正的类型**。如果downcast是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针，也就是此时**可以转型为派生类指针**。如果downcast不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）。</span><br><span class="line"></span><br><span class="line">    - 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</span><br><span class="line">    - 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</span><br><span class="line"></span><br><span class="line">    也就是**根据其执行期间指向的对象**，**如果是基类指针确实指向了派生类**，那么基类指针可以转换为派生类，否则会返回null。</span><br><span class="line"></span><br><span class="line">    - 对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针；</span><br><span class="line">    - 对引用进行dynamic_cast，失败抛出一个异常，成功返回正常cast后的对象引用</span><br><span class="line"></span><br><span class="line">  - **reinterpret_cast**</span><br><span class="line"></span><br><span class="line">    reinterpret_cast是强制类型转换符用来处理无关类型转换的，**通常为操作数的位模式提供较低层次的重新解释**！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！ </span><br><span class="line"></span><br><span class="line">    - 从指针类型到一个足够大的整数类型</span><br><span class="line">    - 从整数类型或者枚举类型到指针类型</span><br><span class="line">    - 从一个指向函数的指针到另一个不同类型的指向函数的指针</span><br><span class="line">    - 从一个指向对象的指针到另一个不同类型的指向对象的指针</span><br><span class="line">    - 从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针</span><br><span class="line">    - 从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针</span><br><span class="line"></span><br><span class="line">    **尽量避免使用**</span><br><span class="line"></span><br><span class="line">- 内存对其的原则</span><br><span class="line"></span><br><span class="line">  - 为什么要内存对齐</span><br><span class="line">    - **平台原因**：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。————- 比如，有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。</span><br><span class="line">    - **性能原因**：内存对齐可以提高存取效率。————- 比如，有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。</span><br><span class="line"></span><br><span class="line">  每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。你可以通过预编译命令`#pragma pack(n)`，n=1,2,4,8,16 来改变这一系数，其中 n 就是你要指定的“对齐系数”。</span><br><span class="line"></span><br><span class="line">  **1）概念：**</span><br><span class="line"></span><br><span class="line">  **有效对齐值**：是 `#pragma pack`指定值 和 结构体中最长数据类型长度 中**较小**的那个。有效对齐值也叫**对齐单位**。</span><br><span class="line"></span><br><span class="line">  注意：VS、VC 默认是#pragma pack(8)，而 gcc 默认是#pragma pack(4)，并且gcc只支持1，2，4对齐。</span><br><span class="line"></span><br><span class="line">  **2）规则：**</span><br><span class="line"></span><br><span class="line">  1. 结构体变量的**首地址**是有效对齐值（对齐单位）的**整数倍**。</span><br><span class="line"></span><br><span class="line">  2. 结构体第一个成员的**偏移量（offset）**为0，——**结构体地址就是第一个成员地址**</span><br><span class="line"></span><br><span class="line">     以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。</span><br><span class="line"></span><br><span class="line">  3. **结构体的总大小**为 有效对齐值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。</span><br><span class="line"></span><br><span class="line">  4. 结构体内类型相同的连续元素将在**连续的空间**内，和数组一样。</span><br><span class="line"></span><br><span class="line">  5. sizeof(union)，以**结构里面size最大元素**为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。</span><br><span class="line"></span><br><span class="line">- **内联函数的优点 内联函数和宏定义的区别**</span><br><span class="line"></span><br><span class="line">  内联函数优点：</span><br><span class="line"></span><br><span class="line">  - 编译的时候直接在该节点展开，不需要寻址调用，**效率高**</span><br><span class="line">  - 内联函数是一个函数，编译器会像对待函数一样**检查参数**，**更安全**，——***宏有安全隐患***</span><br><span class="line">  - inline可以作为类的成员函数操作私有成员 ，——***宏不可以***</span><br><span class="line"></span><br><span class="line">  内联函数缺点：</span><br><span class="line"></span><br><span class="line">  内联函数以复制为代价，活动产函数开销</span><br><span class="line"></span><br><span class="line">  - 如果函数的**代码较长**，使用内联将**消耗过多内存**</span><br><span class="line"></span><br><span class="line">  - 内联函数不能有循环，一个是代码量太大 ，另一个是编译器一般会把他变为非内联函数，编译器的优化？</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  综上,C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。所以在C++ 程序中，应该用内联函数取代所有宏代码.</span><br><span class="line"></span><br><span class="line">  BUT , “断言assert”恐怕是唯一的例外。assert是仅在Debug版本起作用的宏，它用于检查“不应该”发生 的情况。为了不在程序的Debug版本和Release版本引起差别，**assert不应该产生任何副作用**。如果assert是函数，由于函数调用会引起内 存、代码的变动，那么将导致Debug版本与Release版本存在差异。所以assert不是函数，而是宏。</span><br><span class="line"></span><br><span class="line">- **C++**内存管理</span><br><span class="line"></span><br><span class="line">  简介，分为五个区，**栈**，**堆**，**自由存储区**，**全局/静态存储区**，**常量存储区**</span><br><span class="line"></span><br><span class="line">  **栈**</span><br><span class="line"></span><br><span class="line">  在**执行函数**时，函数内**局部变量的存储单元**都可以在**栈上创建**，函数执行**结束时**这些存储单元自动**被释放**。**栈内存分配运算**内置于处理器的**指令集**中，**效率很高**，但是分配的**内存容量有限**</span><br><span class="line"></span><br><span class="line">  **堆**</span><br><span class="line"></span><br><span class="line">  就是那些由 `new`分配的内存块，他们的**释放编译器不去管**，由我们的**应用程序去控制**，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</span><br><span class="line"></span><br><span class="line">  **自由存储区**</span><br><span class="line"></span><br><span class="line">  就是那些由`malloc`等分配的内存块，**和堆十分相似**的，不过它是用`free`来结束自己的生命的</span><br><span class="line"></span><br><span class="line">  **全局/静态存储区**</span><br><span class="line"></span><br><span class="line">  **全局变量和静态变量**被**分配到同一块内存中**，在以前的C语言中，全局变量又分为**初始化的和未初始化**的，在C++里面没有这个区分了，他们**共同占用同一块内存**区。</span><br><span class="line"></span><br><span class="line">  **常量存储区**</span><br><span class="line"></span><br><span class="line">  里面**存放的是常量**，**不允许修改**</span><br><span class="line"></span><br><span class="line">  - 明确区分 堆与栈</span><br><span class="line"></span><br><span class="line">    ```cpp</span><br><span class="line">    void f() &#123; int* p=new int[5]; &#125;</span><br></pre></td></tr></table></figure>

<p>  p位于栈中，指向了一块堆中的内存</p>
<p>  <strong>堆和栈的区别</strong></p>
<p>  (1). 管理方式不同</p>
<p>  ​    栈：编译器自动管理</p>
<p>  ​    堆：程序员管理，容易产生<strong>memory leak</strong></p>
<p>  (2). 空间大小不同</p>
<p>  ​    堆：32位系统，堆内存可以达到<strong>4G</strong>的空间</p>
<p>  ​    栈：在VC6下，默认的栈空间是<strong>1M</strong>大小</p>
<p>  ​    可以认为堆几乎无限制，栈有限制</p>
<p>  (3). 能否产生碎片不同</p>
<p>  ​    堆：频繁的<code>new</code>和<code>delete</code>势必会造成<strong>空间的不连续</strong>，从而造成<strong>大量碎片</strong>，程    序<strong>效率降低</strong></p>
<p>  ​    栈：先进后出，是连续的，<strong>不存在内存碎片</strong>的问题</p>
<p>  (4). 生长方向不同</p>
<p>  ​    堆：向上生长，沿着<strong>内存地址增加</strong>的方向</p>
<p>  ​    栈：向下生长，沿着<strong>内存地址减小</strong>的方向</p>
<p>  (5). 分配方式不同</p>
<p>  ​    动态分配：函数<strong>运行时分配</strong></p>
<p>  ​    静态分配：函数<strong>编译时分配</strong></p>
<p>  ​    堆：<strong>只有动态</strong>分配，<strong>没有静态</strong></p>
<p>  ​    栈：<strong>有静态</strong>分配，比如局部变量的分配，也<strong>有动态</strong>分配，有<code>alloca</code>函数进行    分配。但是栈的动态分配与堆不同，栈的动态分配是有编译器进行释放，无须    我们手工实现。</p>
<p>  (6). 分配效率不同</p>
<p>  ​    栈：<strong>机器系统</strong>提供的数据结构，计算机对栈有<strong>底层支持</strong>，分配<strong>专门的寄存器</strong>存    放栈的地址，<strong>入栈出栈都有专门的指令</strong>执行，所以<strong>栈的效率高</strong></p>
<p>  ​    堆：<strong>C++函数库</strong>提供的。抽象层次高，当然效率就低了</p>
<p>  ​    </p>
<p>  <strong><em>栈的效率高，且不会有内存碎片的问题，但是堆更自由，且使用的内存更大</em></strong></p>
<p>  <strong>那么如何避免产生野指针呢</strong>？这里列出了5条规则，平常写程序时多注意一下，养成良好的习惯。</p>
<blockquote>
<p>规则1：用<code>malloc</code>或<code>new</code>申请内存之后，应该立即检查指针值是否为<code>NULL</code>。防止使用指针值为<code>NULL</code>的内存。<br>规则2：不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。<br>规则3：避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。<br>规则4：动态内存的申请与释放必须配对，防止内存泄漏。<br>规则5：用<code>free</code>或<code>delete</code>释放了内存之后，立即将指针设置为<code>NULL</code>，防止产生“野指针”。</p>
</blockquote>
<p>  <strong>学会使用智能指针</strong></p>
<ul>
<li>越是怕指针，就越要使用指针。不会正确使用指针，肯定算不上是合格的程序员。</li>
<li>必须养成使用“调试器逐步跟踪程序”的习惯，只有这样才能发现问题的本质</li>
</ul>
</li>
<li><p>STL里的内存池实现</p>
<p><strong>为什么要使用内存池</strong></p>
<p>如果应用程序频繁地在堆上分配和释放内存，会导致性能的损失。并且会使<strong>系统中出现大量的内存碎片</strong>，<strong>降低内存的利用率</strong>。默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做<strong>更多的额外工作</strong>。而对于某一个<strong>具体的应用程序</strong>来说，适合自身特定的内存分配释放模式的自定义内存池可以获得更好的性能。</p>
<p>内存池则是在真正使用内存之前，<strong>预先申请分配一定数量、大小相等（一般情况下）的内存块留作备用</strong>。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块<strong>不够再继续申请新的内存</strong>。这样做的一个显著优点是，使得<strong>内存分配效率得到提升</strong>。</p>
<p>单线程内存池整个生命周期只被一个线程使用，因而不需要考虑互斥访问的问题；多线程内存池有可能被多个线程共享，因此需要在每次分配和释放内存时加锁。相对而言，单线程内存池性能更高，而多线程内存池适用范围更加广泛</p>
<p>从内存池可分配内存单元大小来分，可以分为固定内存池和可变内存池。所谓固定内存池是指应用程序每次从内存池中分配出来的内存单元大小事先已经确定，是固定不变的；而可变内存池则每次分配的内存单元大小可以按需变化，应用范围更广，而性能比固定内存池要低。</p>
<p><strong>经典的内存池实现过程</strong></p>
<p>（1）先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象；<br>（2）每个对象<strong>连同一个指向下一个对象的指针</strong>一起构成一个<strong>内存节点</strong>（Memory Node）。各个空闲的<strong>内存节点通过指针形成一个链表</strong>，链表的每一个<strong>内存节点都是</strong>一块可<strong>供分配的内存空间</strong>；<br>（3）某个<strong>内存节点一旦分配出去</strong>，从空闲内存节点<strong>链表中去除</strong>；<br>（4）一旦<strong>释放</strong>了某个内存节点的空间，又将该节点<strong>重新加入</strong>空闲内存节点<strong>链表</strong>；<br>（5）如果一个内存块的<strong>所有内存节点分配完毕</strong>，若<strong>程序继续申请</strong>新的对象空间，则<strong>会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。</strong></p>
</li>
<li><p><strong>STL里的set和map是基于什么实现的。红黑树的特点</strong></p>
</li>
<li><p><strong>STL里的其他数据结构和算法实现</strong></p>
</li>
<li><p><strong>必须在构造函数初始化式里进行初始化的数据成员有哪些</strong></p>
<ul>
<li><p>常量成员——<strong>只能初始化不能赋值</strong></p>
</li>
<li><p>引用类型——<strong>必须在定义时初始化 且 不能重新赋值</strong></p>
</li>
<li><p>数据成员是一个<strong>没有默认构造函数的对象</strong></p>
</li>
<li><p><strong>子类初始化父类的私有成员</strong>，需要在且只能在参数初始化列表中<strong>显式调用父类的构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()&#123;&#125;;</span><br><span class="line">    Test (<span class="keyword">int</span> x)&#123; int_x = x;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt; int_x &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> int_x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mytest</span>:</span><span class="keyword">public</span> Test&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mytest() ：Test(<span class="number">110</span>)&#123;</span><br><span class="line">      <span class="comment">//Test(110);            //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line"> Test *p = <span class="keyword">new</span> Mytest();</span><br><span class="line"> p-&gt;show();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>模板特化</strong></p>
</li>
<li><p><strong>定位内存泄漏</strong><br>(1)在windows平台下通过CRT中的库函数进行检测； </p>
<p>(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置 </p>
<p>(3)Linux下通过工具valgrind检测</p>
</li>
<li><p><strong>手写strcpy，memcpy，strcat，strcmp等函数</strong></p>
<ul>
<li><p>assert：断言，</p>
<p>先计算表达式expression，如果其值为假（0），那么它先向<strong>stderr打印一条出错信息</strong>，然后<strong>通过调用abort来终止程序运行</strong></p>
</li>
<li><p><strong>strcpy</strong>：拷贝字符串，以’\0’为标志结束，并返回dst地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dst,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">	assert(dst!=<span class="literal">nullptr</span> &amp;&amp; src!=<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">char</span>* cp = dst;</span><br><span class="line">	<span class="keyword">while</span>(*cp++ = *src++)</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>strcat</strong>：把src所指字符串添加到dst结尾处（覆盖dst结尾处的’\0’)并添加’\0’</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* dst,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">	assert(dst!=<span class="literal">nullptr</span> &amp;&amp; src!=<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">char</span>* cp = dst;</span><br><span class="line">	<span class="keyword">while</span>(*cp)</span><br><span class="line">		cp++;</span><br><span class="line">	<span class="keyword">while</span>(*cp++ = *src++)</span><br><span class="line">		;</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>strcmp</strong>：比较两个字符串</p>
<p>比较规则：从左到右进行比较（ASCII值），直到出现不同的字符或者遇到’\0’为止。如果全部字符相同，则认为两个字符串相等，返回0。</p>
<p>如果出现不同字符，则对<strong>第一次</strong>出现的不同字符进行比较。比较方法是以S1的第一个不同字符减去S2的第一个不同字符，以所得差值作为返回值（大于0，则返回1，小于0则返回-1）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">char</span>* dst)</span></span>&#123;</span><br><span class="line">	assert(src!=<span class="literal">nullptr</span> &amp;&amp; dst!=<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!(ret=*(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)src-*(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)dst) &amp;&amp; *dst)&#123;</span><br><span class="line">		++dst;</span><br><span class="line">		++src;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>memcpy</strong>：</p>
</li>
<li><p><strong>strlen</strong>：计算字符串s的长度，不包括’\0’</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;</span><br><span class="line">	assert(str!=<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* cp = str;</span><br><span class="line">	<span class="keyword">while</span>(*cp++);</span><br><span class="line">	<span class="keyword">return</span> (cp-str<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p># </p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="YDE WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="YDE Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Note/" rel="tag"># Note</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/29/Network_Start_2019Fall/" rel="next" title="Network_Start_2019Fall">
                <i class="fa fa-chevron-left"></i> Network_Start_2019Fall
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/29/剑指offer_201904/" rel="prev" title="剑指offer_201904">
                剑指offer_201904 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">YDE</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TaoTaoUncle" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number">1.</span> <span class="nav-text">C++</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YDE</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
