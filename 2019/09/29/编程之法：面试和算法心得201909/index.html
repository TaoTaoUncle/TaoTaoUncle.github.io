<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Note,Interview,">










<meta name="description" content="海量数据问题是指基于海量数据的存储 处理 操作 数据量太大的暗示：无法短时间内迅速解决，无法一次性装入内存 ！！！针对时间问题——巧妙的算法搭配合适的数据结构 如 布隆过滤器 哈希 位图 堆 数据库 倒排索引 Trie树 ！！！针对空间问题——采取分而治之(哈希映射)的方法 也就是规模大的数据转化为规模小的，从而各个击破  哈希映射的一个重要特性：相同的元素肯定映射到同一个文件中 此外，针对常说的">
<meta name="keywords" content="Note,Interview">
<meta property="og:type" content="article">
<meta property="og:title" content="编程之法：面试和算法心得201909">
<meta property="og:url" content="http://yoursite.com/2019/09/29/编程之法：面试和算法心得201909/index.html">
<meta property="og:site_name" content="YDE&#39;s Daily">
<meta property="og:description" content="海量数据问题是指基于海量数据的存储 处理 操作 数据量太大的暗示：无法短时间内迅速解决，无法一次性装入内存 ！！！针对时间问题——巧妙的算法搭配合适的数据结构 如 布隆过滤器 哈希 位图 堆 数据库 倒排索引 Trie树 ！！！针对空间问题——采取分而治之(哈希映射)的方法 也就是规模大的数据转化为规模小的，从而各个击破  哈希映射的一个重要特性：相同的元素肯定映射到同一个文件中 此外，针对常说的">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://dl.iteye.com/upload/attachment/437426/baf42378-e625-35d2-9a89-471524a355d8.jpg">
<meta property="og:image" content="http://dl.iteye.com/upload/attachment/437559/689719df-54b7-318c-bc90-e289f84344b9.jpg">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-08-26%20at%203.55.40%20PM.png">
<meta property="og:image" content="http://dl.iteye.com/upload/attachment/437586/b72b8dc2-9139-3078-ad24-b689f64fd71a.jpg">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/beac4fab89c7f2b8472b8a83005f935d425b31de">
<meta property="og:image" content="https://img-my.csdn.net/uploads/201204/04/1333509466_5499.jpg">
<meta property="og:image" content="http://img.blog.csdn.net/20140616114324296">
<meta property="og:updated_time" content="2019-09-30T06:56:44.754Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="编程之法：面试和算法心得201909">
<meta name="twitter:description" content="海量数据问题是指基于海量数据的存储 处理 操作 数据量太大的暗示：无法短时间内迅速解决，无法一次性装入内存 ！！！针对时间问题——巧妙的算法搭配合适的数据结构 如 布隆过滤器 哈希 位图 堆 数据库 倒排索引 Trie树 ！！！针对空间问题——采取分而治之(哈希映射)的方法 也就是规模大的数据转化为规模小的，从而各个击破  哈希映射的一个重要特性：相同的元素肯定映射到同一个文件中 此外，针对常说的">
<meta name="twitter:image" content="http://dl.iteye.com/upload/attachment/437426/baf42378-e625-35d2-9a89-471524a355d8.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/29/编程之法：面试和算法心得201909/">





  <title>编程之法：面试和算法心得201909 | YDE's Daily</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YDE's Daily</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Welcome here!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/29/编程之法：面试和算法心得201909/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YDE">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YDE's Daily">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">编程之法：面试和算法心得201909</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-29T19:29:20+08:00">
                2019-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/201909/" itemprop="url" rel="index">
                    <span itemprop="name">201909</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="海量数据问题"><a href="#海量数据问题" class="headerlink" title="海量数据问题"></a>海量数据问题</h2><p>是指<font color="blue">基于海量数据的存储 处理 操作</font></p>
<p>数据量太大的暗示：无法<font color="blue">短时间</font>内迅速解决，无法<font color="blue">一次性装入内存</font></p>
<p><strong>！！！针对时间问题</strong>——<strong>巧妙的算法搭配合适的数据结构</strong></p>
<p>如 布隆过滤器 哈希 位图 堆 数据库 倒排索引 Trie树</p>
<p><strong>！！！针对空间问题——采取分而治之(哈希映射)的方法</strong></p>
<p>也就是规模大的数据转化为规模小的，从而各个击破</p>
<p> <font color="blue">哈希映射的一个重要特性：相同的元素肯定映射到同一个文件中</font></p>
<p>此外，针对常说的单机及集群问题，通俗来讲，单机就是指处理装载数据的机器有限（只要考虑CPU、内存、和硬盘之间的数据交互），而集群的意思是指机器有多台，适合分布式处理或并行计算，更多考虑节点与节点之间的数据交互。</p>
<p>处理海量数据问题，有以下<strong><font color="blue">十种典型方法</font></strong></p>
<ol>
<li>哈希分治</li>
<li>simhash算法</li>
<li>外排序</li>
<li>MapReduce</li>
<li>多层划分</li>
<li>位图</li>
<li>布隆过滤器</li>
<li>Trie树</li>
<li>数据库</li>
<li>倒排索引</li>
</ol>
<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>STL容器氛围序列式容器(vector/list/queue/deque/stack/heap)，和关联式容器。</p>
<p>关联式容器分为set(集合)和map(映射表)两大类，以及衍生的mulitset和multimap。<font color="blue">这些容器均以RB-tree完成</font></p>
<p>此外还有第三类关联式容器，如<font color="blue">hashtable</font>(散列表)，以及以hashtable为底层机制完成的hash_set(散列结合)/hash_map(散列映射表)/hash_multiset(散列多键集合)/hash_multimap(散列多键映射表)，</p>
<p>也就是说，set/map/multiset/multimap都内含一个RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtable。</p>
<p>所谓关联式容器，类似关联式数据库，每笔数据或每个元素都有一个键值(key)和一个实值(value)，即所谓的Key-Value(键-值对)。当元素被插入到关联式容器中时，容器内部结构(RB-tree/hashtable)便依照其键值大小，以某种特定规则将这个元素放置于适当位置。</p>
<p>包括在非关联式数据库中，比如，在MongoDB内，文档(document)是最基本的数据组织形式，每个文档也是以Key-Value（键-值对）的方式组织起来。一个文档可以有多个Key-Value组合，每个Value可以是不同的类型，比如String、Integer、List等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;name&quot; : &quot;July&quot;,  </span><br><span class="line">&quot;sex&quot; : &quot;male&quot;,  </span><br><span class="line">&quot;age&quot; : 23 &#125;</span><br></pre></td></tr></table></figure>

<p><strong>set/map/multiset/multimap</strong></p>
<p>set，同map一样，所有<strong>元素都会根据元素的键值自动被排序</strong>，因为set/map两者的所有各种操作，<strong>都只是转而调用RB-tree的操作行为</strong>，不过，<font color="blue">值得注意的是，两者都不允许两个元素有相同的键值</font>。</p>
<p>不同的是：set的元素不像map那样可以同时拥有实值(value)和键值(key)，<font color="blue">set元素的键值就是实值，实值就是键值，而map的所有元素都是pair，同时拥有实值(value)和键值(key)，pair的第一个元素被视为键值，第二个元素被视为实值。</font></p>
<p>至于<strong>multiset/multimap</strong>，他们的<strong>特性及用法和set/map完全相同，唯一的差别就在于它们允许键值重复</strong>，即所有的插入操作基于RB-tree的insert_equal()而非insert_unique()。</p>
<p><strong>hash_set/hash_map/hash_multiset/hash_multimap</strong></p>
<p>hash_set/hash_map，两者的一切操作都是基于hashtable之上。不同的是，hash_set同set一样，同时拥有实值和键值，且实质就是键值，键值就是实值，而hash_map同map一样，每一个元素同时拥有一个实值(value)和一个键值(key)，所以其使用方式，和上面的map<font color="blue">基本相同。但由于hash_set/hash_map都是基于hashtable之上，所以不具备自动排序功能。为什么？因为hashtable没有自动排序功能。</font></p>
<p>至于hash_multiset/hash_multimap的特性与上面的multiset/multimap完全相同，<strong>唯一的差别就是</strong>它们hash_multiset/hash_multimap的<strong>底层实现机制是hashtable</strong>（而multiset/multimap，上面说了，底层实现机制是RB-tree），<strong>所以它们的元素都不会被自动排序，不过也都允许键值重复</strong>。</p>
<p>所以，综上，<font color="blue">说白了，什么样的结构决定其什么样的性质</font>，因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash<em>set/hash_map/hash_multiset/hash_multimap都是基于hashtable之上，所以不含有自动排序功能，至于加个前缀multi</em>无非就是允许键值重复而已。</p>
<h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>先映射，后统计，最后排序</p>
<p>hash映射：保证同一个元素在hash后，不会映射到不同的文件中去。换言之，同一个元素只会存在于同一个文件中</p>
<p>一般来讲：</p>
<ul>
<li><p>映射</p>
<p>如果一次放不下，那就用hash映射到多个文件 再进行操作</p>
<p>如果放的下，那就跳过这一步</p>
</li>
<li><p>统计</p>
<p>如果是字符串/单词，考虑Trie树</p>
<p>如果是其他数据，考虑hash_map或者hash_set</p>
<p>去重/统计频率，看具体情况选择合适的数据结构</p>
</li>
<li><p>排序</p>
<p>最后如果需要<strong>top排序</strong>，一般是<strong>堆排序</strong></p>
<p>如果是<strong>全体排序</strong>，一般是<strong>归并排序（外排+内排）</strong></p>
</li>
</ul>
<h3 id="simhash算法"><a href="#simhash算法" class="headerlink" title="simhash算法"></a>simhash算法</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><font color="gray">如果某一天，面试官问你如何设计一个比较两篇文章相似度的算法？可能你会回答几个比较传统点的思路：</font></p>
<ul>
<li><font color="gray">一种方案是先将两篇文章分别进行分词，得到一系列特征向量，然后计算特征向量之间的距离（可以计算它们之间的欧氏距离、海明距离或者夹角余弦等等），从而通过距离的大小来判断两篇文章的相似度。</font></li>
<li><font color="gray">另外一种方案是传统hash，我们考虑为每一个web文档通过hash的方式生成一个指纹（finger print）。</font></li>
</ul>
<p><font color="gray">下面，我们来分析下这两种方法。</font></p>
<ul>
<li><font color="gray">采取第一种方法，若是只比较两篇文章的相似性还好，但如果是海量数据呢，有着数以百万甚至亿万的网页，要求你计算这些网页的相似度。你还会去计算任意两个网页之间的距离或夹角余弦么？想必你不会了。</font></li>
<li><font color="gray">而第二种方案中所说的传统加密方式md5，其设计的目的是为了让整个分布尽可能地均匀，但如果输入内容一旦出现哪怕轻微的变化，hash值就会发生很大的变化</font></li>
</ul>
<p>传统hash，我们考虑为每一个web文档通过<font color="blue">hash的方式生成一个指纹（finger print）</font>。</p>
<p>传统加密方式md5，其设计的目的是为了让整个分布尽可能地均匀，但如果<font color="blue">输入内容一旦出现哪怕轻微的变化，hash值就会发生很大的变化</font>。</p>
<p>使用传统hash可能会得到如下的结果：</p>
<ul>
<li>irb(main):006:0&gt; p1 = ‘the cat sat on the mat’<ul>
<li>irb(main):007:0&gt; p1.hash =&gt; 415542861</li>
</ul>
</li>
<li>irb(main):005:0&gt; p2 = ‘the cat sat on a mat’<ul>
<li>irb(main):007:0&gt; p2.hash =&gt; 668720516</li>
</ul>
</li>
<li>irb(main):007:0&gt; p3 = ‘we all scream for ice cream’<ul>
<li>irb(main):007:0&gt; p3.hash =&gt; 767429688 “</li>
</ul>
</li>
</ul>
<p>可<font color="blue">理想当中的hash函数</font>，需要对几乎相同的输入内容，产生相同或者相近的hash值，换言之，<font color="blue">hash值的相似程度要能直接反映输入内容的相似程度</font>，故md5等传统hash方法也无法满足我们的需求。</p>
<h4 id="引入simhash"><a href="#引入simhash" class="headerlink" title="引入simhash"></a>引入simhash</h4><p>ps：海明距离</p>
<p>在<a href="https://baike.baidu.com/item/信息编码/9637385" target="_blank" rel="noopener">信息编码</a>中，两个合法代码对应位上编码不同的位数称为<a href="https://baike.baidu.com/item/码距/5907009" target="_blank" rel="noopener">码距</a>，又称海明距离。举例如下：10101和00110从第一位开始依次有第一位、第四、第五位不同，则海明距离为3</p>
<p>simhash算法，专门用来解决亿万级别的网页的去重任务。</p>
<p>其<font color="blue">主要思想是降维</font>，将高维的特征向量<font color="blue">映射成低维的特征向量</font>，<font color="blue">通过两个向量的Hamming Distance来确定文章是否重复或者高度近似</font>。</p>
<p>通过<strong>比较多个文档的simHash值的海明距离</strong>，可以获取它们的相似度。</p>
<p>分为五个步骤 <strong>分词</strong> <strong>哈希</strong> <strong>加权</strong> <strong>合并</strong> <strong>降维</strong></p>
<p><strong>分词</strong></p>
<p>一段语句，进行分词，<strong>得到有效的特征向量</strong>，然后为每一个特征向量设置1-5等5个级别的<strong>权重</strong></p>
<p><strong>hash</strong></p>
<p>通过hash函数计算各个特征向量的hash值，<font color="blue">hash值为二进制数01组成的n-bit签名</font>。比如“CSDN”的hash值Hash(CSDN)为100101，“博客”的hash值Hash(博客)为“101011”。就这样，<font color="blue">字符串就变成了一系列数字</font>。</p>
<p><strong>加权</strong></p>
<p>在<strong>hash值的基础</strong>上，给所有特征向量<strong>进行加权</strong>，$即W = Hash*weight$，且遇到<font color="blue">1则hash值和权值正相乘</font>，<font color="blue">遇到0则hash值和权值负相乘</font>。例如给“CSDN”的hash值“100101”加权得到：<code>W(CSDN) = 100101*4 = 4 -4 -4 4 -4 4​</code>，给“博客”的hash值“101011”加权得到：​<code>W(博客)=101011*5 = 5 -5 5 -5 5 5​</code>，其余特征向量类似此般操作。</p>
<p><strong>合并</strong></p>
<p>将上述<strong>各个特征向量的加权结果累加，变成只有一个序列串</strong>。拿前两个特征向量举例，例如“CSDN”的“4 -4 -4 4 -4 4”和“博客”的“5 -5 5 -5 5 5”进行累加，得到“4+5 -4+-5 -4+5 4+-5 -4+5 4+5”，得到“9 -9 1 -1 1”。</p>
<p>一个文本有多个特征向量</p>
<p><strong>降维</strong></p>
<p>对于n-bit签名的<font color="blue">累加结果，如果大于0则置1，否则置0</font>，从而得到该语句的simhash值，<font color="blue">最后</font>我们便可以<font color="blue">根据不同语句simhash的海明距离来判断它们的相似度</font>。例如把上面计算出来的<strong>“9 -9 1 -1 1 9”降维</strong>（某位大于0记为1，小于0记为0），得到的01串为：<strong>“1 0 1 0 1 1”</strong>，<strong>从而形成它们的simhash签名</strong>。</p>
<p><strong>每篇文档得到SimHash签名值后，接着计算两个签名的海明距离即可</strong></p>
<ul>
<li>海明距离的求法：异或时，只有在两个比较的位不同时其结果是1 ，否则结果为0，两个二进制“异或”后得到1的个数即为海明距离的大小。</li>
</ul>
<p><img src="http://dl.iteye.com/upload/attachment/437426/baf42378-e625-35d2-9a89-471524a355d8.jpg" alt="img"></p>
<p>现在问题转换为：对于<strong>64位的SimHash值</strong>，我们只要找到<strong>海明距离在3以内的所有签名</strong>（3以内可以认为是相似度比较高），即可找出所有相似的文本/短语。</p>
<p><font color="blue">扩展到海量数据</font>，在海量的样本库中查询海明距离3以内的记录</p>
<ul>
<li>一种方案是查找待查询文本的64位simhash code的所有3位以内变化的组合<ul>
<li>大约需要四万多次的查询。</li>
</ul>
</li>
<li>另一种方案是预生成库中所有样本simhash code的3位变化以内的组合<ul>
<li>大约需要占据4万多倍的原始空间。</li>
</ul>
</li>
</ul>
<p>这两种方案，要么时间复杂度高，要么空间复杂度复杂，能否有一种方案可以达到时空复杂度的绝佳平衡呢？答案是肯定的：</p>
<ul>
<li><p>我们可以把 64 位的二进制<font color="blue">simhash签名均分成4块，每块16位</font>。根据<strong>鸽巢原理（也称抽屉原理），如果两个签名的海明距离在 3 以内，它们必有一块完全相同</strong>。如下图所示：</p>
<p><font color="gray">在google的论文给出的数据中，64位的签名，在海明距离为3的情况下，可认为两篇文档是相似的或者是重复的，当然这个值只是参考值，针对自己的应用可能又不同的测试取值</font></p>
</li>
</ul>
<p><img src="http://dl.iteye.com/upload/attachment/437559/689719df-54b7-318c-bc90-e289f84344b9.jpg" alt="img"></p>
<p>到这里<strong><font color="blue">相似度问题基本解决</font></strong>，但是按这个思路，在海量数据几百亿的数量下，<font color="blue">效率问题还是没有解决的，因为数据是不断添加进来的，不可能每来一条数据，都要和全库的数据做一次比较，按照这种思路，处理速度会越来越慢，线性增长。</font></p>
<ul>
<li><p>然后把分成的4 块中的每一个块分别作为前16位来进行查找，<strong><font color="blue">建倒排索引</font></strong>。</p>
<p>ps：<strong>倒排索引</strong>（英语：Inverted index），也常被称为<strong>反向索引</strong>、<strong>置入档案</strong>或<strong>反向档案</strong>，是一种<a href="https://zh.wikipedia.org/wiki/索引" target="_blank" rel="noopener">索引</a>方法，被用来<a href="https://zh.wikipedia.org/w/index.php?title=存储&action=edit&redlink=1" target="_blank" rel="noopener">存储</a>在<a href="https://zh.wikipedia.org/w/index.php?title=全文搜索&action=edit&redlink=1" target="_blank" rel="noopener">全文搜索</a>下某个单词在一个文档或者一组文档中的<a href="https://zh.wikipedia.org/w/index.php?title=存储位置&action=edit&redlink=1" target="_blank" rel="noopener">存储位置</a>的<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射</a>。它是<a href="https://zh.wikipedia.org/w/index.php?title=文档检索系统&action=edit&redlink=1" target="_blank" rel="noopener">文档检索系统</a>中最常用的<a href="https://zh.wikipedia.org/wiki/数据结构" target="_blank" rel="noopener">数据结构</a>。</p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-08-26%20at%203.55.40%20PM.png" alt="Screen Shot 2019-08-26 at 3.55.40 PM"></p>
</li>
</ul>
<p>如下图所示：</p>
<p><img src="http://dl.iteye.com/upload/attachment/437586/b72b8dc2-9139-3078-ad24-b689f64fd71a.jpg" alt="img"></p>
<p>如此，如果样本库中存有2^34（差不多171亿）的simhash签名，则每个table返回2^(34-16)=262144个候选结果，大大减少了海明距离的计算成本。</p>
<ul>
<li>假设数据是均匀分布，16位的数据，产生的像限为2^16个，则平均每个像限分布的文档数则为2^34/2^16 = 2^(34-16)) ，四个块返回的总结果数为 4* 262144 （大概 100 万）。<ul>
<li>这样，原本需要比较10亿次，经过索引后，大概只需要处理100万次。</li>
</ul>
</li>
</ul>
<p>针对每一个签名，要查找的次数：相当于2^34 变为 2^(34-16)*(64/16)</p>
<p>对于ABCD都是第一个字段的疑问：对于1/4 整段（较长）的文本来说，调换下顺序，对相似度影响不高。。</p>
<p><strong><em>总结一下：</em></strong></p>
<ul>
<li><p><font color="blue">相似度</font>的计算由<font color="blue">simhash算法得到hash签名+海明距离计算（一般64位hash签名的海明距离&lt;=3认为相似）</font>解决</p>
</li>
<li><p>现在需要进行<font color="blue">对一个64位签名，查询样本中海明距离在3以内的相似签名数</font></p>
<p><font color="gray">一种方案是查找待查询文本的64位simhash code的所有3位以内变化的组合</font></p>
<ul>
<li>大约需要四万多次的查询。每次都要比较2^34次比较，但是不需要额外空间</li>
</ul>
<p><font color="gray">另一种方案是预生成库中所有样本simhash code的3位变化以内的组合</font></p>
<ul>
<li>大约需要占据4万多倍的原始空间。但是查询时间是40000多次</li>
</ul>
</li>
</ul>
<p>我们现在选取一个<font color="blue">空间和时间折衷的方案</font></p>
<p>需要空间：额外一点的空间，小于1倍，这里<strong>存储的是倒排索引不是签名</strong></p>
<p>2^16次方种16位签名，每个签名对应一个倒排索引，加起来索引数是原来的签名的数目。</p>
<p>需要时间：每一次查询，64位分成4部分，对应4个<strong>倒排索引表</strong>，<strong>假设文件在2^16个象限内分布是均匀的</strong>，那么就是4*2^(34-16)次比较。差不多100万次</p>
<p>相当于我们见了个表，直接把不相似的拿走了。——通过<strong><font color="blue">抽屉原理</font></strong></p>
<p>抽屉原理见上</p>
<p>所以我们这里会有<strong><font color="blue">一个额外的建立倒排索引表的操作</font></strong>,但是这个表是任意一次查询都可<strong><font color="blue">永久使用</font></strong>的，所以是<strong><font color="blue">值得的</font></strong></p>
<p>这个表的形式可以是线性表，因为16位是连续的，每个线性表里面存放对应的反倒排索引。</p>
<p>这样首先16位的查询只需要O(1)的时间，然后得到一个64位签名对应的</p>
<h3 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h3><p>外排序，顾名思义，即是<strong><font color="blue">在内存外面的排序</font></strong>，因为当要处理的数据量很大，而<strong>不能一次装入内存</strong>时，此时只能放在读写较慢的外存储器（通常是硬盘）上。</p>
<p>外排序通常采用的是一种<strong><font color="blue">“排序-归并”</font></strong>的策略。</p>
<ul>
<li>在排序阶段，<strong>先读入能放在内存中的数据量，将其排序输出到一个临时文件</strong>，依此进行，将待排序数据组织为<strong><font color="blue">多个有序的临时文件</font></strong>；</li>
<li>尔后在归并阶段<strong><font color="blue">将这些临时文件组合为一个大的有序文件</font></strong>，也即排序结果。</li>
</ul>
<p><font color="gray">比如，要对900 <a href="https://zh.wikipedia.org/wiki/兆字节" target="_blank" rel="noopener">MB</a>的数据进行排序，但机器只有100 MB的可用内存时，外归并排序按如下方法操作：</font></p>
<ol>
<li><font color="gray">读入100 MB的数据至内存中，用某种常规方式（如<a href="https://zh.wikipedia.org/wiki/快速排序" target="_blank" rel="noopener">快速排序</a>、<a href="https://zh.wikipedia.org/wiki/堆排序" target="_blank" rel="noopener">堆排序</a>、<a href="https://zh.wikipedia.org/wiki/归并排序" target="_blank" rel="noopener">归并排序</a>等方法）在内存中完成排序。</font></li>
<li><font color="gray">将排序完成的数据写入磁盘。</font></li>
<li><font color="gray">重复步骤1和2直到所有的数据都存入了不同的100 MB的块（临时文件）中。在这个例子中，有900 MB数据，单个临时文件大小为100 MB，所以会产生9个临时文件。</font></li>
<li><font color="gray">读入每个临时文件（顺串）的前10 MB（ = 100 MB / (9块 + 1)）的数据放入内存中的输入<a href="https://zh.wikipedia.org/wiki/缓冲区" target="_blank" rel="noopener">缓冲区</a>，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）</font></li>
<li><font color="gray">执行九路<a href="https://zh.wikipedia.org/w/index.php?title=归并&action=edit&redlink=1" target="_blank" rel="noopener">归并</a>算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 – 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，每个大块不用完全载入主存。</font></li>
</ol>
<p>为了增加每一个有序的临时文件的长度，可以采用<a href="https://zh.wikipedia.org/w/index.php?title=置换选择排序&action=edit&redlink=1" target="_blank" rel="noopener">置换选择排序</a>（Replacement selection sorting）。它可以产生大于内存大小的顺串。具体方法是在内存中使用一个<a href="https://zh.wikipedia.org/w/index.php?title=最小堆&action=edit&redlink=1" target="_blank" rel="noopener">最小堆</a>进行排序，设该最小堆的大小为{\displaystyle M}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f82cade9898ced02fdd08712e5f0c0151758a0dd" alt="M">。算法描述如下：</p>
<ol>
<li>初始时将输入文件读入内存，建立最小堆。</li>
<li>将堆顶元素输出至输出缓冲区。然后读入下一个记录：<ol>
<li>若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质；</li>
<li>否则将新元素放入堆底位置，将堆的大小减1。</li>
</ol>
</li>
<li>重复第2步，直至堆大小变为0。</li>
<li>此时一个顺串已经产生。将堆中的所有元素建堆，开始生成下一个顺串。<a href="https://zh.wikipedia.org/wiki/外排序#cite_note-3" target="_blank" rel="noopener">[3]</a></li>
</ol>
<p>此方法能生成平均长度为{\displaystyle 2M}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/beac4fab89c7f2b8472b8a83005f935d425b31de" alt="2M">的顺串，可以进一步减少访问外部存储器的次数，节约时间，提高算法效率。</p>
<p><strong>置换选择排序步骤</strong></p>
<ol>
<li>假设内存最大可以存大小为N的数组，首先读入数据数组array[N]，然后数组建最小堆</li>
<li>将堆顶输出，然后来一个元素，如果这个元素大于等于刚刚输出的元素，放到堆顶，然后堆维护，如果小于刚刚的元素，和堆底元素互换，并把堆的大小减1，然后堆维护</li>
<li>重复上述步骤直到堆的大小变为0</li>
</ol>
<p><font color="blue">平均可以生成2N长度的顺串</font>——因为每次我都会输出一个元素，而堆的大小可能减1，可能不减1，假设概率五五开，那么2N次才能结束，就输出了2N个数字，所以平均是2N</p>
<p><strong><font color="blue">提升外排序的效率&lt;=&gt;减少磁盘I/O次数&lt;=&gt;减少顺串数量和使用多路归并</font></strong></p>
<p><strong>减少顺串数量/增加顺串长度可以使用上述的置换选择排序</strong></p>
<p><strong>多路归并我们采用<font color="blue">败者树而不是堆</font></strong></p>
<p>首先介绍败者树和胜者树：</p>
<ul>
<li>胜败：子结点比较，<font color="blue">小者胜</font></li>
<li><font color="blue">所有数据储存在叶结点</font>，非叶结点存储败者or胜者</li>
<li>胜者树非叶结点存储胜者，败者树败者</li>
<li>都是<font color="blue">胜者进入下一轮</font>比赛</li>
</ul>
<p>败者树会在根结点再记录胜者，</p>
<p>可以推出，败者树和胜者树根结点存储的胜者都是该树的最小值。</p>
<p><font color="blue">败者树的维护：</font></p>
<p>新进入的结点 放在堆底的后面，然后与其父结点进行比赛，败者存在父结点，胜者再与上一级父结点进行比较，直到根结点，败者存在结点ls [1]中，胜者放在ls[0]中，如下图</p>
<p><img src="https://img-my.csdn.net/uploads/201204/04/1333509466_5499.jpg" alt="img"></p>
<p><font color="blue">和堆维护的区别</font>：</p>
<ul>
<li>堆维护从根结点到叶结点，败者树维护从新建的叶结点到根结点</li>
<li>堆维护和左右<font color="blue">子结点比较两次</font>，败者树维护和<font color="blue">父结点比较一次</font></li>
<li>堆维护在比较的过程中可能终止，败者树维护会一直比较到根结点</li>
</ul>
<p><strong>堆实现</strong>： 维护一个大小为k的小顶堆，每来一个数都和堆顶进行比较，如果比堆顶小，直接舍弃，否则替换堆顶，维护堆，直到n个数都处理完毕，时间复杂度为O(nlogk)</p>
<p>败者树实现：当用数组来实现败者树时， 维护一个叶子节点个数为k的败者树，注意是叶子节点个数而不是所有节点个数，数字较小者取胜，则最顶层保存的是值最小的叶子节点，每来一个数和最小值比较，如果比最小值还小，直接舍弃，否则替换最小值的节点值，从下往上维护败者树，最后的k个叶子节点中保存的就是所有数中值最大的k的，时间复杂度为O(nlogk)</p>
<p>用数组实现<strong>败者树的时候，因为只有叶子节点存储的是数据</strong>，因此<font color="blue">败者树使用的内存空间是堆的两倍。</font></p>
<p>完全树的内部，度数(分叉数)为2的节点个数是叶子节点个数减一 ，所以使用的数组大小为2k-1, 如果把最值也存入数组中，则需要的数组大小为2k</p>
<p><strong>败者树的构造</strong></p>
<p> 思路： 先构造一颗空的败者树，然后把叶子节点一个一个的插入败者树，自底向上不断的调整，保持内部节点保存的都是失败者的节点编号，优胜者一直向上不断比较，最终得到一颗合格的败者树。</p>
<p><font color="blue">leaves[K+1] </font>: 叶子节点的个数为K，下标从1到K，<font color="blue">下标0处存储一个最小值</font>，用来初始化败者树</p>
<p><font color="blue">loserTree[K]</font>:  <font color="blue">冠军节点存储在下标0</font>，下标1到K-1存储内部节点</p>
<p><font color="blue">叶子结点直接存就行了，需要改变/构建的是中间结点</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> loserTree[K];               <span class="comment">/* 存储中间节点值，下标0处存储冠军节点 */</span></span><br><span class="line"><span class="keyword">int</span> leaves[K+<span class="number">1</span>];                <span class="comment">/* 从下标1开始存储叶子节点值，下标0处存储一个最小值节点 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent=(i+K<span class="number">-1</span>)/<span class="number">2</span>;      <span class="comment">/* 求出父节点的下标 */</span></span><br><span class="line">    <span class="keyword">while</span>(parent&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(leaves[i]&gt;leaves[loserTree[parent]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=loserTree[parent];</span><br><span class="line">            loserTree[parent]=i;</span><br><span class="line">            <span class="comment">/* i指向的是优胜者 */</span></span><br><span class="line">            i= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = parent / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loserTree[<span class="number">0</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initLoserTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;K+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;leaves[i]);<span class="comment">//叶子结点存入Leaves</span></span><br><span class="line">    leaves[<span class="number">0</span>]=MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">        loserTree[i]=<span class="number">0</span>;<span class="comment">//中间结点初始化全0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=K;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        adjust(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时间看一下败者树和胜者树的构建，因为性质的不同而很不同</p>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>分布式处理之MapReduce</p>
<p> 方法介绍</p>
<p>MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行<font color="blue">并行计算</font>，减少整个操作的时间。但如果你要我再通俗点介绍，那么，<font color="blue">说白了，Mapreduce的原理就是一个归并排序</font>。</p>
<p>适用范围：数据量大，但是数据种类小可以放入内存</p>
<p>基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。</p>
<p>读者必须先要明确以下几点，以作为阅读后续内容的基础知识储备：</p>
<ol>
<li>MapReduce是一种模式。</li>
<li>Hadoop是一种框架。</li>
<li>Hadoop是一个实现了MapReduce模式的开源的分布式并行编程框架。</li>
</ol>
<p>所以，你现在，知道了什么是MapReduce，什么是hadoop，以及这两者之间最简单的联系，而本文的主旨即是，一句话概括：<strong>在hadoop的框架上采取MapReduce的模式处理海量数据</strong>。下面，咱们可以依次深入学习和了解MapReduce和hadoop这两个东西了。</p>
<h3 id="多层划分"><a href="#多层划分" class="headerlink" title="多层划分"></a>多层划分</h3><p><strong>多<font color="blue">层</font>划分</strong>:重点落在“层”上</p>
<p>多层划分法，<strong>本质上还是分而治之</strong>的思想，因为<strong>元素范围很大，不能利用直接寻址表</strong>，所以通过<font color="blue">多次划分，逐步确定范围</font>，然后最后在一个可以接受的范围内进行。</p>
<h4 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h4><p><strong>1、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数</strong></p>
<p>分析：有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，<font color="blue">划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域</font>，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。</p>
<p><strong>2、5亿个int找它们的中位数</strong></p>
<p>分析：首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p>
<p>实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>所谓的Bit-map就是<font color="blue">用一个bit位来标记某个元素对应的Value</font>， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在<font color="blue">存储空间方面，可以大大节省</font>。</p>
<p><strong>for example</strong></p>
<p>要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0,然后<font color="blue">遍历</font>这5个元素，首先第一个元素是4，那么就把4对应的位置为1,然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将<font color="blue">相应的位置为1</font></p>
<p>然后我们现在<font color="blue">遍历一遍Bit区域</font>，将该<font color="blue">位是一的位的编号输出</font>，这样就<font color="blue">达到了排序的目的</font>。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>可进行数据的<strong>快速查找，判重，删除，</strong>一般来说<strong>数据范围是int的10倍以下</strong></p>
<h4 id="问题实例-1"><a href="#问题实例-1" class="headerlink" title="问题实例"></a>问题实例</h4><p><strong><font color="blue">注意：位图的意义就在于“位”，所以在使用位图的标记时，一定要精确到位 </font></strong></p>
<p>比如<strong><font color="blue">一位就代表存在 or 不存在</font></strong></p>
<p><strong><font color="blue">两位就可以代表 存在 存在一次 存在多次</font></strong></p>
<p><strong><em>！！！ 不要用整数标记 因为整数太大！！！</em></strong></p>
<p><strong>1、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数</strong></p>
<p><strong>解法一</strong>：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</p>
<p><font color="blue">有点像状态机的意思</font> </p>
<p><strong>解法二</strong>：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”</p>
<p><strong>2、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</strong></p>
<p><strong>解法一</strong>：可以用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<p><font color="blue">位图在这里有点哈希表的意思，key是数值，value是”状态”(特别强调下状态的意思，不出现 出现一次 出现多次等等)</font></p>
<h3 id="Bloom-Filter（布隆过滤器）"><a href="#Bloom-Filter（布隆过滤器）" class="headerlink" title="Bloom Filter（布隆过滤器）"></a>Bloom Filter（布隆过滤器）</h3><p>布隆过滤器，是一种<strong>空间效率很高的随机数据结构</strong>，Bloom filter<font color="blue">可以看做是对bit-map的扩展</font>,它的原理是：</p>
<ul>
<li>当一个元素被加入集合时，通过<font color="blue">K个Hash函</font>将这个元素<font color="hlue">映射成</font>一个位阵列（Bit array）中的<font color="blue">K个点，把它们置为1</font>。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：<ul>
<li>如果这些点<strong>有任何一个0，则被检索元素一定不在</strong>；</li>
<li>如果<strong>都是1，则被检索元素<font color="blue">很可能在</font></strong>。</li>
</ul>
</li>
</ul>
<p>其可以用来实现数据字典，进行数据的判重，或者集合求交集。</p>
<p>但Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，<font color="blue">有可能会把不属于这个集合的元素误认为属于这个集合（false positive）</font>。因此，Bloom Filter<strong>不适合那些“零错误”的应用场合</strong>。而<strong>在能容忍低错误率的应用场合</strong>下，Bloom Filter<strong>通过极少的错误换取了存储空间的极大节省。</strong></p>
<h4 id="集合表示和元素查询"><a href="#集合表示和元素查询" class="headerlink" title="集合表示和元素查询"></a>集合表示和元素查询</h4><p><strong>初始状态</strong>时，Bloom Filter是一个包含<font color="blue">m位的位数组，每一位都置为0。</font></p>
<p>为了表达S={x1, x2,…,xn}这样一个<font color="blue">n个元素的集合</font>，<font color="blue">Bloom Filter使用k个相互独立的哈希函数</font>（Hash Function），它们<font color="blue">分别将集合中的每个元素映射到{1,…,m}</font>的范围中。对任意一个元素x，第i个哈希函数映射的位置hi(x)就会被置为1（1≤i≤k）。注意，如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，k=3，且有两个哈希函数选中同一个位置（从左边数第五位，即第二个“1“处）。</p>
<p><strong>注意上述表述</strong>，元素是n个，哈希函数是k个，映射的范围是1..m</p>
<p>假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素<strong>依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1</strong>。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的<font color="blue">其中有一个点不为1</font>，则可以判断<font color="blue">该元素一定不存在集合中</font>。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这<font color="blue">3个点是不同元素经过哈希得到的位置</font>，因此这种情况说明元素虽然不在集合中，<font color="blue">也可能对应的都是1，这是误判率存在的原因</font>。</p>
<h4 id="布隆过滤器添加元素"><a href="#布隆过滤器添加元素" class="headerlink" title="布隆过滤器添加元素"></a>布隆过滤器添加元素</h4><ul>
<li>将要添加的元素给k个哈希函数</li>
<li>得到对应于位数组上的k个位置</li>
<li>将这k个位置设为1</li>
</ul>
<h4 id="布隆过滤器查询元素"><a href="#布隆过滤器查询元素" class="headerlink" title="布隆过滤器查询元素"></a>布隆过滤器查询元素</h4><ul>
<li>将要查询的元素给k个哈希函数</li>
<li>得到对应于位数组上的k个位置</li>
<li>如果k个位置有一个为0，则肯定不在集合中</li>
<li>如果k个位置全部为1，则可能在集合中</li>
</ul>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>从布隆过滤的特性来看，主要是<font color="blue">查询是否存在</font></p>
<p>适合两个文件查找相同元素</p>
<h4 id="问题实例-2"><a href="#问题实例-2" class="headerlink" title="问题实例"></a>问题实例</h4><p><strong>1、给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？</strong></p>
<p><strong>分析</strong>：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。”</p>
<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>见前</p>
<h4 id="问题实例-3"><a href="#问题实例-3" class="headerlink" title="问题实例"></a>问题实例</h4><p><strong>1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析</strong></p>
<p><strong>提示</strong>：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平均长度），然后是找出出现最频繁的前10个词。当然，也可以用堆来实现，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一个。</p>
<p><strong>2、寻找热门查询</strong></p>
<p><strong>原题</strong>：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p><strong>提示</strong>：利用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><p>当遇到<strong>大数据量的增删改</strong>查时，一般把数据装进数据库中，从而利用数据的设计实现方法，对海量数据的增删改查进行处理。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>学习一个算法，可分为3个步骤：</p>
<ol>
<li><p>首先了解算法本身解决什么问题，</p>
</li>
<li><p>然后学习它的解决策略，</p>
</li>
<li><p>最后了解某些相似算法之间的联系</p>
</li>
</ol>
<p>图算法中</p>
<ul>
<li>广搜是一层一层往外遍历，寻找最短路径，其策略是采取队列的方法。</li>
<li>最小生成树是最小代价连接所有点，其策略是贪心，比如Prim的策略是贪心+权重队列。</li>
<li>Dijkstra是寻找单源最短路径，其策略是贪心+非负权重队列。</li>
<li>Floyd是多结点对的最短路径，其策略是动态规划。</li>
</ul>
<p>而贪心和动态规划是有联系的，贪心是“最优子结构+局部最优”，动态规划是“最优独立重叠子结构+全局最优”。一句话理解动态规划，则是枚举所有状态，然后剪枝，寻找最优状态，同时将每一次求解子问题的结果保存在一张“表格”中，以后再遇到重叠的子问题，从表格中保存的状态中查找（<font color="blue">俗称记忆化搜索</font>）。</p>
<p><strong><font color="blue">动态规划求解题目最重要的是要找到状态转移方程</font></strong></p>
<h3 id="最大连续乘积子串"><a href="#最大连续乘积子串" class="headerlink" title="最大连续乘积子串"></a>最大连续乘积子串</h3><p>给一个浮点数序列，取最大乘积连续子串的值，例如 -2.5，4，0，3，0.5，8，-1，则取出的最大乘积连续子串为3，0.5，8。也就是说，上述数组中，3 0.5 8这3个数的乘积$3<em>0.5</em>8=12$是最大的，而且是连续的。</p>
<h4 id="分析与解法"><a href="#分析与解法" class="headerlink" title="分析与解法"></a>分析与解法</h4><p>此最大乘积连续子串与最大乘积子序列不同，请勿混淆，前者<font color="blue">子串要求连续</font>，后者<font color="blue">子序列不要求连续</font>。也就是说，最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence，LCS）是：</p>
<ul>
<li>子串（Substring）是串的一个连续的部分，</li>
<li>子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；</li>
</ul>
<p>更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串“ acdfg ”同“ akdfc ”的最长公共子串为“ df ”，而它们的最长公共子序列LCS是“ adf ”，LCS可以使用动态规划法解决。</p>
<p><strong>解法一：暴力解法</strong></p>
<p>两次for循环 时间复杂度O(n^2)</p>
<p><strong>解法二：动态规划</strong></p>
<p>针对这道题目，我们<font color="blue">使用两个变量记录当前最大值maxEnd, 和当前最小值minEnd</font>。为什么记录当前最小值呢？因为,<font color="blue">数组中会出现负数，乘以一个负数的话，当前最小值是会逆袭的</font>！！</p>
<p><strong>状态转移方程</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxEnd=max(max(maxEnd*a[i], minEnd*a[i]), a[i]); <span class="comment">//更新当前最大值</span></span><br><span class="line">minEnd=min(min(maxEnd*a[i], minEnd*a[i]), a[i]); <span class="comment">//更新当前最小值</span></span><br></pre></td></tr></table></figure>

<p>代码 自己写的 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMaxSubStringProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; Seq)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> maxEnd = Seq[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">double</span> minEnd = Seq[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">double</span> maxResult = Seq[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;Seq.size();i++)&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; Seq[i] &lt;&lt; endl;</span></span><br><span class="line">		maxEnd = max(max(maxEnd*Seq[i],minEnd*Seq[i]),Seq[i]);</span><br><span class="line">		minEnd = min(min(maxEnd*Seq[i],minEnd*Seq[i]),Seq[i]);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "maxEnd is: " &lt;&lt; maxEnd &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; "maxResult is: " &lt;&lt; maxResult &lt;&lt; endl;</span></span><br><span class="line">		maxResult = max(maxEnd,maxResult);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; Seq&#123;<span class="number">-2.5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0.5</span>, <span class="number">8</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">double</span> result = findMaxSubStringProduct(Seq);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"MaxSubStringProduct is : "</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划求解的方法<font color="blue">一个for循环搞定，所以时间复杂度为O(n)</font>。</p>
<h4 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h4><p>1、给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意（N-1）个数的组合中乘积最大的一组，并写出算法的时间复杂度。</p>
<h3 id="字符串编辑距离"><a href="#字符串编辑距离" class="headerlink" title="字符串编辑距离"></a>字符串编辑距离</h3><p>给定一个源串和目标串，能够对源串进行如下操作：</p>
<ol>
<li>在给定位置上<font color="blue">插入一个字符</font></li>
<li><font color="blue">替换</font>任意字符</li>
<li><font color="blue">删除</font>任意字符</li>
</ol>
<p>写一个程序，<strong>返回最小操作数，使得对源串进行这些操作后等于目标串</strong>，源串和目标串的长度都小于2000。</p>
<h4 id="分析与解法-1"><a href="#分析与解法-1" class="headerlink" title="分析与解法"></a>分析与解法</h4><p>此题常见的思路是动态规划，假如令$dp[i][j]$ 表示源串S[0…i] 和目标串T[0…j] 的最短编辑距离，其边界：<code>dp[0][j] = j</code>，<code>dp[i][0] = i</code>，那么我们可以得出状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> dp[i][j] =min&#123;</span><br><span class="line">   dp[i-1][j] + 1 , S[i]不在T[0…j]中</span><br><span class="line">   dp[i-1][j-1] + 1/0 , S[i]在T[j]</span><br><span class="line">   dp[i][j-1] + 1 , S[i]在T[0…j-1]中</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，咱们重点解释下上述3个式子的含义</p>
<ul>
<li>关于<code>dp[i-1][j] + 1</code>, s.t. s[i]不在T[0…j]中的说明<ul>
<li>s[i]没有落在T[0…j]中，即s[i]在中间的某一次编辑操作被删除了。因为删除操作没有前后相关性，不妨将其在第1次操作中删除。除首次操作时删除外，后续编辑操作是将长度为i-1的字符串，编辑成长度为j的字符串：即<code>dp[i-1][j]</code>。</li>
<li>因此：<code>dp[i][j] = dp[i-1][j] + 1</code>。</li>
</ul>
</li>
<li>关于<code>dp[i-1][j-1] + 0/1</code>, s.t. s[i] 在T[j]的说明<ul>
<li>若s[i]经过编辑，最终落在T[j]的位置。</li>
<li>则要么s[i] == t[j]，s[i]直接落在T[j]。这种情况，编辑操作实际上是将长度为i-1的S’串，编辑成长度为j-1的T’串：即<code>dp[i-1][j-1]</code>；</li>
<li>要么s[i] ≠ t[j]，s[i] 落在T[j]后，要将s[i]修改成T[j]，即在上一种情况的基础上，增加一次修改操作：即<code>dp[i-1][j-1] + 1</code>。</li>
</ul>
</li>
<li>关于dp[i][j-1] + 1, s.t. s[i]在T[0…j-1]中的说明<ul>
<li>若s[i]落在了T[1…j-1]的某个位置，不妨认为是k，因为最小编辑步数的定义，那么，在k+1到j-1的字符，必然是通过插入新字符完成的。因为共插入了(j-k)个字符，故编辑次数为(j-k)次。而字符串S[1…i]经过编辑，得到了T[1…k]，编辑次数为<code>dp[i][k]</code>。故： <code>dp[i][j] = dp[i][k] + (j-k)</code>。</li>
<li>由于最后的(j-k)次是插入操作，可以讲(j-k)逐次规约到dp[i][k]中。即：<code>dp[i][k]+(j-k)=dp[i][k+1] + (j-k-1)</code> 规约到插入操作为1次，得到 <code>dp[i][k]+(j-k) =dp[i][k+1] + (j-k-1) =dp[i][k+2] + (j-k-2)=… =dp[i][k+(j-k-1)] + (j-k)-(j-k-1) =dp[i][j-1] + 1</code>。</li>
</ul>
</li>
</ul>
<p>上述的解释清晰规范，但<strong><font color="blue">为啥这样做呢</font></strong>？</p>
<p>换一个角度，其实就是<font color="blue">字符串对齐的思路</font>。例如把字符串“ALGORITHM”，变成“ALTRUISTIC”，那么把相关字符各自对齐后，如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20140616114324296" alt="img"></p>
<p>把图中上面的源串S[0…i] = “ALGORITHM”编辑成下面的目标串T[0…j] = “ALTRUISTIC”，我们枚举字符串S和T最后一个字符s[i]、t[j]</p>
<p><font color="blue">对应四种情况：（字符-空白）（空白-字符）(字符-字符)（空白-空白）</font>其实压根就没有空白到空白。</p>
<p>由于其中的（空白-空白）是多余的编辑操作。所以，<font color="blue">事实上只存在以下3种情况</font>：</p>
<ul>
<li><font color="blue">下面的目标串空白</font>，即S + 字符X，T + 空白，S变成T，<font color="blue">意味着源串要删字符</font><ul>
<li>dp[i - 1, j] + 1</li>
</ul>
</li>
<li><font color="blue">上面的源串空白</font>，S + 空白，T + 字符，S变成T，最后，在S的最后插入“字符”，<font color="blue">意味着源串要添加字符</font><ul>
<li>dp[i, j - 1] + 1</li>
</ul>
</li>
<li><font color="blue">上面源串中的的字符跟下面目标串中的字符不一样</font>，即S + 字符X，T + 字符Y，S变成T，<font color="blue">意味着源串要修改字符</font><ul>
<li>dp[i - 1, j - 1] + (s[i] == t[j] ? 0 : 1)</li>
</ul>
</li>
</ul>
<p>综上，可以写出简单的DP状态方程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i,j]表示表示源串S[0…i] 和目标串T[0…j] 的最短编辑距离</span></span><br><span class="line">dp[i, j] = min &#123; dp[i - <span class="number">1</span>, j] + <span class="number">1</span>,  dp[i, j - <span class="number">1</span>] + <span class="number">1</span>,  dp[i - <span class="number">1</span>, j - <span class="number">1</span>] + (s[i] == t[j] ? <span class="number">0</span> : <span class="number">1</span>) &#125;</span><br><span class="line"><span class="comment">//分别表示：删除1个，添加1个，替换1个（相同就不用替换）。</span></span><br></pre></td></tr></table></figure>

<h4 id="举一反三-1"><a href="#举一反三-1" class="headerlink" title="举一反三"></a>举一反三</h4><p>1、传统的编辑距离里面有三种操作，即增、删、改，我们现在要讨论的编辑距离只允许两种操作，即增加一个字符、删除一个字符。我们求两个字符串的这种编辑距离，即把一个字符串变成另外一个字符串的最少操作次数。假定每个字符串长度不超过1000，只有大写英文字母组成。</p>
<p>这个简单，<font color="blue">把出现替换情况的部分，把数值1改为2，因为由原来的一次替换操作变成了先删除后插入的2次操作</font></p>
<p>2、有一亿个数，输入一个数，找出与它编辑距离在3以内的数，比如输入6（0110），找出0010等数，数是32位的。</p>
<p>这道题的话，如果都是32位的，，可以直接通过比较不同的位来判断编辑距离，因为<font color="blue">只用替换一种操作即可</font>，所以可以直接<font color="blue">两数相异或然后求解疑惑结果中1的个数（用那个最高效的算法） ,得到的结果就是<font color="blue">编辑距离</font></font></p>
<p>然后直接遍历一遍即可。</p>
<h4 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h4><p>实际上，关于这个“编辑距离”问题在搜索引擎中有着重要的作用，如搜索引擎关键字查询中拼写错误的提示，如下图所示，当你输入“<a href="https://www.google.com.hk/search?hl=zh-CN&newwindow=1&safe=strict&site=&source=hp&q=Jult&btnK=Google+搜索" target="_blank" rel="noopener">Jult</a>”后，因为没有这个单词“Jult”，所以搜索引擎猜测你可能是输入错误，进而会提示你是不是找“July”： </p>
<p>当然，面试官还可以继续问下去，如请问，如何设计一个比较这篇文章和上一篇文章相似性的算法？</p>
<h3 id="格子取数问题"><a href="#格子取数问题" class="headerlink" title="格子取数问题"></a>格子取数问题</h3><p><strong>题目描述</strong></p>
<p>有n*n个格子，每个格子里有<font color="blue">正数或者0</font>，从最左上角往最右下角走，只能<font color="blue">向下和向右</font>，一共<strong><font color="blue">走两次</font></strong>（即从左上角走到右下角走两趟），把所有经过的格子的数加起来，求最大值SUM，且两次<font color="blue">如果经过同一个格子，则最后总和SUM中该格子的计数只加一次</font>。</p>
<p>保证了<font color="blue">连续的两次走法都是最优</font>的，但却<font color="blue">不能保证总体最优</font></p>
<p>局部贪优不行，我们可以考虑穷举，但最终将导致复杂度过高，所以咱们得另寻良策。</p>
<p>先对矩阵做一个编号，且以5*5的矩阵为例（给这个矩阵起个名字叫M1）</p>
<p>M1</p>
<p>0 1 2 3 4</p>
<p>1 2 3 4 5</p>
<p>2 3 4 5 6</p>
<p>3 4 5 6 7</p>
<p>4 5 6 7 8</p>
<p><strong><font color="blue">注意上面的每个数字都代表了到这个结点要走的步数</font></strong></p>
<p>从左上(0)走到右下(8)共需要走8步（2*5-2）。我们设所走的步数为s。因为限定了只能向右和向下走，因此无论如何走，经过8步后（s = 8)都将走到右下。而DP的状态也是依据所走的步数来记录的。</p>
<p>再来分析一下经过其他s步后所处的位置，根据上面的讨论，可以知道：</p>
<ul>
<li>经过8步后，一定处于右下角(8)；</li>
<li>那么经过5步后(s = 5)，肯定会处于编号为5的位置；</li>
<li>3步后肯定处于编号为3的位置；</li>
<li>s = 4的时候，处于编号为4的位置，此时对于方格中，共有5（相当于n）个不同的位置，也是所有编号中最多的。</li>
</ul>
<p>故推广来说，<font color="blue">对于n*n的方格，总共需要走2n - 2步，且当s = n - 1时，编号为n个，也是编号数最多的</font>。</p>
<p>如果用DP[s,i,j]来记录2次所走的状态获得的最大值，其中<font color="blue">s表示走s步，i和j分别表示在s步后第1趟走的位置和第2趟走的位置</font>。</p>
<p>为了方便描述，再对矩阵做一个编号（给这个矩阵起个名字叫M2）：</p>
<p>M2</p>
<p>0 0 0 0 0</p>
<p>1 1 1 1 1</p>
<p>2 2 2 2 2</p>
<p>3 3 3 3 3</p>
<p>4 4 4 4 4</p>
<p>M1</p>
<p>0 1 2 3 4</p>
<p>1 2 3 4 5</p>
<p>2 3 4 5 6</p>
<p>3 4 5 6 7</p>
<p>4 5 6 7 8</p>
<p>我们先看M1，在经过5步后，肯定处于M1中编号为5的位置。而M1中共有3个编号为5的，它们分别对应M2中的2 3 4。故对于M2来说，假设第1次经过5步走到了M2中的2，第2次经过5步走到了M2中的4，<font color="blue">DP[s,i,j] 则对应 DP[5,2,4]。由于s = 2n - 2,0 &lt;= i &lt;= j &lt;= n，所以这个DP共有O(n^3)个状态。</font></p>
<p><font color="blue">分析一下状态转移</font>，以DP[6,2,3]为例(就是上面M1中加粗的部分)，可以到达DP[6,2,3]的状态包括DP[5,1,2]，DP[5,1,3]，DP[5,2,2]，DP[5,2,3]。</p>
<p>因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DP[6,2,3] = Max(DP[5,1,2] ，DP[5,1,3]，DP[5,2,2]，DP[5,2,3]) + 6,2和6,3格子中对应的数值    （式一）</span><br></pre></td></tr></table></figure>

<p>上面（式一）所示的这个递推看起来没有涉及：“如果两次经过同一个格子，那么该数只加一次的这个条件”，讨论这个条件需要换一个例子，以DP[6,2,2]为例：DP[6,2,2]可以由DP[5,1,1]，DP[5,1,2]，DP[5,2,2]到达，但由于i = j，也就是2次走到同一个格子，那么数值只能加1次。 所以当i = j时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DP[6,2,2] = Max(DP[5,1,1]，DP[5,1,2]，DP[5,2,2]) + 6,2格子中对应的数值                                （式二）</span><br></pre></td></tr></table></figure>

<p>故，综合上述的（式一），（式二）最后的递推式就是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i != j) </span><br><span class="line">	DP[s, i ,j] = Max(DP[s - <span class="number">1</span>, i - <span class="number">1</span>, j - <span class="number">1</span>], DP[s - <span class="number">1</span>, i - <span class="number">1</span>, j], 	DP[s - <span class="number">1</span>, i, j - <span class="number">1</span>], DP[s - <span class="number">1</span>, i, j]) + W[s,i] + W[s,j] </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	DP[s, i ,j] = Max(DP[s - <span class="number">1</span>, i - <span class="number">1</span>, j - <span class="number">1</span>], DP[s - <span class="number">1</span>, i - <span class="number">1</span>, j], 	DP[s - <span class="number">1</span>, i, j]) + W[s,i]</span><br></pre></td></tr></table></figure>

<p>其中W[s,i]表示经过s步后，处于i位置，位置i对应的方格中的数字。下一节我们将根据上述DP方程编码实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copyright@caopengcs 2013</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">202</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1000000000</span>;  <span class="comment">//无穷大</span></span><br><span class="line"><span class="keyword">int</span> dp[N * <span class="number">2</span>][N][N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> n)</span> <span class="comment">//判断状态是否合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y1 = step - x1, y2 = step - x2;</span><br><span class="line">    <span class="keyword">return</span> ((x1 &gt;= <span class="number">0</span>) &amp;&amp; (x1 &lt; n) &amp;&amp; (x2 &gt;= <span class="number">0</span>) &amp;&amp; (x2 &lt; n) &amp;&amp; (y1 &gt;= <span class="number">0</span>) &amp;&amp; (y1 &lt; n) &amp;&amp; (y2 &gt;= <span class="number">0</span>) &amp;&amp; (y2 &lt; n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> n)</span>  <span class="comment">//处理越界 不存在的位置 给负无穷的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IsValid(step, x1, x2, n) ? dp[step][x1][x2] : (-inf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态表示dp[step][i][j] 并且i &lt;= j, 第step步  两个人分别在第i行和第j行的最大得分 时间复杂度O(n^3) 空间复杂度O(n^3)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinPathSum</span><span class="params">(<span class="keyword">int</span> a[N][N], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> P = n * <span class="number">2</span> - <span class="number">2</span>; <span class="comment">//最终的步数</span></span><br><span class="line">    <span class="keyword">int</span> i, j, step;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能到达的位置 设置为负无穷大</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][j] = -inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (step = <span class="number">1</span>; step &lt;= P; ++step)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[step][i][j] = -inf;</span><br><span class="line">                <span class="keyword">if</span> (!IsValid(step, i, j, n))   <span class="comment">//非法位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//对于合法的位置进行dp</span></span><br><span class="line">                <span class="keyword">if</span> (i != j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[step][i][j] = max(dp[step][i][j], GetValue(step - <span class="number">1</span>, i - <span class="number">1</span>, j - <span class="number">1</span>, n));</span><br><span class="line">                    dp[step][i][j] = max(dp[step][i][j], GetValue(step - <span class="number">1</span>, i - <span class="number">1</span>, j, n));</span><br><span class="line">                    dp[step][i][j] = max(dp[step][i][j], GetValue(step - <span class="number">1</span>, i, j - <span class="number">1</span>, n));</span><br><span class="line">                    dp[step][i][j] = max(dp[step][i][j], GetValue(step - <span class="number">1</span>, i, j, n));</span><br><span class="line">                    dp[step][i][j] += a[i][step - i] + a[j][step - j];  <span class="comment">//不在同一个格子，加两个数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[step][i][j] = max(dp[step][i][j], GetValue(step - <span class="number">1</span>, i - <span class="number">1</span>, j - <span class="number">1</span>, n));</span><br><span class="line">                    dp[step][i][j] = max(dp[step][i][j], GetValue(step - <span class="number">1</span>, i - <span class="number">1</span>, j,  n));</span><br><span class="line">                    dp[step][i][j] = max(dp[step][i][j], GetValue(step - <span class="number">1</span>, i, j,  n));</span><br><span class="line">                    dp[step][i][j] += a[i][step - i]; <span class="comment">// 在同一个格子里，只能加一次</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[P][n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="举一反三-2"><a href="#举一反三-2" class="headerlink" title="举一反三"></a>举一反三</h4><p>1、给定m*n的矩阵，每个位置是一个非负整数，从左上角开始，每次只能朝右和下走，走到右下角，但只走一次，求总和最小的路径。</p>
<p>提示：因为只走一次，所以相对来说比较简单，dp[0, 0]=a[0, 0]，且dp[x, y] = min(dp[x-1, y] + a[x, y]dp[x, y-1] + a[x, y])。</p>
<p>2、给定m*n的矩阵，每个位置是一个整数，从左上角开始，每次只能朝右、上和下走，并且不允许两次进入同一个格子，走到右上角，最小和。</p>
<p>分析：@cpcs ：我们按列dp，假设前一列的最优值已经算好了，一旦往右就回不去了。枚举我们从对固定的(y-1)列，我们已经算好了最优值，我们枚举行x，朝右走到(x,y),然后再从(x,y)朝上走到(x,0)，再从(x,y)朝下走到(x,n-1)，所有这些第y列的值，作为第y列的候选值，取最优。 实际上，我们枚举了进入第y列的位置和在最终停在第y列的位置。这样保证我们不重复经过一个格子，也能保证我们不会往“左”走。</p>
<h3 id="交替字符串"><a href="#交替字符串" class="headerlink" title="交替字符串"></a>交替字符串</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入<font color="blue">三个字符串s1、s2和s3</font>，判断<font color="blue">第三个字符串s3是否由前两个字符串s1和s2交错而成</font>，即不改变s1和s2中各个字符原有的相对顺序，例如当s1 = “aabcc”，s2 = “dbbca”，s3 = “aadbbcbcac”时，则输出true，但如果s3=“accabdbbca”，则输出false。</p>
<h4 id="分析与解法-2"><a href="#分析与解法-2" class="headerlink" title="分析与解法"></a>分析与解法</h4><p>此题不能简单的排序，因为一旦排序，便改变了s1或s2中各个字符原始的相对顺序，既然不能排序，咱们可以考虑下用动态规划的方法，令<font color="blue"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果s1当前字符（即s1[i-1]）等于s3当前字符（即s3[i+j-1]），而且```dp[i-1][j]```为真，那么可以取s1当前字符而忽略s2的情况，```dp[i][j]```返回真；</span><br><span class="line">- 如果s2当前字符等于s3当前字符，并且```dp[i][j-1]```为真，那么可以取s2而忽略s1的情况，`dp[i][j]`返回真，其它情况，```dp[i][j]```返回假</span><br><span class="line"></span><br><span class="line">代码（自己写的）：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool crossStringCheck(string s1, string s2, string s3)&#123;</span><br><span class="line">	int result = false;</span><br><span class="line">	int row = s1.size();</span><br><span class="line">	int col = s2.size();</span><br><span class="line">	int length = s3.size();</span><br><span class="line">	if(row+col != length)</span><br><span class="line">		return result;</span><br><span class="line">	bool dp[row+1][col+1];// we start with &apos;&apos; rather than &apos;x&apos;, we suppose that &apos;&apos; can be composed by &apos;&apos; and &apos;&apos; which means dp[0][0] is true</span><br><span class="line">	dp[0][0] = true;</span><br><span class="line">	for(int i=0; i&lt;row+1; i++)&#123;</span><br><span class="line">		for(int j = 0;j&lt;col+1;j++)&#123;</span><br><span class="line">			if((i-1&gt;=0&amp;&amp;dp[i-1][j]==true&amp;&amp;s1[i-1]==s3[i-1+j])||(j-1&gt;=0&amp;&amp;dp[i][j-1]==true&amp;&amp;s2[j-1]==s3[i+j-1])||dp[i][j]) // attention: why &quot;||dp[i][j]&quot;? ——we need to take dp[0][0] into account</span><br><span class="line">				dp[i][j] = true;</span><br><span class="line">			else</span><br><span class="line">				dp[i][j] = false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[row][col];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	string s1 = &quot;clear&quot;;</span><br><span class="line">	string s2 = &quot;farm&quot;;</span><br><span class="line">	string s3 = &quot;cfleaarrm&quot;;</span><br><span class="line">	bool result1 = crossStringCheck(s1,s2,s3);</span><br><span class="line">	bool result2 = crossStringCheck(s1,s3,s2);</span><br><span class="line">	bool result3 = crossStringCheck(s2,s3,s1);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;s3 can be crossed by s1&amp;s2: &quot; &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;s2 can be crossed by s1&amp;s3: &quot; &lt;&lt; result2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;s1 can be crossed by s2&amp;s3: &quot; &lt;&lt; result3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p>
<h2 id="程序员如何准备面试中的算法"><a href="#程序员如何准备面试中的算法" class="headerlink" title="程序员如何准备面试中的算法"></a>程序员如何准备面试中的算法</h2><p>大部分的面试题都在围绕一个点：<strong><font color="blue">基于各种数据结构上的增删改查</font></strong>。如字符串的查找翻转，链表的查找遍历合并删除，树和图的查找遍历，后来为了更好的查找，我们想到了排序，排序仍然不够，我们有了贪心、动态规划，再后来东西多了，于是有了海量数据处理，资源有限导致人们彼此竞争，出现了博弈组合概率。</p>
<p>如果学数据结构，可以看我们在大学里学的任一本数据结构教材都行，如果你觉得实在不够上档次，那么可以再看看<strong>《STL源码剖析》</strong>。</p>
<p>如果你已经学完了一本数据结构教材，那么建议你着重看<strong><font color="blue">贪心、动态规划、图论</font></strong>等内容，这3个议题每一个议题都大有题目可出。同时，熟悉<a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">常用算法的时间复杂度</a>。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>6个经典的字符串问题，分别是<strong>旋转字符串</strong>、<strong>字符串包含</strong>、<strong>字符串转换成整数</strong>、<strong>回文判断</strong>、<strong>最长回文子串</strong>、<strong>字符串的全排列</strong></p>
<p>读完本章后会发现，好的思路都是在<font color="blue">充分考虑到问题本身的特征</font>的前提下，或巧用<font color="blue">合适的数据结构</font>，或选择<font color="blue">合适的算法</font>降低时间复杂度（避免不必要的操作），或选用<font color="blue">效率更高的算法</font>。</p>
<h3 id="旋转字符串"><a href="#旋转字符串" class="headerlink" title="旋转字符串"></a>旋转字符串</h3><p>给定一个字符串，要求<font color="blue">把字符串前面的若干个字符移动到字符串的尾部</font>，如把字符串“abcdef”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的<font color="blue">时间复杂度为 O(n)，空间复杂度为 O(1)</font>。</p>
<p><strong>特别注意，我们这里空间复杂度为O(1)，所以我们是不能直接全部存储字符串尾部的部分，因为这部分的空间复杂度可以认为是O(n)</strong></p>
<p><strong>合适的解法——三步反转法</strong></p>
<p>对于这个问题，换一个角度思考一下。</p>
<p>将一个字符串分成X和Y两个部分，在每部分字符串上定义反转操作，如X^T，即把X的所有字符反转（如，X=”abc”，那么X^T=”cba”），那么就得到下面的结论：(X^TY^T)^T=YX，显然就解决了字符串的反转问题。</p>
<p>例如，字符串 abcdef ，若要让def翻转到abc的前头，只要按照下述3个步骤操作即可：</p>
<ol>
<li>首先将原字符串分为两个部分，即X:abc，Y:def；</li>
<li>将X反转，X-&gt;X^T，即得：abc-&gt;cba；将Y反转，Y-&gt;Y^T，即得：def-&gt;fed。</li>
<li>反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。</li>
</ol>
<p>相当于是，<font color="blue">把两部分分别反转，然后对整体反转</font></p>
<p>代码（自己写的）</p>
<p>移动前m个字符到后面</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strReverseCore</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> tmp ;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=(start+end)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">char</span> tmp = str[i];</span><br><span class="line">		str[i] = str[end+start-i];</span><br><span class="line">		str[end+start-i] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strReverse</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = str.size();</span><br><span class="line">	strReverseCore(str,<span class="number">0</span>,m<span class="number">-1</span>);</span><br><span class="line">	strReverseCore(str,m,length<span class="number">-1</span>);</span><br><span class="line">	strReverseCore(str,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">"abcdefghi"</span>;</span><br><span class="line">	<span class="keyword">int</span> m = <span class="number">5</span>;</span><br><span class="line">	strReverse(str,m);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reverse Str is: "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串包含"><a href="#字符串包含" class="headerlink" title="字符串包含"></a>字符串包含</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个分别由字母组成的字符串A和字符串B，<font color="blue">字符串B的长度比字符串A短</font>。请问，如何<font color="blue">最快地判断字符串B中所有字母是否都在字符串A里</font>？</p>
<p>为了<font color="blue">简单起见</font>，我们规定输入的字符串<font color="blue">只包含大写英文字母</font>，请实现函数bool StringContains(string &amp;A, string &amp;B)</p>
<p>比如，如果是下面两个字符串：</p>
<p>String 1：ABCD</p>
<p>String 2：BAD</p>
<p>答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。</p>
<p>如果是下面两个字符串：</p>
<p>String 1：ABCD</p>
<p>String 2：BCE</p>
<p>答案是false，因为字符串String2里的E字母不在字符串String1里。</p>
<p>同时，如果string1：ABCD，string 2：AA，同样返回true。</p>
<p><font color="blue">重复出现算一次</font></p>
<p>直接就想到了最好的算法——哈希表</p>
<p>可以先把长字符串a中的所有字符都放入一个Hashtable里，然后轮询短字符串b，看短字符串b的每个字符是否都在Hashtable里，如果都存在，说明长字符串a包含短字符串b，否则，说明不包含。</p>
<p>再进一步，我们可以对字符串A，用<strong><font color="blue">位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找</font></strong>。</p>
<p><strong>26 位的签名代替了长度为26的数组，虽然都是O(1)，但是占用空间更小了，厉害！！！</strong></p>
<p><strong><font color="blue">位签名</font></strong>——好好消化</p>
<p>这个方法的实质是用一个整数代替了hashtable，空间复杂度为O(1)，时间复杂度还是O(n + m)。</p>
<p>代码</p>
<p>注意<font color="blue">移位 或的操作</font>——位运算</p>
<p>注意在 <font color="blue">多种运算符出现在同一个表达式中，注意使用括号来区分优先级</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInclude</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s2.size();i++)</span><br><span class="line">		hash |= <span class="number">1</span>&lt;&lt;(s2[i]-<span class="string">'a'</span>) ;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;s1.size();j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(((<span class="number">1</span>&lt;&lt;(s1[j]-<span class="string">'a'</span>))&amp;hash) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">"bfcd"</span>;</span><br><span class="line">	<span class="built_in">string</span> s2 = <span class="string">"hah"</span>;</span><br><span class="line">	<span class="built_in">string</span> s3 = <span class="string">"bhafcd"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">bool</span> result1 = isInclude(s1,s2);</span><br><span class="line">	<span class="keyword">bool</span> result2 = isInclude(s1,s3);</span><br><span class="line">	<span class="keyword">bool</span> result3 = isInclude(s2,s3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s2 include s1 : "</span> &lt;&lt; result1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s3 include s1 : "</span> &lt;&lt; result2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s3 include s2 : "</span> &lt;&lt; result3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="举一反三-3"><a href="#举一反三-3" class="headerlink" title="举一反三"></a>举一反三</h4><p>1、变位词</p>
<ul>
<li>如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，比如bad和adb即为兄弟字符串，现提供一个字符串，如何在字典中迅速找到它的兄弟字符串，请描述数据结构和查询过程。</li>
</ul>
<p><strong><font color="blue">签名一致</font></strong></p>
<h3 id="字符串转换成整数"><a href="#字符串转换成整数" class="headerlink" title="字符串转换成整数"></a>字符串转换成整数</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串”123”，输出整数123。</p>
<p>给定函数原型<code>int StrToInt(const char \*str)</code> ，实现字符串转换成整数的功能，不能使用库函数atoi</p>
<p><strong><font color="blue">这个问题中边界问题很重要</font></strong></p>
<p><strong>基本思路</strong>便是：从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字。</p>
<p><font color="blue">以下细节</font>：</p>
<ol>
<li><strong>空指针输入</strong>：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。</li>
<li><strong>正负符号</strong>：整数不仅包含数字，还有可能是以’+’或’-‘开头表示正负整数，因此如果第一个字符是’-‘号，则要把得到的整数转换成负整数。</li>
<li><strong>非法字符</strong>：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。</li>
<li><strong>整型溢出</strong>：输入的数字是以字符串的形式输入，因此输入<font color="blue">一个很长的字符串将可能导致溢出</font>。</li>
</ol>
<p>上述其它问题比较好处理，但溢出问题比较麻烦，所以咱们来<font color="blue">重点看下溢出</font>问题。</p>
<p>一般说来，当<strong><font color="blue">发生溢出时，取最大或最小的int值</font></strong>。</p>
<p>即大于正整数能表示的范围时返回MAX_INT：2147483647；</p>
<p>小于负整数能表示的范围时返回MIN_INT：-2147483648。</p>
<p>针对这种由于输入了一个很大的数字转换之后会超过能够表示的最大的整数而导致的溢出情况，我们有两种处理方式可以选择：</p>
<ul>
<li>一个取巧的方式是把转换后返回的值n定义成long long，即long long n；</li>
<li>另外一种则是<font color="blue">只比较n和MAX_INT / 10的大小</font>，即：<ul>
<li><strong>若n &gt; MAX_INT / 10</strong>，那么说明最后一步转换时，n*10必定大于MAX_INT，所以在得知n &gt; MAX_INT / 10时，当即返回MAX_INT&lt;。</li>
<li><strong>若n == MAX_INT / 10时</strong>，那么比较最后一个数字c跟MAX_INT % 10的大小，即如果n == MAX_INT / 10且c &gt; MAX_INT % 10，则照样返回MAX_INT。</li>
</ul>
</li>
</ul>
<p>对于上面第一种方式，虽然我们把n定义了长整型，但最后返回时系统会自动转换成整型。咱们下面主要来看第二种处理方式。</p>
<p>对于上面第二种方式，先举两个例子说明下：</p>
<ul>
<li>如果我们要转换的字符串是”2147483697”，那么当我扫描到字符’9’时，判断出214748369 &gt; MAX_INT / 10 = 2147483647 / 10 = 214748364（C语言里，整数相除自动取整，不留小数），则返回MAX_INT；</li>
<li>如果我们要转换的字符串是”2147483648”，那么判断最后一个字符’8’所代表的数字8与MAX_INT % 10 = 7的大小，前者大，依然返回MAX_INT。</li>
</ul>
<p><font color="blue">代码 自己写的</font></p>
<p><strong><font color="blue">尤其注意：区分数字和字符串，比较的时候 ‘9’-‘0’才是9，不要忘了字符串要 -‘0’ </font></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSign</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((x==<span class="string">'-'</span>)||(x==<span class="string">'+'</span>))?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((x&gt;=<span class="string">'0'</span>)&amp;&amp;(x&lt;=<span class="string">'9'</span>))?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi_</span><span class="params">(<span class="keyword">char</span>* ptr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* tmp = ptr;</span><br><span class="line">	<span class="keyword">if</span>(tmp==<span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"Input is invalid!(nullptr)"</span> ;</span><br><span class="line">	<span class="keyword">if</span>(!isValid(*tmp)&amp;&amp;!isSign(*tmp))</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"Input is invalid!"</span>;</span><br><span class="line">	<span class="keyword">bool</span> sgn = (*tmp==<span class="string">'-'</span>)?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(isSign(*tmp))</span><br><span class="line">		tmp++;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*tmp!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!isValid(*tmp))</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"Input is invalid"</span>;</span><br><span class="line">		<span class="keyword">if</span>(result&gt;INT_MAX/<span class="number">10</span>||((result==INT_MAX/<span class="number">10</span>)&amp;&amp;((*tmp-<span class="string">'0'</span>)&gt;(INT_MAX%<span class="number">10</span>+<span class="number">1</span>-sgn))))&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Overflow!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			result =  sgn?INT_MAX:(INT_MIN);</span><br><span class="line">			sgn = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		result = result*<span class="number">10</span> + (*tmp-<span class="string">'0'</span>);</span><br><span class="line">		tmp++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sgn?result:-result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">"fadsfasdf"</span>;</span><br><span class="line">	<span class="built_in">string</span> s2 = <span class="string">"+1234"</span>;</span><br><span class="line">	<span class="built_in">string</span> s3 = <span class="string">"-12341324"</span>;</span><br><span class="line">	<span class="built_in">string</span> s4 = <span class="string">"-2345a232"</span>;</span><br><span class="line">	<span class="built_in">string</span> s5 = <span class="string">"111111111111111111111111"</span>;</span><br><span class="line">	<span class="built_in">string</span> s6 = <span class="string">"-11111111111111111111111"</span>;</span><br><span class="line">	<span class="built_in">string</span> s7 = <span class="string">"2147483647"</span>;</span><br><span class="line">	<span class="built_in">string</span> s8 = <span class="string">"2147483648"</span>;</span><br><span class="line">	<span class="built_in">string</span> s9 = <span class="string">"-2147483648"</span>;</span><br><span class="line">	<span class="built_in">string</span> s10 = <span class="string">"-2147483649"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	cout &lt;&lt; "s1 is:" &lt;&lt; atoi_(&amp;(s1[0])) &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s2 is:"</span> &lt;&lt; atoi_(&amp;s2[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s3 is:"</span> &lt;&lt; atoi_(&amp;s3[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; "s4 is:" &lt;&lt; atoi_(&amp;s4[0]) &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s5 is:"</span> &lt;&lt; atoi_(&amp;s5[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s7 is:"</span> &lt;&lt; atoi_(&amp;s7[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s8 is:"</span> &lt;&lt; atoi_(&amp;s8[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s9 is:"</span> &lt;&lt; atoi_(&amp;s9[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"s10 is:"</span> &lt;&lt; atoi_(&amp;s10[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; "nullptr is:" &lt;&lt; atoi_(nullptr) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是那四个点</p>
<p><strong>nullptr</strong> <strong>正负号</strong> <strong>非法字符</strong> <strong>溢出</strong></p>
<h4 id="举一反三-4"><a href="#举一反三-4" class="headerlink" title="举一反三"></a>举一反三</h4><ol>
<li>实现string到double的转换</li>
</ol>
<p>分析：此题虽然类似于atoi函数，但毕竟double为64位，而且支持小数，因而<strong>边界条件更加严格，写代码时需要更加注意</strong>。</p>
<h3 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a>回文判断</h3><p><strong>题目描述</strong></p>
<p>回文，英文palindrome，指一个<font color="blue">顺着读和反过来读都一样的字符串</font>，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。</p>
<p>那么，我们的<font color="blue">第一个问题就是：判断一个字串是否是回文？</font></p>
<p>有两种：</p>
<p>解法一：从首尾开始 向中间靠拢，依次判断两指针指向元素是否相等</p>
<p>解法二：从中间开始，向首尾扩散，依次判断两指针指向元素是否相等</p>
<p>虽然解法二的时空复杂度和解法一是一样的，但<font color="blue">很快我们会看到，在某些回文问题里面，这个方法二有着自己的独到之处</font>，可以方便的解决一类问题。</p>
<p><strong>举一反三</strong></p>
<p>1、判断<font color="blue">一条单向链表</font>是不是“回文”</p>
<p>分析：对于单链表结构，可以用两个指针从两端或者中间遍历并判断对应字符是否相等。但这里的关键就是如何朝两个方向遍历。由于单链表是单向的，所以要<font color="blue">向两个方向遍历</font>的话，可以<font color="blue">采取经典的快慢指针</font>的方法，即<font color="blue">先位移到链表的中间位置</font>，再将<font color="blue">链表的后半逆置，最后用两个指针同时从链表头部和中间开始同时遍历并比较即可。</font></p>
<p>2、判断<font color="blue">一个栈</font>是不是“回文”</p>
<p>分析：对于栈的话，只需要将字符串全部压入栈，然后依次将各字符<font color="blue">出栈</font>，这样得到的就是<font color="blue">原字符串的逆置串</font>，分别和原字符串各个字符比较，就可以判断了。<strong>逆置串和原串相等，就是回文，这是等价的</strong></p>
<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>[Manacher算法][<a href="https://segmentfault.com/a/1190000003914228]" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003914228]</a></p>
<h3 id="字符串的全排列"><a href="#字符串的全排列" class="headerlink" title="字符串的全排列"></a>字符串的全排列</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个字符串，打印出该字符串中<font color="blue">字符的所有排列</font>。</p>
<p>例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串</p>
<p>abc、acb、bac、bca、cab 和 cba。</p>
<h4 id="分析与解法-3"><a href="#分析与解法-3" class="headerlink" title="分析与解法"></a>分析与解法</h4><p><strong>解法一 递归实现</strong></p>
<p>从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列。以对字符串abc进行全排列为例，我们可以这么做：以abc为例</p>
<ul>
<li>固定a，求后面bc的排列：abc，acb，求好后，a和b交换，得到bac</li>
<li>固定b，求后面ac的排列：bac，bca，求好后，c放到第一位置，得到cba</li>
<li>固定c，求后面ba的排列：cba，cab。</li>
</ul>
<p><font color="blue">通过交换完成全排列</font></p>
<p><strong><font color="blue">for 循环第二三步 千万不要写反了</font></strong></p>
<p>代码（自己写的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PermutationCore</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=end;i++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;=end;i++)&#123;</span><br><span class="line">    		swap(str[i],str[start]);</span><br><span class="line">    		PermutationCore(str, start+<span class="number">1</span>, end);</span><br><span class="line">    		swap(str[i],str[start]);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = str.size();</span><br><span class="line">	PermutationCore(str,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//	string s2 = "dfaosdgfa";</span></span><br><span class="line"></span><br><span class="line">	Permutation(s1);</span><br><span class="line"><span class="comment">//	Permutation(s2);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二 字典序排列</strong></p>
<p><strong>什么是字典序</strong></p>
<p>维基百科的定义：给定两个偏序集A和B,(a,b)和(a′,b′)属于笛卡尔集 A × B，则<font color="blue">字典序定义为:</font></p>
<p><font color="blue">(a,b) ≤ (a′,b′) 当且仅当 a &lt; a′ 或 (a = a′ 且 b ≤ b′)</font>。</p>
<p>所以给定两个字符串，逐个字符比较，那么<strong><font color="blue">先出现较小字符</font></strong>的那个串字典顺序小，如果字符一直相等，较短的串字典顺序小。例如：abc &lt; abcd &lt; abde &lt; afab。</p>
<p>那有没有这样的算法，使得</p>
<ul>
<li><strong>起点</strong>： 字典序最小的排列, 1-n , 例如12345</li>
<li><strong>终点</strong>： 字典序最大的排列，n-1, 例如54321</li>
<li><strong>过程</strong>： 从当前排列生成字典序刚好比它大的下一个排列</li>
</ul>
<p>答案是肯定的：有，即是<font color="blue">STL中的next_permutation</font>算法。</p>
<p>先分析下<font color="blue">下一个排列的性质</font></p>
<ul>
<li>假定现有字符串(A)x(B)，它的下一个排列是：(A)y(B’)，其中A、B和B’是“字符串”(可能为空），x和y是“字符”，前缀相同，都是A，且一定有y &gt; x。</li>
<li>那么，为使下一个排列字典顺序尽可能小，必有：<ul>
<li>A尽可能长</li>
<li>y尽可能小</li>
<li>B’里的字符按由小到大递增排列</li>
</ul>
</li>
</ul>
<p>现在的问题是：找到x和y。怎么找到呢？咱们来看一个例子。</p>
<p>比如说，现在我们要找<font color="blue">21543的下一个排列</font>，我们可以从左至右逐个扫描每个数，看哪个能增大（至于<font color="blue">如何判定能增大，是根据如果一个数右面有比它大的数存在，那么这个数就能增大）</font>，我们可以看到<strong>最后一个能增大的数</strong>是：x = 1。</p>
<p>而1<font color="blue">应该增大到多少？</font>1能增大到<font color="blue">它右面比它大的那一系列数中最小的那个数</font>，即：y = 3，故此时21543的下一个排列应该变为23xxx，显然 xxx(对应之前的B’）应由小到大排，于是我们最终找到比“21543”大，但字典顺序尽量小的23145，找到的23145刚好比21543大。</p>
<p>由这个例子可以得出next_permutation算法流程为：</p>
<p><strong>next_permutation算法</strong></p>
<ul>
<li><p>定义</p>
<ul>
<li>升序：相邻两个位置a<sub>i</sub> &lt; a<sub>i+1</sub>，ai 称作该升序的首位</li>
</ul>
</li>
<li><p>步骤（<strong>二找、一交换、一翻转</strong>）</p>
<ol>
<li><p>找到排列中最后（最右）一个升序的首位位置i，x = ai</p>
<p>*<font color="blue">ps：最后一个升序，说明后面都是降序排列</font>*</p>
</li>
<li><p>找到排列中<font color="blue">第i位右边最后一个比ai 大的位置j</font>，y = aj</p>
</li>
<li><p>交换x，y</p>
</li>
<li><p>把第(i+ 1)位到最后的部分翻转</p>
<p>*<font color="blue">ps：i+1位到最后都是降序，反转后是升序，是最小的情况</font>*</p>
</li>
</ol>
</li>
</ul>
<p>我们现在<strong>使用next_permutation算法</strong></p>
<p>这里我们需要<strong>保存当前的一个排列</strong>，<strong>要么更改原有字符串</strong>，<strong>要么额外开辟O(n)空间</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>&amp; a, <span class="keyword">char</span>&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="keyword">int</span> indexOfLastAscend, <span class="keyword">int</span> indexOfFirstLess)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = indexOfLastAscend; i&lt;=(indexOfFirstLess+indexOfLastAscend)/<span class="number">2</span>;i++)</span><br><span class="line">		swap(s1[i], s1[indexOfFirstLess+indexOfLastAscend-i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasNextPermutation</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="keyword">int</span>&amp; length)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> indexOfLastAscend = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> indexOfFirstLess = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[i]&gt;s1[i<span class="number">-1</span>])&#123;</span><br><span class="line">			indexOfLastAscend = i<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; "indexOfLastAscend is:" &lt;&lt;  indexOfLastAscend &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">if</span>(indexOfLastAscend==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = length<span class="number">-1</span>;j&gt;=indexOfLastAscend;j--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s1[j]&gt;s1[indexOfLastAscend])&#123;</span><br><span class="line">			indexOfFirstLess = j;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; "indexOfFirstLess is:" &lt;&lt; indexOfFirstLess &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">if</span>(indexOfFirstLess==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	swap(s1[indexOfLastAscend],s1[indexOfFirstLess]);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; s1 &lt;&lt; endl;</span></span><br><span class="line">	Reverse(s1, indexOfLastAscend+<span class="number">1</span>, length<span class="number">-1</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; s1 &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">string</span>&amp; s1)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = s1.size();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span>(hasNextPermutation(s1,length))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> s1 = <span class="string">"abc"</span>; <span class="comment">// we use original sort here; so we will change s1 or you can create a copy of s1</span></span><br><span class="line">	<span class="built_in">string</span> s2 = <span class="string">"1234"</span>;</span><br><span class="line">	Permutation(s1);</span><br><span class="line">	Permutation(s2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法总结"><a href="#解法总结" class="headerlink" title="解法总结"></a>解法总结</h4><p>由于全排列总共有n!种排列情况，所以不论解法一中的递归方法，还是上述解法二的字典序排列方法，这<strong>两种方法的时间复杂度都为O(n!)</strong>。</p>
<h4 id="类似问题"><a href="#类似问题" class="headerlink" title="类似问题"></a>类似问题</h4><p>1、已知字符串里的字符<strong>是互不相同</strong>的，现在任意组合，比如ab，则输出aa，ab，ba，bb，编程按照字典序输出所有的组合。</p>
<p>分析：非简单的全排列问题（跟全排列的形式不同,abc全排列的话，只有6个不同的输出）。 本题可用递归的思想，<strong>设置一个变量表示已输出的个数，然后当个数达到字符串长度时，就输出</strong>。</p>
<p>首先，输出个数是长度的长度次方（上面说了互不相同，所以没有重复的可能性）</p>
<p>每次递归都是在字符串末尾+（所有字符中的一个，用for循环），然后递归，一个计数变量判断是否到达长度，达到就输出</p>
<p>类似于一个度为长度，深度为1+长度的树，然后我我们到子结点就输出字符串</p>
<p>2、如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？当输入的字符串中含有相同的字符串时，相同的字符交换位置是不同的排列，但是同一个组合。举个例子，如果输入abc，它的组合有a、b、c、ab、ac、bc、abc。</p>
<p>两层循环，第一层固定住前k个字符</p>
<p>第二层，从剩下的n-k字符中挑选出来apped到第k+1个字符上</p>
<p>O(n^2)：因为一共有这么多种组合</p>
<p>3、写一个程序，打印出以下的序列。</p>
<p>(a),(b),(c),(d),(e)……..(z)</p>
<p>(a,b),(a,c),(a,d),(a,e)……(a,z),(b,c),(b,d)…..(b,z),(c,d)…..(y,z)</p>
<p>(a,b,c),(a,b,d)….(a,b,z),(a,c,d)….(x,y,z)</p>
<p>….</p>
<p>(a,b,c,d,…..x,y,z)</p>
<p><strong>思路同第2题</strong></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>笔试和面试中，除了字符串，另一类出现频率极高的问题便是与数组相关的问题。在阅读完第1章和本第二章后，读者会慢慢了解到解决面试编程题的有几种常用思路。首先一般考虑<strong>“万能的”暴力穷举（递归、回溯）</strong>，如求n个数的全排列或八皇后（N皇后问题）。但因为穷举时间复杂度通常过高，所以<strong>需要考虑更好的方法</strong>，如<strong>分治法（通过分而治之，然后归并），以及空间换时间（如活用哈希表）</strong>。</p>
<p>此外，选择<strong>合适的数据结构</strong>可以显著提升效率，如寻找最小的k个数中，用<strong>堆</strong>代替数组。</p>
<p>再有，如果题目允许排序，则可以考虑排序。比如，寻找和为定值的两个数中，先排序，然后用前后两个指针往中间扫。而如果如果已经排好序了（如杨氏矩阵查找中），则想想有无必要二分。但是，如果题目不允许排序呢？这个时候，我们可以考虑不改变数列顺序的贪心算法（如最小生成树Prim、Kruskal及最短路dijkstra），或动态规划（如 01背包问题，每一步都在决策）。</p>
<p>最后，注意细节处理，不要忽略边界条件，如字符串转换成整数。</p>
<h3 id="寻找最小的k个数"><a href="#寻找最小的k个数" class="headerlink" title="寻找最小的k个数"></a>寻找最小的k个数</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入n个整数 输出最小的k个</p>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>要求一个序列中最小的k个数，按照惯有的思维方式，则是先对这个序列从小到大排序，然后输出前面的最小的k个数。</p>
<p>至于选取什么的排序方法，我想你可能会第一时间想到快速排序（我们知道，快速排序平均所费时间为<code>n\*logn</code>），然后再遍历序列中前k个元素输出即可。因此，总的时间复杂度：<code>O（n * log n)+O(k)=O（n * log n）</code>。</p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>咱们再进一步想想，题目没有要求最小的k个数有序，也没要求最后n-k个数有序。既然如此，就<font color="blue">没有必要对所有元素进行排序</font>。这时，咱们想到了用选择或交换排序，即：</p>
<p>1、遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；<br>2、对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为<code>O（k）</code>）；<br>3、继续遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果<code>x &lt; kmax</code> ，用x替换kmax，并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果<code>x &gt;= kmax</code>，则继续遍历不更新数组。</p>
<p>每次遍历，更新或不更新数组的所用的时间为<code>O（k）</code>或<code>O（0）</code>。故整趟下来，时间复杂度为<code>n\*O（k）=O（n\*k）</code>。</p>
<h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似：()</p>
<p><font color="blue">解法二是维护topk的数组，解法三是维护topk的堆</font></p>
<ul>
<li>1、用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；</li>
<li>2、堆中元素是有序的，令k1&lt;k2&lt;…&lt;kmax（kmax设为最大堆中的最大元素）</li>
<li>3、遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：如果<code>x &lt; kmax</code>，用x替换kmax，然后更新堆（用时logk）；否则不更新堆。</li>
</ul>
<p>这样下来，总的时间复杂度:<code>O（k+（n-k）\*logk）=O（n\*logk）</code>——<font color="blue">O(n*lgk)</font>。此方法得益于堆中进行查找和更新的时间复杂度均为：<code>O(logk)</code>（若使用解法二：在数组中找出最大元素，时间复杂度：<code>O（k））</code>。</p>
<h3 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h3><p>在《数据结构与算法分析–c语言描述》一书，第7章第7.7.6节中，阐述了一种在平均情况下，时间复杂度为<code>O（N）</code>的快速选择算法。如下述文字：</p>
<ul>
<li>选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样<ul>
<li>如果k &lt;= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。</li>
<li>如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。</li>
<li>否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。</li>
</ul>
</li>
</ul>
<p><strong>此算法的平均运行时间为O(n)。</strong>——<font color="blue">这部分需要证明</font></p>
<p>在《数据结构与算法分析–c语言描述》一书，第7章第7.7.6节中，阐述了一种在平均情况下，时间复杂度为<code>O（N）</code>的快速选择算法。如下述文字：</p>
<p>+</p>
<ul>
<li>选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样<ul>
<li>如果k &lt;= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。</li>
<li>如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。</li>
<li>否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。</li>
</ul>
</li>
</ul>
<p>此算法的平均运行时间为O(n)。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//QuickSelect 将第k小的元素放在 a[k-1]  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSelect</span><span class="params">( <span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> left, <span class="keyword">int</span> right )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( left + cutoff &lt;= right )</span><br><span class="line">    &#123;</span><br><span class="line">        pivot = median3( a, left, right );</span><br><span class="line">        <span class="comment">//取三数中值作为枢纽元，可以很大程度上避免最坏情况</span></span><br><span class="line">        i = left; j = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; ; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( a[ ++i ] &lt; pivot )&#123; &#125;</span><br><span class="line">            <span class="keyword">while</span>( a[ --j ] &gt; pivot )&#123; &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &lt; j )</span><br><span class="line">                swap( &amp;a[ i ], &amp;a[ j ] );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置枢纽元</span></span><br><span class="line">        swap( &amp;a[ i ], &amp;a[ right - <span class="number">1</span> ] );  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( k &lt;= i )</span><br><span class="line">            QuickSelect( a, k, left, i - <span class="number">1</span> );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( k &gt; i + <span class="number">1</span> )</span><br><span class="line">            QuickSelect( a, k, i + <span class="number">1</span>, right );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        InsertSort( a + left, right - left + <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个快速选择SELECT算法，类似快速排序的划分方法。N个数存储在数组S中，再从数组中选取“中位数的中位数”作为枢纽元X，把数组划分为Sa和Sb俩部分，Sa&lt;=X&lt;=Sb，如果要查找的k个元素小于Sa的元素个数，则返回Sa中较小的k个元素，否则返回Sa中所有元素+Sb中小的k-|Sa|个元素，这种解法在平均情况下能做到<code>O(n)</code>的复杂度。</p>
<p>更进一步，《算法导论》第9章第9.3节介绍了一个最坏情况下亦为O(n)时间的SELECT算法，有兴趣的读者可以参看。</p>
<h4 id="举一反三-5"><a href="#举一反三-5" class="headerlink" title="举一反三"></a>举一反三</h4><p>1、谷歌面试题：输入是两个整数数组，他们任意两个数的和又可以组成一个数组，求这个和中前k个数怎么做？</p>
<p>分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">“假设两个整数数组为A和B，各有N个元素，任意两个数的和组成的数组C有N^2个元素。</span><br><span class="line">  那么可以把这些和看成N个有序数列：</span><br><span class="line">         A[1]+B[1] &lt;= A[1]+B[2] &lt;= A[1]+B[3] &lt;=…</span><br><span class="line">         A[2]+B[1] &lt;= A[2]+B[2] &lt;= A[2]+B[3] &lt;=…</span><br><span class="line">         …</span><br><span class="line">        A[N]+B[1] &lt;= A[N]+B[2] &lt;= A[N]+B[3] &lt;=…</span><br><span class="line">   问题转变成，在这N^2个有序数列里，找到前k小的元素”</span><br></pre></td></tr></table></figure>

<p>需要n个指针，每次对n个比较（不需要排序，只需要找最小值），然后最小值的那个指针向后移动，然后重复上述操作k次，即找到MinK</p>
<p>2、有两个序列A和B,A=(a1,a2,…,ak),B=(b1,b2,…,bk)，A和B都按升序排列。对于1&lt;=i,j&lt;=k，求k个最小的（ai+bj）。要求算法尽量高效。</p>
<p>3、给定一个数列a1,a2,a3,…,an和m个三元组表示的查询，对于每个查询(i，j，k)，输出ai，ai+1，…，aj的升序排列中第k个数。</p>
<h3 id="寻找和为定值的两个数"><a href="#寻找和为定值的两个数" class="headerlink" title="寻找和为定值的两个数"></a>寻找和为定值的两个数</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。</p>
<p>要求时间复杂度是O(N)。如果有多对数字的和等于输入的数字，<font color="blue">输出任意一对即可</font>。</p>
<p>例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11。</p>
<h4 id="分析与解法-4"><a href="#分析与解法-4" class="headerlink" title="分析与解法"></a>分析与解法</h4><p>咱们试着一步一步解决这个问题（注意阐述中数列有序无序的区别）：</p>
<p>直接穷举，从数组中任意选取两个数，判定它们的和是否为输入的那个数字。此举复杂度为O(N^2)。很显然，我们要寻找效率更高的解法</p>
<p>题目相当于，对每个a[i]，查找sum-a[i]是否也在原始序列中，每一次要查找的时间都要花费为O(N)，这样下来，最终找到两个数还是需要O（N^2）的复杂度。那如何提高查找判断的速度呢？</p>
<p>答案是<strong>二分查找</strong>，可以<strong>将O(N)的查找时间提高到O(log N)</strong>，这样对于<strong>N个a[i]，都要花logN的时间去查找相对应的sum-a[i]是否在原始序列中</strong>，总的时间复杂度已降为O(N log N)，且空间复杂度为O(1)。 （如果有序，直接二分O(N log N)，如果无序，先排序后二分，复杂度同样为O（N log N + N log N）= O(N log N)，空间复杂度总为O(1)）。</p>
<p>可以继续优化做到时间O(N)么</p>
<p><font color="blue">注意 二分查找可以将O(N) 变O(lgN)——常规思路</font></p>
<h4 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h4><p>根据前面的分析，a[i]在序列中，如果a[i]+a[k]=sum的话，那么sum-a[i]（a[k])也必然在序列中。 举个例子，如下： 原始序列：</p>
<ul>
<li>1、 2、 4、 7、11、15</li>
</ul>
<p>用输入数字15减一下各个数，得到对应的序列为：</p>
<ul>
<li>14、13、11、8、4、 0</li>
</ul>
<p>第一个数组以一指针i 从数组最左端开始向右扫描，第二个数组以一指针j 从数组最右端开始向左扫描，如果第一个数组出现了和第二个数组一样的数，即<code>a[*i]=a[*j]</code>，就找出这俩个数来了。 如上，i，j最终在第一个，和第二个序列中找到了相同的数4和11，所以符合条件的两个数，即为4+11=15。 怎么样，两端同时查找，时间复杂度瞬间缩短到了O(N)，但却同时需要O(N)的空间存储第二个数组。</p>
<p><font color="blue">两端如何同时查找是O(N)??</font></p>
<h4 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h4><p>当题目对时间复杂度要求比较严格时，我们可以考虑下用空间换时间，上述解法一即是此思想，此外，构造hash表也是典型的用空间换时间的处理办法。</p>
<p>即给定一个数字，根据hash映射查找另一个数字是否也在数组中，只需用O(1)的时间，前提是经过O(N)时间的预处理，和用O(N)的空间构造hash表。</p>
<p>但能否做到在时间复杂度为O(N)的情况下，空间复杂度能进一步降低达到O(1)呢？</p>
<p><font color="blue">用哈希表确实可以查找是O(N)</font></p>
<h4 id="解法三-1"><a href="#解法三-1" class="headerlink" title="解法三"></a>解法三</h4><p>如果数组是无序的，先排序(N log N)，然后用两个指针<font color="blue">i，j，各自指向数组的首尾两端</font>，令i=0，j=n-1，然后i++，j–，逐次判断a[i]+a[j]?=sum，</p>
<ul>
<li>如果某一刻a[i]+a[j] &gt; sum，则要想办法让sum的值减小，所以此刻i不动，j–；</li>
<li>如果某一刻a[i]+a[j] &lt; sum，则要想办法让sum的值增大，所以此刻i++，j不动。</li>
</ul>
<p>所以，数组无序的时候，时间复杂度最终为O(N log N + N)=O(N log N)。</p>
<p>如果<strong>原数组是有序</strong>的，则不需要事先的排序，直接用两指针分别从头和尾向中间扫描，<strong>O(N)搞定，且空间复杂度还是O(1)</strong>。</p>
<p>下面，咱们先来实现此思路（这里假定数组已经是有序的），代码可以如下编写：</p>
<h4 id="解法总结-1"><a href="#解法总结-1" class="headerlink" title="解法总结"></a>解法总结</h4><p>不论原序列是有序还是无序，解决这类题有以下三种办法：</p>
<ul>
<li>1、<strong><font color="blue">二分</font></strong>（<strong>若无序，先排序后二分</strong>），时间复杂度总为O(N log N)，空间复杂度为O（1）；</li>
<li>2、扫描一遍X-S[i] 映射到一个数组或构造<font color="blue">hash表</font>，时间复杂度为O(N)，空间复杂度为O(N)；</li>
<li>3、<font color="blue">两个指针两端扫描</font>（若无序，先排序后扫描），时间复杂度最后为：有序O(N)，无序O(N log N + N)=O(N log N)，空间复杂度都为O(1)。</li>
</ul>
<p>所以，要想达到时间O(N)，空间O(1)的目标，除非原数组是有序的（指针扫描法），不然，当数组无序的话，就只能先排序，后指针扫描法或二分（时间 O(Nlog N)，空间O(1)），或映射或hash（时间O(N)，空间O(N)）。时间或空间，必须牺牲一个，达到平衡。</p>
<p>综上，若是数组有序的情况下，优先考虑两个指针两端扫描法，以达到最佳的时O(N)，空O(1)效应。否则，如果要排序的话，时间复杂度最快当然是只能达到O(N log N)，空间O(1)则不在话下。</p>
<h4 id="问题扩展-1"><a href="#问题扩展-1" class="headerlink" title="问题扩展"></a>问题扩展</h4><ol>
<li>如果在返回找到的两个数的同时，还要求你返回这两个数的位置列？</li>
<li>如果需要输出所有满足条件的整数对呢?</li>
<li>如果把题目中的要你寻找的两个数改为“多个数”，或任意个数列?</li>
</ol>
<h4 id="举一反三-6"><a href="#举一反三-6" class="headerlink" title="举一反三"></a>举一反三</h4><p>1、在二元树中<font color="blue">找出和为某一值的所有路径</font> 输入一个整数和一棵二元树，从树的根结点开始往下访问一直到叶结点所经过的所有结点形成一条路径，然后打印出和与输入整数相等的所有路径。 例如输入整数22和如下二元树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<p>/ <br>5 12<br>/ <br>4 7</p>
<p>则打印出两条路径：10, 12和10, 5, 7。 其中，二元树节点的数据结构定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct BinaryTreeNode // a node in the binary tree</span><br><span class="line">&#123;</span><br><span class="line">    int m_nValue; // value of node</span><br><span class="line">    BinaryTreeNode *m_pLeft; // left child of node</span><br><span class="line">    BinaryTreeNode *m_pRight; // right child of node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、有一个数组a，设有一个值n。在数组中找到两个元素a[i]和a[j]，使得a[i]+a[j]等于n，求出所有满足以上条件的i和j。</p>
<p>3、3-sum问题</p>
<p>给定一个整数数组，判断能否从中找出<font color="blue">3个数a、b、c，使得他们的和为0</font>，如果能，请找出所有满足和为0个3个数对。</p>
<p>4、4-sum问题</p>
<p>给定一个整数数组，判断能否从中找出<font color="blue">4个数a、b、c、d，使得他们的和为0</font>，如果能，请找出所有满足和为0个4个数对。</p>
<h3 id="寻找和为定值的多个数"><a href="#寻找和为定值的多个数" class="headerlink" title="寻找和为定值的多个数"></a>寻找和为定值的多个数</h3><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数n和sum，从数列1，2，3…….n 中<font color="blue">随意取几个数，使其和等于sum</font>，要求将<font color="blue">其中所有的可能组合列出来</font>。</p>
<p>注意到取n，和不取n个区别即可，考虑<font color="blue">是否取第n个数的策略，可以转化为一个只和前n-1个数相关的问题</font>。</p>
<ul>
<li>如果取第n个数，那么问题就转化为“取前n-1个数使得它们的和为sum-n”，对应的代码语句就是sumOfkNumber(sum - n, n - 1)；</li>
<li>如果不取第n个数，那么问题就转化为“取前n-1个数使得他们的和为sum”，对应的代码语句为sumOfkNumber(sum, n - 1)</li>
</ul>
<p>形成<strong>递推式</strong></p>
<p>代码（自己写的）</p>
<p>特别注意：<font color="blue">list数据结构是没有下标操作的</font></p>
<p><font color="blue">所以我们取值要使用迭代器</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sumOfkNumber</span><span class="params">(<span class="keyword">int</span> sum , <span class="keyword">int</span> K, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; list1)</span></span>&#123;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; "sum is:" &lt;&lt;sum &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; "K is:" &lt;&lt; K &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">if</span>(sum&lt;=<span class="number">0</span> || K&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(sum==K)&#123;</span><br><span class="line">		list1.reverse();<span class="comment">// reverse here is to get a reverse sort (or descend sort) rather than reverse the number!!!</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = list1.begin();iter!=list1.end();iter++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; K &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		list1.reverse();</span><br><span class="line">	&#125;</span><br><span class="line">	list1.push_front(K);</span><br><span class="line">	sumOfkNumber(sum-K, K<span class="number">-1</span>, list1);</span><br><span class="line">	list1.pop_front();</span><br><span class="line">	sumOfkNumber(sum, K<span class="number">-1</span>, list1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> K = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1;</span><br><span class="line">	sumOfkNumber(sum, K, list1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二-没懂-有时间再看"><a href="#解法二-没懂-有时间再看" class="headerlink" title="解法二 没懂 有时间再看"></a>解法二 没懂 有时间再看</h4><p>这个问题<font color="blue">属于子集和问题（也是背包问题）</font>。本程序采用回溯法+剪枝，其中X数组是解向量，t=∑(1,..,k-1)Wi*Xi, r=∑(k,..,n)Wi，且</p>
<ul>
<li>若t+Wk+W(k+1)&lt;=M,则Xk=true，递归左儿子(X1,X2,..,X(k-1),1)；否则剪枝；</li>
<li>若t+r-Wk&gt;=M &amp;&amp; t+W(k+1)&lt;=M,则置Xk=0，递归右儿子(X1,X2,..,X(k-1),0)；否则剪枝；</li>
</ul>
<p>本题中W数组就是(1,2,..,n),所以直接用k代替WK值。</p>
<p>代码编写如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入t， r， 尝试Wk</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SumOfkNumber</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> k, <span class="keyword">int</span> r, <span class="keyword">int</span>&amp; M, <span class="keyword">bool</span>&amp; flag, <span class="keyword">bool</span>* X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X[k] = <span class="literal">true</span>;   <span class="comment">// 选第k个数</span></span><br><span class="line">    <span class="keyword">if</span> (t + k == M) <span class="comment">// 若找到一个和为M，则设置解向量的标志位，输出解</span></span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X[i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 若第k+1个数满足条件，则递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> (t + k + (k + <span class="number">1</span>) &lt;= M)</span><br><span class="line">        &#123;</span><br><span class="line">            SumOfkNumber(t + k, k + <span class="number">1</span>, r - k, M, flag, X);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若不选第k个数，选第k+1个数满足条件，则递归右子树</span></span><br><span class="line">        <span class="keyword">if</span> ((t + r - k &gt;= M) &amp;&amp; (t + (k + <span class="number">1</span>) &lt;= M))</span><br><span class="line">        &#123;</span><br><span class="line">            X[k] = <span class="literal">false</span>;</span><br><span class="line">            SumOfkNumber(t, k + <span class="number">1</span>, r - k, M, flag, X);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>&amp; N, <span class="keyword">int</span>&amp; M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化解空间</span></span><br><span class="line">    <span class="keyword">bool</span>* X = (<span class="keyword">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)* (N + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(X, <span class="literal">false</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>)* (N + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> sum = (N + <span class="number">1</span>) * N * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt; M || sum &lt; M) <span class="comment">// 预先排除无解情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not found\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">    SumOfkNumber(<span class="number">0</span>, <span class="number">1</span>, sum, M, f, X);</span><br><span class="line">    <span class="keyword">if</span> (!f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"not found\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="0-1-背包问题（背景介绍）"><a href="#0-1-背包问题（背景介绍）" class="headerlink" title="0-1 背包问题（背景介绍）"></a>0-1 背包问题（背景介绍）</h4><p>0-1背包问题是<font color="blue">最基础的背包问题</font>，其具体描述为：有N件物品和一个容量为V的背包。放入第i件物品耗费的<font color="blue">容量是Ci，得到的价值是Wi</font>。求解将哪些物品装入背包可使<font color="blue">价值总和最大</font>。</p>
<p>简单分析下：这是最基础的背包问题，特点是每种物品仅有一件，可以选择放或不放。用<strong><font color="blue">子问题定义状态</font></strong>：即<font color="blue">F[i, v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值</font>。则其状态转移方程便是：</p>
<ul>
<li>F[i, v] = max{F[i-1, v], F[i-1, v-Ci ] + Wi}</li>
</ul>
<p>根据前面的分析，我们不难理解这个方程的意义：“将前i件物品放入容量为v的背包中”这个子问题，若只<strong>考虑第i件物品的策略（放或不放），那么就可以转化为一个只和前 i-1 件物品相关的问题</strong>。即：</p>
<ul>
<li>如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为 F[i-1, v ]；</li>
<li>如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-Ci的背包中”，此时能获得的最大价值就是F[i-1, v-Ci]再加上通过放入第i件物品获得的价值Wi。</li>
</ul>
<p>这段代码的时间和空间复杂度均为 O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O(V)。感兴趣的读者可以继续思考或者参考网上一个不错的文档<font color="blue">《背包问题九讲》</font>。</p>
<h4 id="举一反三-7"><a href="#举一反三-7" class="headerlink" title="举一反三"></a>举一反三</h4><p>1、《挑战程序设计竞赛》的开篇有个类似的抽签问题，挺有意思，题目如下：</p>
<p>将写有数字的n个纸片放入一个纸箱子中，然后你和你的朋友从纸箱子中抽取4张纸片，每次记下纸片上的数字后放回子箱子中，如果这4个数字的和是m，代表你赢，否则就是你的朋友赢。</p>
<p>请编写一个程序，当纸片上所写的数字是k1，k2，k3，k4，..，kn时，是否存在抽取4次和为m的方案，如果存在，输出YES；否则，输出NO。</p>
<p>限制条件：</p>
<ul>
<li>1 &lt;= n &lt;= 50</li>
<li>1 &lt;= m &lt;= 10^8</li>
<li>1 &lt;= ki &lt;= 10^8</li>
</ul>
<p>分析：最容易想到的方案是用4个for循环直接穷举所有方案，时间复杂度为O（N^4）,主体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过4重for循环枚举所有方案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n, a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; n; b++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; n; d++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k[a] + k[b] + k[c] + k[d] == m)</span><br><span class="line">                &#123;</span><br><span class="line">                    f = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果当n远大于50时，则程序会显得非常吃力，如此，我们需要找到更好的办法。</p>
<p>提供两个思路：</p>
<p>①最内侧关于d的循环所做的事情：检查是否有d满足ka+ kb +kc + kd = m，移动下式子，等价于：检查是否有d使得kd = m - ka - kb - kc，也就是说，只要检查k中所有元素，判断是否有等于m-ka-kb-ka 的元素即可。设m-ka-kb-ka = x，接下来，就是要看x是否存在于数组k中，此时，可以先把数组k排序，然后利用二分查找在数组k中找x；</p>
<p>②进一步，内侧的两个循环所做的事情：检查是否有c和d满足kc + kd = m - ka -kb。同样，可以预先枚举出kc+kd所得的n^2数字并排好序，便可以利用二分搜索继续求解。</p>
<p>2、给定整数a1、a2、a3、…、an，判断是否可以从中选出若干个数，使得它们的和等于k（k任意给定，且满足-10^8 &lt;= k &lt;= 10^8）。</p>
<p>分析：此题<strong>相对于本节“寻找满足条件的多个数”如出一辙，不同的是此题只要求判断，不要求把所有可能的组合给输出来</strong>。因为此题需要考虑到加上a[i]和不加上a[i]的情况，故<strong>可以采用深度优先搜索的办法，递归解决</strong>。</p>
<p>3、有n个数，输出期中所有和为s的k个数的组合。</p>
<p>分析：此题有两个坑，<font color="blue">一是这里的n个数是任意给定的</font>，不一定是：1,2,3…n，所以<font color="blue">可能有重复的数（如果有重复的数怎么处理？）</font>；二是<font color="blue">不要求你输出所有和为s的全部组合</font>，而<font color="blue">只要求输出和为s的k个数的组合</font>。</p>
<p>举个例子，假定n=6，这6个数为：1 2 1 3 0 1，如果要求输出和为3的全部组合的话，</p>
<ul>
<li>1 2</li>
<li>1 2 0</li>
<li>0 3</li>
<li>1 1 1</li>
<li>1 1 1 0</li>
</ul>
<p>而题目加了个限制条件，若令k=2，则只要求输出：[{1,2}, {0,3}] 即可。</p>
<h3 id="最大连续子数组和"><a href="#最大连续子数组和" class="headerlink" title="最大连续子数组和"></a>最大连续子数组和</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整形数组，数组里<font color="blue">有正数也有负数</font>。数组中<font color="blue">连续的一个或多个整数组成一个子数组</font>，每个子数组都有一个和。 求所有子数组的和的最大值，要求<strong>时间复杂度为O(n)</strong>。</p>
<p>例如输入的数组为<code>1, -2, 3, 10, -4, 7, 2, -5</code>，和最大的子数组为<code>3, 10, -4, 7, 2</code>， 因此输出为该子数组的和18。</p>
<h4 id="解法一-2"><a href="#解法一-2" class="headerlink" title="解法一"></a>解法一</h4><p>暴力解法。。</p>
<h4 id="解法二-2"><a href="#解法二-2" class="headerlink" title="解法二"></a>解法二</h4><p><strong><font color="blue">关键还是找到状态转移</font></strong></p>
<p>事实上，当我们令currSum为当前最大子数组的和，maxSum为最后要返回的最大子数组的和，当我们往后扫描时，</p>
<ul>
<li>对第j+1个元素有两种选择：<strong><font color="blue">要么放入前面找到的子数组，要么做为新子数组的第一个元素</font></strong>；<ul>
<li>如果<font color="blue">currSum加上当前元素a[j]后不小于a[j]</font>，则令currSum加上a[j]，否则currSum重新赋值，置为下一个元素，即currSum = a[j]。</li>
</ul>
</li>
<li>同时，当currSum &gt; maxSum，则更新maxSum = currSum，否则保持原值，不更新。</li>
</ul>
<p>即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currSum = max(a[j], currSum + a[j])</span><br><span class="line">maxSum = max(maxSum, currSum)</span><br></pre></td></tr></table></figure>

<p><font color="blue">代码，（自己写的）</font></p>
<p><strong>注意：maxSum的初始值和currSum的初始值的不同</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s1)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = s1[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = s1.begin();iter!=s1.end();iter++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*iter&gt;result)</span><br><span class="line">			result = *iter;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxSumSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; array1)</span></span>&#123;</span><br><span class="line">	<span class="comment">//int maxSum = max_(array1);</span></span><br><span class="line">	<span class="keyword">int</span> maxSum = array1[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> currSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array1.size();i++)&#123;</span><br><span class="line">		currSum = array1[i]&gt;array1[i]+currSum?array1[i]:array1[i]+currSum;</span><br><span class="line">		maxSum = currSum&gt;maxSum?currSum:maxSum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array1&#123;<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">-4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">-5</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array2&#123;<span class="number">-9</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-1</span>,<span class="number">-1000</span>,<span class="number">-9</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> maxSum = getMaxSumSubArray(array1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Max sum of sub array is :"</span> &lt;&lt; maxSum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	maxSum = getMaxSumSubArray(array2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Max sum of sub  array2 is:"</span> &lt;&lt; maxSum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题扩展-2"><a href="#问题扩展-2" class="headerlink" title="问题扩展"></a>问题扩展</h4><ol>
<li>如果数组是二维数组，同样要你求最大子数组的和列?</li>
<li>如果是要你求子数组的最大乘积列?</li>
<li>如果同时要求输出子段的开始和结束列?</li>
</ol>
<h4 id="举一反三-8"><a href="#举一反三-8" class="headerlink" title="举一反三"></a>举一反三</h4><p>1 给定整型数组，其中每个元素表示木板的高度，木板的宽度都相同，求这些木板拼出的最大矩形的面积。并分析时间复杂度。</p>
<p>此题类似leetcode里面关于连通器的题，需要明确的是高度可能为0，长度最长的矩形并不一定是最大矩形，还需要考虑高度很高，但长度较短的矩形。如[5,4,3,2,4,5,0,7,8,4,6]中最大矩形的高度是[7,8,4,6]组成的矩形，面积为16。</p>
<p>2、环面上的最大子矩形</p>
<p>《算法竞赛入门经典》 P89 页。</p>
<p>3、最大子矩阵和</p>
<p>一个<code>M\*N</code>的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。如果所有数都是负数，就输出0。 例如：<code>3\*5</code>的矩阵：</p>
<p>1 2 0 3 4</p>
<p>2 3 4 5 1</p>
<p>1 1 5 3 0</p>
<p>和最大的子矩阵是：</p>
<p>4 5</p>
<p>5 3</p>
<p>最后输出和的最大值17。</p>
<p>4、允许交换两个数的位置 求最大子数组和。</p>
<h3 id="跳台阶问题"><a href="#跳台阶问题" class="headerlink" title="跳台阶问题"></a>跳台阶问题</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。</p>
<p>求总共有多少总跳法，并分析算法的时间复杂度。</p>
<p>也是找<font color="blue">状态转移</font>，——斐波那契数列</p>
<p>我们把上面的分析用一个公式总结如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        /  1                             n = 1</span><br><span class="line">f(n)=      2                             n = 2</span><br><span class="line">        \  f(n-1) + f(n-2)               n &gt; 2</span><br></pre></td></tr></table></figure>

<p>原来上述问题就是我们平常所熟知的Fibonacci数列问题。可编写代码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如果一个人上台阶可以一次上1个，2个，或者3个呢？这个时候，公式是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        / 1                                      n = 1</span><br><span class="line">f(n)=     2                                      n = 2</span><br><span class="line">          4                                      n = 3       //111, 12, 21, 3</span><br><span class="line">        \ f(n-1)+f(n-2)+f(n-3)                   n &gt; 3</span><br></pre></td></tr></table></figure>

<h4 id="解法二-3"><a href="#解法二-3" class="headerlink" title="解法二"></a>解法二</h4><p>解法一用的<strong><font color="blue">递归的方法有许多重复计算</font></strong>的工作，事实上，我们可以从后往前推，一步步利用之前计算的结果递推。 ——<strong><font color="blue">递归转循环</font></strong></p>
<p>初始化时，dp[0]=dp[1]=1，然后递推计算即可：dp[n] = dp[n-1] + dp[n-2]。</p>
<p>参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1, 1, 2, 3, 5, 8, 13, 21..</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClimbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">2</span>] = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="举一反三-9"><a href="#举一反三-9" class="headerlink" title="举一反三"></a>举一反三</h3><p>1、兔子繁殖问题</p>
<p>13世纪意大利数学家斐波那契在他的《算盘书》中提出这样一个问题：有人想知道一年内一对兔子可繁殖成多少对，便筑了一道围墙把一对兔子关在里面。已知一对兔子每一个月可以生一对小兔子，而一对兔子出生后.第<font color="blue">三个月</font>（注意是第几个月）开始生小兔子假如一年内没有发生死亡，则一对兔子一年内能繁殖成多少对？</p>
<p>分析：这就是斐波那契数列的由来，本节的跳台阶问题便是此问题的变形，只是换了种表述形式。</p>
<p>2、换硬币问题。</p>
<p>想兑换100元钱，有1,2,5,10四种钱，问总共有多少兑换方法。</p>
<p>相当于每次可以跳1 2 5 10 问总共有多少种跳法。</p>
<p>好好理解下面的代码， <font color="blue">通过一个简单的循环嵌套完成了在不同区间不同表达式的统一代码，数学原理是通过将表达式拆分再相加，利用循环把区间区别开</font></p>
<p>而且 由于表达式没有一致性，我们这里用一个数组来存储value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100;</span><br><span class="line">int dimes[] = &#123; 1, 2, 5, 10 &#125;;</span><br><span class="line">int arr[N + 1] = &#123; 1 &#125;; //这里如果不这么初始化，其他部分可能不是0！！！，所以数组还是要显式初始化，不要默认初始化</span><br><span class="line">for (int i = 0; i &lt; sizeof(dimes) / sizeof(int); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    for (int j = dimes[i]; j &lt;= N; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[j] += arr[j - dimes[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此问题还有一个变形，就是打印出路径目前只想到要使用递归来解决这个问题。对此，利用一个vector来保存路径，<font color="blue">每进入一层，push_back一个路径，每退出一层，pop_back一个路径</font>。</p>
<h3 id="奇偶排序"><a href="#奇偶排序" class="headerlink" title="奇偶排序"></a>奇偶排序</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。要求<font color="blue">时间复杂度为O(n)</font>。</p>
<h4 id="分析与解法-5"><a href="#分析与解法-5" class="headerlink" title="分析与解法"></a>分析与解法</h4><p>还是暴力解法。。。pass</p>
<p>事实上，若把奇数看做是小的数，偶数看做是大的数，那么按照题目所要求的奇数放在前面偶数放在后面，就相当于小数放在前面大数放在后面，<font color="blue">联想到快速排序中的partition过程</font>，不就是通过一个主元把整个数组分成大小两个部分么，小于主元的小数放在前面，大于主元的大数放在后面。</p>
<p><font color="blue">partition过程有以下两种实现</font>：</p>
<ul>
<li><p><strong><font color="blue">一头一尾两个指针往中间扫描</font></strong>，如果头指针遇到的数比主元大且尾指针遇到的数比主元小，则交换头尾指针所分别指向的数字；</p>
<p>按照题目要求，最终是为了让奇数排在数组的前面，偶数排在数组的后面，所以头指针理应指向的就是奇数，尾指针理应指向的就是偶数，故当<font color="blue">头指针指向的是偶数且尾指针指向的是奇数时，我们就当立即交换</font>它们所指向的数字。</p>
<p>注意头尾指针++和—的时机</p>
<p>代码（自己写的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a , <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span>&amp; num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>&amp;(num<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oddEvenSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; array1)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> length = array1.size();</span><br><span class="line">	<span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tail = length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(head&lt;tail)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEven(array1[head])&amp;&amp;!isEven(array1[tail]))&#123;</span><br><span class="line">			swap(array1[head++],array1[tail--]);	</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!isEven(array1[head]))</span><br><span class="line">			head++;</span><br><span class="line">		<span class="keyword">if</span>(isEven(array1[tail]))</span><br><span class="line">			tail--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array1 &#123;<span class="number">2</span>, <span class="number">8</span>,<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	oddEvenSort(array1);</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = array1.begin(); iter != array1.end(); iter++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><strong><font color="blue">一前一后两个指针同时从左往右扫</font></strong>，如果前指针遇到的数比主元小，则后指针右移一位，然后交换各自所指向的数字。</li>
</ul>
<h4 id="举一反三-10"><a href="#举一反三-10" class="headerlink" title="举一反三"></a>举一反三</h4><p>一个未排序整数数组，有正负数，重新排列使负数排在正数前面，并且要求不改变原来的正负数之间相对顺序，比如： input: 1,7,-5,9,-12,15 ans: -5,-12,1,7,9,15 要求时间复杂度O(n),空间O(1)。</p>
<p>分析：如果本题没有这个要求“并且要求不改变原来的正负数之间相对顺序”，那么同奇偶数排序是一道题，但加上这个不能改变正负数之间的相对顺序后，便使得问题变得比较艰难了，若有兴趣，读者可以参考这篇论文《STABLE MINIMUM SPACE PARTITIONING IN LINEAR TIME》。</p>
<h3 id="荷兰国旗"><a href="#荷兰国旗" class="headerlink" title="荷兰国旗"></a>荷兰国旗</h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>拿破仑席卷欧洲大陆之后，代表自由，平等，博爱的竖色三色旗也风靡一时。荷兰国旗就是一面三色旗（只不过是横向的），自上而下为红白蓝三色。</p>
<p>该问题本身是<strong>关于三色球排序和分类</strong>的，由荷兰科学家Dijkstra提出。由于问题中的三色小球有序排列后正好分为三类，Dijkstra就想象成他母国的国旗，于是问题也就被命名为荷兰旗问题（Dutch National Flag Problem）。</p>
<p>下面是问题的正规描述： 现有<font color="blue">n个红白蓝三种不同颜色的小球</font>，<font color="blue">乱序排列</font>在一起，请通过<font color="blue">两两交换任意两个球</font>，使得从左至右，<font color="blue">依次是一些红球、一些白球、一些蓝球</font>。</p>
<h4 id="分析与解法-6"><a href="#分析与解法-6" class="headerlink" title="分析与解法"></a>分析与解法</h4><p>初看此题，我们貌似除了暴力解决并无好的办法，但联想到我们所熟知的快速排序算法呢？</p>
<p>我们知道，快速排序依托于一个<strong><font color="blue">partition分治</font></strong>过程，在每一趟排序的过程中，选取的主元都会把整个数组排列成一大一小的部分，那我们是否可以借鉴partition过程<strong>设定三个指针完成重新排列，使得所有球排列成三个不同颜色的球呢</strong>？</p>
<p><strong><em>Partition其实是一个分类的思想 好好利用，分类但不排序，通过递归可以完成快排</em></strong></p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>通过前面的分析得知，这个问题类似快排中partition过程，只是需要用到三个指针：<font color="blue">一个前指针begin，一个中指针current，一个后指针end，current指针</font>遍历整个数组序列，当</p>
<ol>
<li><p>current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；</p>
<p>这个地方begin所指向：如果begin current相同 那么是0，否则是1 ，不会指向2（注意理解逻辑）</p>
</li>
<li><p>current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；</p>
</li>
<li><p>current指针所指元素为2时，与end指针所指的元素交换，而后，current指针不动，end– 。</p>
</li>
</ol>
<p>为什么上述第3点中，current指针所指元素为2时，与end指针所指元素交换之后，current指针不能动呢？因为第三步中current指针所指元素与end指针所指元素交换之前，如果end指针之前指的元素是0，那么与current指针所指元素交换之后，current指针此刻所指的元素是0，此时，current指针能动么？不能动，因为如上述第1点所述，如果current指针所指的元素是0，还得与begin指针所指的元素交换。</p>
<p> 代码（自己写的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threeColorSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator begin = <span class="built_in">array</span>.begin();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator current = <span class="built_in">array</span>.begin();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator end = <span class="built_in">array</span>.end();</span><br><span class="line">	<span class="keyword">while</span>(current&lt;end)&#123;</span><br><span class="line">		<span class="keyword">if</span>(*current == <span class="number">0</span>)&#123;</span><br><span class="line">			swap(*current, *begin);</span><br><span class="line">			begin++;</span><br><span class="line">			current++; <span class="comment">// *begin must be 1 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(*current == <span class="number">1</span>)&#123;</span><br><span class="line">			current++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			swap(*current, *end);</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span> = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	threeColorSort(<span class="built_in">array</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=<span class="built_in">array</span>.begin(); iter!=<span class="built_in">array</span>.end() ; iter++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="举一反三-11"><a href="#举一反三-11" class="headerlink" title="举一反三"></a>举一反三</h4><p>给定一个字符串里面只有”R” “G” “B” 三个字符，请排序，最终结果的顺序是R在前 G中 B在后。</p>
<p>要求：空间复杂度是O(1)，且只能遍历一次字符串。</p>
<h3 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>请编程实现矩阵乘法，并考虑当矩阵规模较大时的优化方法。</p>
<h4 id="分析与解法-7"><a href="#分析与解法-7" class="headerlink" title="分析与解法"></a>分析与解法</h4><p>根据wikipedia上的介绍：两个矩阵的乘法仅当第一个矩阵A的行数和另一个矩阵B的列数相等时才能定义。如A是m×n矩阵，B是n×p矩阵，它们的乘积AB是一个m×p矩阵，它的一个元素其中 1 ≤ i ≤ m, 1 ≤ j ≤ p。</p>
<p>值得一提的是，矩阵乘法满足结合律和分配率，但并不满足交换律，如下图所示的这个例子，两个矩阵交换相乘后，结果变了：</p>
<p>下面咱们来具体解决这个矩阵相乘的问题。</p>
<h4 id="解法一-暴力解法"><a href="#解法一-暴力解法" class="headerlink" title="解法一 暴力解法"></a>解法一 暴力解法</h4><p>其实，通过前面的分析，我们已经很明显的看出，两个具有相同维数的矩阵相乘，其复杂度为O(n^3)，参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//矩阵乘法，3个for循环搞定    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MulMatrix</span><span class="params">(<span class="keyword">int</span>** matrixA, <span class="keyword">int</span>** matrixB, <span class="keyword">int</span>** matrixC)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)     </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)     </span><br><span class="line">        &#123;    </span><br><span class="line">            matrixC[i][j] = <span class="number">0</span>;    </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)     </span><br><span class="line">            &#123;    </span><br><span class="line">                matrixC[i][j] += matrixA[i][k] * matrixB[k][j];    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二-Strassen-算法"><a href="#解法二-Strassen-算法" class="headerlink" title="解法二 Strassen 算法"></a>解法二 Strassen 算法</h4><p>。。。</p>
<h3 id="完美洗牌算法"><a href="#完美洗牌算法" class="headerlink" title="完美洗牌算法"></a>完美洗牌算法</h3><h4 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h4><p>有个长度为2n的数组{a1,a2,a3,…,an,b1,b2,b3,…,bn}，希望排序后{a1,b1,a2,b2,….,an,bn}，请考虑有无<font color="blue">时间复杂度O(n)，空间复杂度O(1)</font>的解法。</p>
<p><strong>题目来源</strong>：此题是去年2013年UC的校招笔试题，看似简单，按照题目所要排序后的字符串蛮力变化即可，但若要完美的达到题目所要求的时空复杂度，则需要我们花费不小的精力。OK，请看下文详解，一步步优化。</p>
<p>有时间看 。。</p>
<h2 id="第三章-树"><a href="#第三章-树" class="headerlink" title="第三章 树"></a>第三章 树</h2><h3 id="本章导读"><a href="#本章导读" class="headerlink" title="本章导读"></a>本章导读</h3><p>想要更好地理解红黑树，可以先理解二叉查找树和2-3树。为何呢？首先，二叉查找树中的结点是2-结点（一个键两条链），引入<font color="blue">3-结点（两个键三条链），即成2-3树</font>；然后将2-3树中3-结点分解，即成红黑树，故结合二叉查找树易查找和2-3树易插入的特点，便成了红黑二叉查找树，简称红黑树。</p>
<p>进一步而言，理解了2-3树，也就理解了B树、B+树、B*树，因为2-3树就是一棵3阶的B树，而一颗3阶的B树各个结点关键字数满足1-2，故当结点关键字数多于2时则达到饱和，此时需要分裂结点，而结点关键字数少于1时则从兄弟结点“借”关键字补充。</p>
<p>但为何有了红黑树，还要发明B树呢？原因是，当计算机要处理的数据量一大，便无法一次性装入内存进行处理，于此，计算机会把大部分备用的数据存在磁盘中，有需要的时候，就从磁盘中调取数据到在内存中处理，如果处理时修改了数据，则再次将数据写入磁盘，如此导致了不断的磁盘IO读写，而树的高度越高，查找文件所需要的磁盘IO读写次数越多，所以为了减少磁盘的IO读写，要想办法进一步降低树的高度。 因此，具有多个孩子的B树便应运而生，因为B树每一个结点可以有几个到几千个孩子，使得在结点数目一定的情况下，树的高度会大大降低，从而有效减少磁盘IO读写消耗。</p>
<p>此外，无论是<code>B树</code>，还是<code>B+树、B\*树</code>，由于根或者树的上面几层被反复查询，所以树上层几块的数据可以存在内存中。换言之，<code>B树、B+树、B\*</code>树的根结点和部分顶层数据存在内存中，大部分下层数据存在磁盘上。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>若任意结点的左子树不空，则左子树上<strong><font color="blue">所有结点</font></strong>的值均小于它的根结点的值；</li>
<li>若任意结点的右子树不空，则右子树上<strong><font color="blue">所有结点</font></strong>的值均大于它的根结点的值；</li>
<li>任意结点的左、右子树也分别为二叉查找树。</li>
<li>没有键值相等的结点（no duplicate nodes）。</li>
</ul>
<p>红黑树本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。</p>
<p>但它是如何保证一棵n个结点的红黑树的高度始终保持在h = logn的呢？这就引出了红黑树的5条性质：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）每个结点要么是红的，要么是黑的。  </span><br><span class="line">2）根结点是黑的。  </span><br><span class="line">3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  </span><br><span class="line">4）如果一个结点是红的，那么它的俩个儿子都是黑的。  </span><br><span class="line">5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。</span><br></pre></td></tr></table></figure>

<p>正是红黑树的这5条性质，使得一棵n个结点是红黑树始终保持了logn的高度，从而也就解释了上面我们所说的“红黑树的查找、插入、删除的时间复杂度最坏为O(log n)”这一结论的原因。</p>
<p><strong><font color="blue">省略。。。有时间看</font></strong></p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>二叉查找树结构由于<strong>树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下</strong>，因此我们该想办法降低树的深度，从而减少磁盘查找存取的次数。一个基本的想法就是：采用<strong><font color="blue">多叉树</font></strong>结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。</p>
<p>平衡多路查找树，即<strong>B-tree（B-tree树即B树*</strong>，B即Balanced，平衡的意思<strong>）</strong></p>
<p>后面我们会看到，B树的各种操作能使B树保持较低的高度，从而有效避免磁盘过于频繁的查找存取操作，达到有效提高查找效率的目的。然在开始介绍B<del>tree之前，先了解下相关的硬件知识，才能很好的了解为什么需要B</del>tree这种<font color="blue">外存数据结构</font>。</p>
<p>许多数据库系统都一般使用B树或者B树的各种变形结构</p>
<p>B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。不过B树与红黑树一样，一棵含n个结点的B树的高度也为<code>O(lgn)</code>，但可能比一棵红黑树的高度小许多，因为<strong>它的分支因子比较大</strong>。所以，B树可以在<code>O（logn）</code>时间内，实现各种如插入（insert），删除（delete）等动态集合操作。</p>
<p>。。。<strong>详看以前，之前学习过</strong></p>
<h3 id="最近公共祖先LCA问题"><a href="#最近公共祖先LCA问题" class="headerlink" title="最近公共祖先LCA问题"></a>最近公共祖先LCA问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>求有根树的任意两个结点的最近公共祖先</p>
<p>解答这个问题之前，咱们得先搞清楚到底什么是最近公共祖先。最近公共祖先简称LCA（Lowest Common Ancestor），所谓LCA，是当给定一个有根树T时，对于任意两个结点u、v，找到一个离根最远的结点x，使得x同时是u和v的祖先，x 便是u、v的最近公共祖先。（参见：<a href="http://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Lowest_common_ancestor</a> ）原问题涵盖一般性的有根树，<strong><font color="blue">本文为了简化，多使用二叉树来讨论</font></strong>。</p>
<p><strong>是不是二叉查找树</strong></p>
<h4 id="解法一-暴力对待"><a href="#解法一-暴力对待" class="headerlink" title="解法一 暴力对待"></a>解法一 暴力对待</h4><ul>
<li><p><strong>是二叉查找树</strong></p>
<p>那么从树根开始：</p>
<ul>
<li>如果当前结点t 大于结点u、v，说明u、v都在t 的左侧，所以它们的共同祖先必定在t 的左子树中，故从t 的左子树中继续查找；</li>
<li>如果当前结点t 小于结点u、v，说明u、v都在t 的右侧，所以它们的共同祖先必定在t 的右子树中，故从t 的右子树中继续查找；</li>
<li>如果当前结点t 满足 u &lt;t &lt; v，说明u和v分居在t 的两侧，故当前结点t 即为最近公共祖先；</li>
<li>而如果u是v的祖先，那么返回u的父结点，同理，如果v是u的祖先，那么返回v的父结点。</li>
</ul>
<p>代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copyright@eriol 2011  </span></span><br><span class="line"><span class="comment">//modified by July 2014  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(Node t, Node u, Node v)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> left = u.value;    </span><br><span class="line">    <span class="keyword">int</span> right = v.value;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉查找树内，如果左结点大于右结点，不对，交换  </span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;    </span><br><span class="line">        <span class="keyword">int</span> temp = left;    </span><br><span class="line">        left = right;    </span><br><span class="line">        right = temp;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;    </span><br><span class="line">        <span class="comment">//如果t小于u、v，往t的右子树中查找  </span></span><br><span class="line">        <span class="keyword">if</span> (t.value &lt; left) &#123;    </span><br><span class="line">            t = t.right;    </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果t大于u、v，往t的左子树中查找  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.value &gt; right) &#123;    </span><br><span class="line">            t = t.left;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="keyword">return</span> t.value;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不是二叉查找树</p>
<p>但如果这棵树不是二叉查找树，只是一棵普通的二叉树呢？<font color="blue">如果每个结点都有一个指针指向它的父结点</font>，于是我们可以从任何一个结点出发，得到一个到达树根结点的单向链表。因此这个<font color="blue">问题转换为两个单向链表的第一个公共结点</font>。</p>
<p>此外，如果给出根节点，LCA问题可以用递归很快解决。而关于树的问题一般都可以转换为递归（因为树本来就是递归描述），参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copyright@allantop 2014-1-22-20:01  </span></span><br><span class="line"><span class="function">node* <span class="title">getLCA</span><span class="params">(node* root, node* node1, node* node2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(root == null)  </span><br><span class="line">        <span class="keyword">return</span> null;  </span><br><span class="line">    <span class="keyword">if</span>(root== node1 || root==node2)  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line"></span><br><span class="line">    node* left = getLCA(root-&gt;left, node1, node2);  </span><br><span class="line">    node* right = getLCA(root-&gt;right, node1, node2);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left != null &amp;&amp; right != null)  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left != null)  </span><br><span class="line">        <span class="keyword">return</span> left;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (right != null)  </span><br><span class="line">        <span class="keyword">return</span> right;  </span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="keyword">return</span> null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然不论是针对普通的二叉树，还是针对二叉查找树，<font color="blue">上面的解法有一个很大的弊端就是：如需N 次查询，则总体复杂度会扩大N 倍</font>，故这种暴力解法仅适合一次查询，不适合多次查询。</p>
<p><strong>接下来的解法，将不再区别对待是否为二叉查找树</strong>，而是一致当做是一棵普通的二叉树。总体来说，由于<font color="blue">可以把LCA问题看成是询问式的</font>，即给出一系列询问，程序对每一个询问尽快做出反应。故处理这类问题<strong>一般有两种解决方法</strong>：</p>
<ul>
<li><strong>一种是在线算法，相当于循序渐进处理</strong>；</li>
<li><strong>另外一种则是离线算法，如Tarjan算法，相当于一次性批量处理，一开始就知道了全部查询，只待询问</strong>。</li>
</ul>
</li>
</ul>
<h4 id="解法二：Tarjan算法"><a href="#解法二：Tarjan算法" class="headerlink" title="解法二：Tarjan算法"></a>解法二：Tarjan算法</h4><p>如上文末节所述，不论咱们所面对的二叉树是二叉查找树，或不是二叉查找树，都可以把求任意两个结点的最近公共祖先，当做是查询的问题，如果是只求一次，则是单次查询；如果要求多个任意两个结点的最近公共祖先，则相当于是批量查询。</p>
<p><strong>涉及到批量查询的时候，咱们可以借鉴离线处理的方式，这就引出了解决此LCA问题的Tarjan离线算法。</strong></p>
<h4 id="2-1、什么是Tarjan算法"><a href="#2-1、什么是Tarjan算法" class="headerlink" title="2.1、什么是Tarjan算法"></a>2.1、什么是Tarjan算法</h4><p>Tarjan算法 （以发现者Robert Tarjan命名）是一个<font color="blue">在图中寻找强连通分量</font>的算法。算法的基本思想为：任选一结点开始进行深度优先搜索dfs（若深度优先搜索结束后仍有未访问的结点，则再从中任选一点再次进行）。搜索过程中已访问的结点不再访问。<strong>搜索树的若干子树构成了图的强连通分量。</strong></p>
<p>应用到咱们要解决的LCA问题上，则是：对于新搜索到的一个结点u，先创建由u构成的集合，再对u的每颗子树进行搜索，每搜索完一棵子树，<font color="blue">这时候子树中所有的结点的最近公共祖先就是u了</font>。</p>
<p>举一个例子，如下图（不同颜色的结点相当于不同的集合）：</p>
<p>假设遍历完10的孩子,要处理关于10的请求了，取根节点到当前正在遍历的节点的路径为关键路径,即1-3-8-10，集合的祖先便是关键路径上距离集合最近的点。</p>
<p>比如：</p>
<ul>
<li>1，2，5，6为一个集合,祖先为1，集合中点和10的LCA为1</li>
<li>3，7为一个集合，祖先为3，集合中点和10的LCA为3</li>
<li>8，9，11为一个集合，祖先为8，集合中点和10的LCA为8</li>
<li>10，12为一个集合，祖先为10，集合中点和10的LCA为10</li>
</ul>
<p>得出的结论便是：LCA(u,v)便是根至u的路径上到节点v最近的点。</p>
<h4 id="2-2、Tarjan算法如何而来"><a href="#2-2、Tarjan算法如何而来" class="headerlink" title="2.2、Tarjan算法如何而来"></a>2.2、Tarjan算法如何而来</h4><p>但关键是 Tarjan算法是怎么想出来的呢？再给定下图，你是否能看出来：分别从结点1的左右子树当中，任取一个结点，设为u、v，这两个任意结点u、v的最近公共祖先都为1。</p>
<p>于此，我们可以得知：若两个结点u、v分别分布于某节点t 的左右子树，那么此节点 t即为u和v的最近公共祖先。更进一步，考虑到一个节点自己就是LCA的情况，得知：</p>
<ul>
<li>若某结点t 是两结点u、v的祖先之一，且这两结点并不分布于该结点t 的一棵子树中，而是分别在结点t 的左子树、右子树中，那么该结点t 即为两结点u、v的最近公共祖先。</li>
</ul>
<p>这个定理就是Tarjan算法的基础。</p>
<p>一如上文1.1节我们得到的结论：“如果当前结点t 满足 u &lt;t &lt; v，说明u和v分居在t 的两侧，故当前结点t 即为最近公共祖先”。</p>
<p>而对于本节开头我们所说的“如果要求多个任意两个结点的最近公共祖先，则相当于是批量查询”，即在很多组的询问的情况下，或许可以先确定一个LCA。例如是根节点1，然后再去检查所有询问，看是否满足刚才的定理，不满足就忽视，满足就赋值，全部弄完，再去假设2号节点是LCA，再去访问一遍。</p>
<p>可此方法需要判断一个结点是在左子树、还是右子树，或是都不在，都只能遍历一棵树，而多次遍历的代价实在是太大了，所以我们需要找到更好的方法。这就引出了下面要阐述的Tarjan算法，即每个结点只遍历一次，怎么做到的呢，请看下文讲解。</p>
<h3 id="2-3、Tarjan算法流程"><a href="#2-3、Tarjan算法流程" class="headerlink" title="2.3、Tarjan算法流程"></a>2.3、Tarjan算法流程</h3><p>Tarjan算法流程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Procedure dfs（u）；</span><br><span class="line">    begin</span><br><span class="line">        设置u号节点的祖先为u</span><br><span class="line">        若u的左子树不为空，dfs（u - 左子树）；</span><br><span class="line">        若u的右子树不为空，dfs（u - 右子树）；</span><br><span class="line">        访问每一条与u相关的询问u、v</span><br><span class="line">            -若v已经被访问过，则输出v当前的祖先t（t即u,v的LCA）</span><br><span class="line">        标记u为已经访问，将所有u的孩子包括u本身的祖先改为u的父亲</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>普通的dfs 不能直接解决LCA问题，故Tarjan算法的原理是dfs + <a href="http://zh.wikipedia.org/zh-cn/并查集" target="_blank" rel="noopener">并查集</a>，它每次把两个结点对的最近公共祖先的查询保存起来，然后dfs 更新一次。如此，利用并查集优越的时空复杂度，此算法的时间复杂度可以缩小至O(n＋Q)，其中，n为数据规模，Q为询问个数。</p>
<p><strong><font color="red">看完图的部分再回来看</font></strong></p>
<h2 id="第四章-查找匹配"><a href="#第四章-查找匹配" class="headerlink" title="第四章 查找匹配"></a>第四章 查找匹配</h2><h3 id="有序数组的查找"><a href="#有序数组的查找" class="headerlink" title="有序数组的查找"></a>有序数组的查找</h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个有序的数组，查找某个数是否在数组中，请编程实现</p>
<p>使用二分查找O(lgn)</p>
<p>以下是一份参考实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果这里是int right = n 的话，那么下面有两处地方需要修改，以保证一一对应：</span></span><br><span class="line">    <span class="comment">//1、下面循环的条件则是while(left &lt; right)</span></span><br><span class="line">    <span class="comment">//2、循环内当 array[middle] &gt; value 的时候，right = mid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)  <span class="comment">//循环条件，适时而变</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);  <span class="comment">//防止溢出，移位也更高效。同时，每次循环都需要更新。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &gt; value)</span><br><span class="line">        &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;  <span class="comment">//right赋值，适时而变</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[middle] &lt; value)</span><br><span class="line">        &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        <span class="comment">//可能会有读者认为刚开始时就要判断相等，但毕竟数组中不相等的情况更多</span></span><br><span class="line">        <span class="comment">//如果每次循环都判断一下是否相等，将耗费时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="行列递增矩阵的查找"><a href="#行列递增矩阵的查找" class="headerlink" title="行列递增矩阵的查找"></a>行列递增矩阵的查找</h3><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>例如下面的二维数组就是每行、每列都递增排序。如果在这个数组中查找数字6，则返回true；如果查找数字5，由于数组不含有该数字，则返回false。</p>
<p>定位法：详见 剑指 offer</p>
<h4 id="举一反三-12"><a href="#举一反三-12" class="headerlink" title="举一反三"></a>举一反三</h4><p>1、给定 n×n 的实数矩阵，每行和每列都是递增的，求这 n^2 个数的中位数。</p>
<p>2、我们已经知道杨氏矩阵的每行的元素从左到右单调递增，每列的元素从上到下也单调递增的矩阵。那么，如果给定从1-n这n个数，我们可以构成多少个杨氏矩阵呢？</p>
<p>例如n = 4的时候，我们可以构成1行4列的矩阵：</p>
<p>1 2 3 4</p>
<p>2个2行2列的矩阵:</p>
<p>1 2</p>
<p>3 4</p>
<p>和</p>
<p>1 3</p>
<p>2 4</p>
<p>还有一个4行1列的矩阵</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>因此输出4。</p>
<h3 id="出现次数超过一半的数字"><a href="#出现次数超过一半的数字" class="headerlink" title="出现次数超过一半的数字"></a>出现次数超过一半的数字</h3><h4 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中有一个数组的次数超过了数组长度的一半，找出这个数字</p>
<h4 id="解法一-3"><a href="#解法一-3" class="headerlink" title="解法一"></a>解法一</h4><p>哈希表 空间换时间</p>
<h4 id="解法二-4"><a href="#解法二-4" class="headerlink" title="解法二"></a>解法二</h4><p>Hash表需要O(n)的空间开销，且要设计hash函数，还有没有更好的办法呢？我们可以试着这么考虑，如果<strong><font color="blue">每次删除两个不同的数</font></strong>（不管是不是我们要查找的那个出现次数超过一半的数字），那么，在剩下的数中，我们要查找的数（出现次数超过一半）出现的次数仍然超过总数的一半。通过不断重复这个过程，不断排除掉其它的数，最终找到那个出现次数超过一半的数字。这个方法，免去了排序，也避免了空间O(n)的开销，总得说来，时间复杂度只有O(n)，空间复杂度为O(1)，貌似不失为最佳方法。</p>
<p>举个简单的例子，如数组a[5] = {0, 1, 2, 1, 1};</p>
<p>很显然，若我们要找出数组a中出现次数超过一半的数字，这个数字便是1，若根据上述思路4所述的方法来查找，我们应该怎么做呢？通过一次性遍历整个数组，然后每次删除不相同的两个数字，过程如下简单表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 1 1 =&gt;2 1 1=&gt;1</span><br></pre></td></tr></table></figure>

<p>最终1即为所找。</p>
<p>此外，对于序列{5, 5, 5, 5, 1}，每次分别从数组两端尝试各删除一个数(左边删除5, 右边删除1，两个数不相同)，之后剩余{5, 5, 5}，这时无法找到两个不同的数进行删除，说明剩余元素全部相同，返回5作为结果即可</p>
<h3 id="解法四-1"><a href="#解法四-1" class="headerlink" title="解法四"></a>解法四</h3><p>更进一步，考虑到这个问题本身的特殊性，我们可以在遍历数组的时候保存两个值：一个candidate，用来保存数组中遍历到的某个数字；一个nTimes，表示当前数字的出现次数，其中，nTimes初始化为1。当我们遍历到数组中下一个数字的时候：</p>
<ul>
<li>如果下一个数字与之前candidate保存的数字相同，则nTimes加1；</li>
<li>如果下一个数字与之前candidate保存的数字不同，则nTimes减1；</li>
<li>每当出现次数nTimes变为0后，用candidate保存下一个数字，并把nTimes重新设为1。 直到遍历完数组中的所有数字为止。</li>
</ul>
<p>举个例子，假定数组为{0, 1, 2, 1, 1}，按照上述思路执行的步骤如下：</p>
<ul>
<li>1.开始时，candidate保存数字0，nTimes初始化为1；</li>
<li>2.然后遍历到数字1，与数字0不同，则nTimes减1变为0；</li>
<li>3.因为nTimes变为了0，故candidate保存下一个遍历到的数字2，且nTimes被重新设为1；</li>
<li>4.继续遍历到第4个数字1，与之前candidate保存的数字2不同，故nTimes减1变为0；</li>
<li>5.因nTimes再次被变为了0，故我们让candidate保存下一个遍历到的数字1，且nTimes被重新设为1。最后返回的就是最后一次把nTimes设为1的数字1。</li>
</ul>
<p>思路清楚了，完整的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a代表数组，length代表数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindOneNumber</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidate = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> nTimes = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nTimes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            candidate = a[i];</span><br><span class="line">            nTimes = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate == a[i])</span><br><span class="line">                nTimes++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nTimes--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即针对数组{0, 1, 2, 1, 1}，套用上述程序可得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i=0，candidate=0，nTimes=1；</span><br><span class="line">i=1，a[1] != candidate，nTimes--，=0；</span><br><span class="line">i=2，candidate=2，nTimes=1；</span><br><span class="line">i=3，a[3] != candidate，nTimes--，=0；</span><br><span class="line">i=4，candidate=1，nTimes=1；</span><br><span class="line">如果是0，1，2，1，1，1的话，那么i=5，a[5] == candidate，nTimes++，=2；......</span><br></pre></td></tr></table></figure>

<h4 id="举一反三-13"><a href="#举一反三-13" class="headerlink" title="举一反三"></a>举一反三</h4><p>加强版水王：找出出现次数刚好是一半的数字</p>
<p>分析：我们知道，水王问题：有N个数，其中有一个数出现超过一半，要求在线性时间求出这个数。那么，我的问题是，加强版水王：有N个数，其中有一个数刚好出现一半次数，要求在线性时间内求出这个数。</p>
<p>因为，很明显，如果是刚好出现一半的话，如此例： 0，1，2，1 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">遍历到0时，candidate为0，times为1</span><br><span class="line">遍历到1时，与candidate不同，times减为0</span><br><span class="line">遍历到2时，times为0，则candidate更新为2，times加1</span><br><span class="line">遍历到1时，与candidate不同，则times减为0；我们需要返回所保存candidate（数字2）的下一个数字，即数字1。</span><br></pre></td></tr></table></figure>

<p>分治 dp 贪心 回溯 分支界定</p>
<p>常用<strong><font color="blue">算法思想</font></strong>：</p>
<p><strong>分治</strong> <strong>动态规划</strong> <strong>贪心</strong> <strong>回溯</strong> <strong>分支界定</strong></p>
<ul>
<li><p>分治</p>
<p>设计思想：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之</p>
<p><strong>问题的规模越小，越容易直接求解，解题所需的计算时间也越少</strong></p>
<p> 分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，<strong><font color="blue">递归地解</font></strong>这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>三、分治法适用的情况</p>
<pre><code>分治法所能解决的问题一般具有以下几个特征：

1) 该问题的规模缩小到一定的程度就可以容易地解决

2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

3) 利用该问题分解出的子问题的解可以合并为该问题的解；

4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</code></pre><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p>第三条特征是关键，<font color="blue">能否利用分治法完全取决于问题是否具有第三条特征</font>，如果<font color="blue">具备了第一条和第二条特征，而不具备第三条特征</font>，则可以<font color="blue">考虑用贪心法或动态规划法</font>。</p>
<p>第四条特征<font color="blue">涉及到分治法的效率</font>，如果各子问题是<font color="blue">不独立的则分治法要做许多不必要的工作</font>，重复地解公共的子问题，<font color="blue">此时</font>虽然可用分治法，但一般用<font color="blue">动态规划法较好</font>。四、分治法的基本步骤</p>
<p>分治法在每一层递归上都有三个步骤：</p>
<pre><code>step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

step3 合并：将各个子问题的解合并为原问题的解。</code></pre><p>它的一般的算法设计模式如下：</p>
<pre><code>Divide-and-Conquer(P)

1. if |P|≤n0

2. then return(ADHOC(P))

3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk

4. for i←1 to k

5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

6. T ← MERGE(y1,y2,...,yk) △ 合并子问题

7. return(T)

其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。</code></pre><p>五、分治法的复杂性分析</p>
<pre><code>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</code></pre><p> T（n）= k T(n/m)+f(n)</p>
<p> 通过迭代法求得方程的解：<br> 递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 </p>
<p> 六、可使用分治法求解的一些经典问题<br>   （1）二分搜索</p>
<pre><code>（2）大整数乘法
 （3）Strassen矩阵乘法
（4）棋盘覆盖
（5）合并排序
（6）快速排序
（7）线性时间选择
（8）最接近点对问题
（9）循环赛日程表
（10）汉诺塔</code></pre><p>七、依据分治法设计程序时的思维过程<br>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。<br>1、一定是先找到<font color="blue">最小问题规模时的求解方法</font><br>2、然后考虑<font color="blue">随着问题规模增大时的求解方法</font><br>3、找到求解的<font color="blue">递归函数式后（各种规模或因子）</font>，设计递归程序即可。</p>
</li>
<li><p><strong>动态规划算法</strong></p>
<p>一 . 基本概念</p>
<p>​        动态规划的过程：每次<font color="blue">决策依赖于当前状态，又随即引起状态的转移</font>。一个决策序列就是在变化的状态中产生出来的，所以这种多阶段最优化决策解决问题的过程就称为动态规划</p>
<p>二. 基本思想和策略</p>
<p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，<font color="blue">前一子问题的解，为后一子问题的求解提供了有用的信息</font>。在<font color="blue">求解任一子问题</font>时，<font color="blue">列出各种可能</font>的局部解，通过决策<font color="blue">保留那些有可能达到最优</font>的局部解，丢弃其他局部解。<font color="blue">依次解决</font>各子问题，<font color="blue">最后一个子问题就是初始问题的解</font>。</p>
<p>由于动态规划解决的问题多数有重叠子问题这个特点，为<font color="blue">减少重复计算</font>，对<font color="blue">每一个子问题只解一次</font>，将其不同阶段的不同状态<font color="blue">保存在一个二维数组</font>中。</p>
<pre><code>**与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的**（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</code></pre><p>三. 适用的情况</p>
<p>一般要具有以下<strong>三个性质</strong>：</p>
<ol>
<li><p><font color="blue">最优化原理</font></p>
<p>如果问题的<font color="blue">最优解所包含的子问题的解也是最优的</font>，就称该问题具有最优子结构，即满足最优化原理。</p>
</li>
<li><p><font color="blue">无后效性</font></p>
<p>即<font color="blue">某阶段状态一旦确定，就不受这个状态以后决策的影响</font>。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关</p>
</li>
<li><p><font color="blue">有重叠子问题</font></p>
<p>即子问题之间是不独立的，<font color="blue">一个子问题在下一阶段决策中可能被多次使用到</font>。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
</li>
</ol>
<p>四. 求解的基本步骤</p>
<p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p>
</li>
</ul>
<p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p>
<p>图1 动态规划决策过程示意图</p>
<p>(1)<font color="blue">划分阶段</font>：按照问题的时间或空间特征，<font color="blue">把问题分为若干个阶段</font>。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。<br>(2)<font color="blue">确定状态和状态变量</font>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，<font color="blue">状态的选择要满足无后效性</font>。<br>(3)<font color="blue">确定决策并写出状态转移方程</font>：因为决策和状态转移有着天然的联系，<strong>状态转移就是根据上一阶段的状态和决策来导出本阶段的状态</strong>。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，<strong>根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程</strong>。<br>(4)<font color="blue">寻找边界条件</font>：给出的状态转移方程是一个递推式，<strong>需要一个递推的终止条件或边界条件</strong>。<br>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<p>（1）分析最优解的性质，并刻画其结构特征。<br>（2）递归的定义最优解。<br>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值<br>（4）根据计算最优值时得到的信息，构造问题的最优解</p>
<p>五.算法实现的说明</p>
<p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p>
<p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p>
<p>（1）问题的<strong><font color="blue">阶段</font></strong> （2）每个阶段的<strong><font color="blue">状态</font></strong></p>
<p>（3）从前一个阶段转化到后一个阶段之间的<strong><font color="blue">递推关系</font></strong>。</p>
<p><strong>递推关系必须是从次小的问题开始到较大的问题之间的转化</strong>(<font color="blue">也就是要注意递推的方向</font>)，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面<strong>保存子问题的解来减少重复计算</strong>，所以对于大规模问题来说，有递归不可比拟的优势，这也是<strong>动态规划算法的核心之处</strong>。</p>
<p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p>
<p><strong><font color="red">f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</font></strong></p>
<ul>
<li><p>贪心算法</p>
<p>一.基本概念</p>
<p>所谓贪心算法是指，在对问题求解时，<font color="blue">总是做出在当前看来是最好的选择</font>。也就是说，<font color="blue">不从整体最优上加以考虑</font>，他所做出的仅是在某种意义上的局部最优解。</p>
<pre><code>贪心算法没有固定的算法框架，算法设计的**关键是贪心策略的选择**。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，**选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。**所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</code></pre><p>二、<strong>贪心算法的基本思路</strong>：</p>
<pre><code>1.建立数学模型来描述问题。
2.把求解的问题**&lt;font color=blue&gt;分解&lt;/font&gt;**成若干个子问题。
3.对每一子问题求解，得到**&lt;font color=blue&gt;子问题的局部最优解&lt;/font&gt;**。
4.把子问题的解局部最优解**&lt;font color=blue&gt;合成&lt;/font&gt;**原来解问题的一个解。</code></pre><p>三、贪心算法适用的问题</p>
<pre><code> 贪心策略适用的**前提是：局部最优策略能导致产生全局最优解。**
**实际上，贪心算法适用的情况很少**。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</code></pre><p>四、贪心算法的实现框架</p>
<pre><code>从问题的某一初始解出发；
while （能朝给定总目标前进一步）
{ 
      利用可行的决策，求出可行解的一个解元素；
}
由所有解元素组合成问题的一个可行解；</code></pre><p>五、贪心策略的选择</p>
<pre><code>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</code></pre><p>六、例题分析</p>
<pre><code>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。
[背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。
要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。
物品 A B C D E F G
重量 35 30 60 50 40 10 25
价值 10 40 30 50 35 40 30
分析：
目标函数： ∑pi最大
约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)
（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？
（2）每次挑选所占重量最小的物品装入是否能得到最优解？
（3）每次选取单位重量价值最大的物品，成为解本题的策略。
值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。
贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。
可惜的是，它需要证明后才能真正运用到题目的算法中。
一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。
对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：
（1）贪心策略：选取价值最大者。反例：
W=30
物品：A B C
重量：28 12 12
价值：30 20 20
根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。
（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。
（3）贪心策略：选取单位重量价值最大的物品。反例：
W=30
物品：A B C
重量：28 20 10
价值：28 20 10
根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误</code></pre></li>
<li><p><strong>回溯法</strong></p>
<ol>
<li><p>概念</p>
<p>回溯算法实际上一个<strong>类似枚举的搜索尝试</strong>过程，主要是在搜索尝试过程中寻找问题的解，当发现已<strong>不满足求解条件时，就“回溯”返回，尝试别的</strong>路径。</p>
<p>回溯法<strong>是一种选优搜索法，按选优条件向前搜索，</strong>以达到目标。但当探索到某一步时，发现原先选择并不优或<strong>达不到目标，就退回一步重新选择</strong>，这种<strong>走不通就退回再走</strong>的技术为回溯法，而满足回溯条件的某个状态的点称为<strong>“回溯点”</strong>。<br>许多复杂的，规模较大的问题都可以使用回溯法，有“<strong>通用解题方法</strong>”的美称。</p>
</li>
<li><p>基本思想</p>
<p>在包含问题的所有解的解空间树中，按照<strong>深度优先搜索的策略</strong>，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（<font color="blue">其实回溯法就是对隐式图的深度优先搜索算法</font>）。</p>
<p>若用回溯法<strong>求问题的所有解时，要回溯到根</strong>，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若使用回溯法<strong>求任一个解时，只要搜索到问题的一个解就可以结束。</strong></p>
</li>
<li><p>用回溯法解题的一般步骤</p>
<p>（1）针对所给问题，<font color="blue">确定问题的解空间</font>：</p>
<p>​         首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最        优）解。<br>（2）确定结点的扩展<font color="blue">搜索规则</font></p>
<p>（3）以<font color="blue">深度优先方式搜索</font>解空间，并在搜索过程中<font color="blue">用剪枝函数避免无效搜索</font>。</p>
</li>
</ol>
</li>
<li><p><strong>分支限界法</strong></p>
<p>一. 基本描述<br><strong>类似于回溯法</strong>，也是一种在问题的<font color="blue">解空间树T上搜索问题解的算法</font>。但在一般情况下，分支限界法与回溯法的求解目标不同。<strong>回溯法</strong>的求解目标是找出T中满足约束条件的<strong>所有解</strong>，而<strong>分支限界法</strong>的求解目标则是找出满足约束条件的<strong>一个解</strong>，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即<strong>在某种意义下的最优解</strong>。</p>
<p> 所谓“分支”就是<strong>采用广度优先的策略</strong><font color="blue">(回溯是深度优先)</font>，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p>
<p><font color="blue">选择下一个E-结点的方式</font>不同，则会有几种不同的分支搜索方式。</p>
<ol>
<li>FIFO搜索</li>
<li>LIFO搜索</li>
<li>优先队列搜索</li>
<li>分支限界搜索算法</li>
</ol>
<p>二、分支限界法的一般过程<br>由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。<strong>回溯法以深度优先的方式</strong>搜索解空间树T，而<strong>分支限界法则以广度优先或以最小耗费优先的方式</strong>搜索解空间树T。</p>
<p>分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
<p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p>
<p>三、回溯法和分支限界法的一些区别<br>有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>
</li>
</ul>
<p>回溯法和分支限界法的一些区别：</p>
<p>方法对解空间树的搜索方式       存储结点的常用数据结构      结点存储特性常用应用</p>
<p>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>
<p>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="YDE WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="YDE Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Note/" rel="tag"># Note</a>
          
            <a href="/tags/Interview/" rel="tag"># Interview</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/29/查缺补漏_Start_2019Fall/" rel="next" title="查缺补漏_Start_2019Fall">
                <i class="fa fa-chevron-left"></i> 查缺补漏_Start_2019Fall
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/29/OS_Start_2019Fall/" rel="prev" title="OS_Start_2019Fall">
                OS_Start_2019Fall <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">YDE</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TaoTaoUncle" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#海量数据问题"><span class="nav-number">1.</span> <span class="nav-text">海量数据问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关联式容器"><span class="nav-number">1.1.</span> <span class="nav-text">关联式容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分而治之"><span class="nav-number">1.2.</span> <span class="nav-text">分而治之</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#simhash算法"><span class="nav-number">1.3.</span> <span class="nav-text">simhash算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背景"><span class="nav-number">1.4.</span> <span class="nav-text">背景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引入simhash"><span class="nav-number">1.4.1.</span> <span class="nav-text">引入simhash</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外排序"><span class="nav-number">1.5.</span> <span class="nav-text">外排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapReduce"><span class="nav-number">1.6.</span> <span class="nav-text">MapReduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多层划分"><span class="nav-number">1.7.</span> <span class="nav-text">多层划分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题实例"><span class="nav-number">1.7.1.</span> <span class="nav-text">问题实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitmap"><span class="nav-number">1.8.</span> <span class="nav-text">Bitmap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用"><span class="nav-number">1.8.1.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题实例-1"><span class="nav-number">1.8.2.</span> <span class="nav-text">问题实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bloom-Filter（布隆过滤器）"><span class="nav-number">1.9.</span> <span class="nav-text">Bloom Filter（布隆过滤器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#集合表示和元素查询"><span class="nav-number">1.9.1.</span> <span class="nav-text">集合表示和元素查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布隆过滤器添加元素"><span class="nav-number">1.9.2.</span> <span class="nav-text">布隆过滤器添加元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布隆过滤器查询元素"><span class="nav-number">1.9.3.</span> <span class="nav-text">布隆过滤器查询元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用-1"><span class="nav-number">1.9.4.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题实例-2"><span class="nav-number">1.9.5.</span> <span class="nav-text">问题实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Trie树"><span class="nav-number">1.10.</span> <span class="nav-text">Trie树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题实例-3"><span class="nav-number">1.10.1.</span> <span class="nav-text">问题实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库"><span class="nav-number">1.11.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法介绍"><span class="nav-number">1.11.1.</span> <span class="nav-text">方法介绍</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">2.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最大连续乘积子串"><span class="nav-number">2.1.</span> <span class="nav-text">最大连续乘积子串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分析与解法"><span class="nav-number">2.1.1.</span> <span class="nav-text">分析与解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三"><span class="nav-number">2.1.2.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串编辑距离"><span class="nav-number">2.2.</span> <span class="nav-text">字符串编辑距离</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分析与解法-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">分析与解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">举一反三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题扩展"><span class="nav-number">2.2.3.</span> <span class="nav-text">问题扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格子取数问题"><span class="nav-number">2.3.</span> <span class="nav-text">格子取数问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交替字符串"><span class="nav-number">2.4.</span> <span class="nav-text">交替字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述"><span class="nav-number">2.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析与解法-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">分析与解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序员如何准备面试中的算法"><span class="nav-number">3.</span> <span class="nav-text">程序员如何准备面试中的算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导读"><span class="nav-number">4.1.</span> <span class="nav-text">导读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旋转字符串"><span class="nav-number">4.2.</span> <span class="nav-text">旋转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串包含"><span class="nav-number">4.3.</span> <span class="nav-text">字符串包含</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-3"><span class="nav-number">4.3.2.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串转换成整数"><span class="nav-number">4.4.</span> <span class="nav-text">字符串转换成整数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-2"><span class="nav-number">4.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-4"><span class="nav-number">4.4.2.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回文判断"><span class="nav-number">4.5.</span> <span class="nav-text">回文判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长回文子串"><span class="nav-number">4.6.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的全排列"><span class="nav-number">4.7.</span> <span class="nav-text">字符串的全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-3"><span class="nav-number">4.7.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析与解法-3"><span class="nav-number">4.7.2.</span> <span class="nav-text">分析与解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法总结"><span class="nav-number">4.7.3.</span> <span class="nav-text">解法总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类似问题"><span class="nav-number">4.7.4.</span> <span class="nav-text">类似问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">5.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找最小的k个数"><span class="nav-number">5.1.</span> <span class="nav-text">寻找最小的k个数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-4"><span class="nav-number">5.1.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一"><span class="nav-number">5.2.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法二"><span class="nav-number">5.3.</span> <span class="nav-text">解法二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法三"><span class="nav-number">5.4.</span> <span class="nav-text">解法三</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法四"><span class="nav-number">5.5.</span> <span class="nav-text">解法四</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-5"><span class="nav-number">5.5.1.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找和为定值的两个数"><span class="nav-number">5.6.</span> <span class="nav-text">寻找和为定值的两个数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-5"><span class="nav-number">5.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析与解法-4"><span class="nav-number">5.6.2.</span> <span class="nav-text">分析与解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一-1"><span class="nav-number">5.6.3.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二-1"><span class="nav-number">5.6.4.</span> <span class="nav-text">解法二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法三-1"><span class="nav-number">5.6.5.</span> <span class="nav-text">解法三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法总结-1"><span class="nav-number">5.6.6.</span> <span class="nav-text">解法总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题扩展-1"><span class="nav-number">5.6.7.</span> <span class="nav-text">问题扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-6"><span class="nav-number">5.6.8.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找和为定值的多个数"><span class="nav-number">5.7.</span> <span class="nav-text">寻找和为定值的多个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-6"><span class="nav-number">5.8.</span> <span class="nav-text">题目描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二-没懂-有时间再看"><span class="nav-number">5.8.1.</span> <span class="nav-text">解法二 没懂 有时间再看</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#0-1-背包问题（背景介绍）"><span class="nav-number">5.8.2.</span> <span class="nav-text">0-1 背包问题（背景介绍）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-7"><span class="nav-number">5.8.3.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大连续子数组和"><span class="nav-number">5.9.</span> <span class="nav-text">最大连续子数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-7"><span class="nav-number">5.9.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一-2"><span class="nav-number">5.9.2.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二-2"><span class="nav-number">5.9.3.</span> <span class="nav-text">解法二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问题扩展-2"><span class="nav-number">5.9.4.</span> <span class="nav-text">问题扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-8"><span class="nav-number">5.9.5.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳台阶问题"><span class="nav-number">5.10.</span> <span class="nav-text">跳台阶问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-8"><span class="nav-number">5.10.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二-3"><span class="nav-number">5.10.2.</span> <span class="nav-text">解法二</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举一反三-9"><span class="nav-number">5.11.</span> <span class="nav-text">举一反三</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#奇偶排序"><span class="nav-number">5.12.</span> <span class="nav-text">奇偶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-9"><span class="nav-number">5.12.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析与解法-5"><span class="nav-number">5.12.2.</span> <span class="nav-text">分析与解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-10"><span class="nav-number">5.12.3.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#荷兰国旗"><span class="nav-number">5.13.</span> <span class="nav-text">荷兰国旗</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-10"><span class="nav-number">5.13.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析与解法-6"><span class="nav-number">5.13.2.</span> <span class="nav-text">分析与解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法"><span class="nav-number">5.13.3.</span> <span class="nav-text">解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-11"><span class="nav-number">5.13.4.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵相乘"><span class="nav-number">5.14.</span> <span class="nav-text">矩阵相乘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-11"><span class="nav-number">5.14.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析与解法-7"><span class="nav-number">5.14.2.</span> <span class="nav-text">分析与解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一-暴力解法"><span class="nav-number">5.14.3.</span> <span class="nav-text">解法一 暴力解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二-Strassen-算法"><span class="nav-number">5.14.4.</span> <span class="nav-text">解法二 Strassen 算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完美洗牌算法"><span class="nav-number">5.15.</span> <span class="nav-text">完美洗牌算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目详情"><span class="nav-number">5.15.1.</span> <span class="nav-text">题目详情</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-树"><span class="nav-number">6.</span> <span class="nav-text">第三章 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本章导读"><span class="nav-number">6.1.</span> <span class="nav-text">本章导读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树"><span class="nav-number">6.2.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B树"><span class="nav-number">6.3.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最近公共祖先LCA问题"><span class="nav-number">6.4.</span> <span class="nav-text">最近公共祖先LCA问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题描述"><span class="nav-number">6.4.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一-暴力对待"><span class="nav-number">6.4.2.</span> <span class="nav-text">解法一 暴力对待</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二：Tarjan算法"><span class="nav-number">6.4.3.</span> <span class="nav-text">解法二：Tarjan算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1、什么是Tarjan算法"><span class="nav-number">6.4.4.</span> <span class="nav-text">2.1、什么是Tarjan算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2、Tarjan算法如何而来"><span class="nav-number">6.4.5.</span> <span class="nav-text">2.2、Tarjan算法如何而来</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3、Tarjan算法流程"><span class="nav-number">6.5.</span> <span class="nav-text">2.3、Tarjan算法流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-查找匹配"><span class="nav-number">7.</span> <span class="nav-text">第四章 查找匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有序数组的查找"><span class="nav-number">7.1.</span> <span class="nav-text">有序数组的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-12"><span class="nav-number">7.1.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行列递增矩阵的查找"><span class="nav-number">7.2.</span> <span class="nav-text">行列递增矩阵的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-13"><span class="nav-number">7.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-12"><span class="nav-number">7.2.2.</span> <span class="nav-text">举一反三</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#出现次数超过一半的数字"><span class="nav-number">7.3.</span> <span class="nav-text">出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#题目描述-14"><span class="nav-number">7.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一-3"><span class="nav-number">7.3.2.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二-4"><span class="nav-number">7.3.3.</span> <span class="nav-text">解法二</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法四-1"><span class="nav-number">7.4.</span> <span class="nav-text">解法四</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举一反三-13"><span class="nav-number">7.4.1.</span> <span class="nav-text">举一反三</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YDE</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
