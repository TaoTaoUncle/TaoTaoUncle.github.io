<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Note,Network,">










<meta name="description" content="计算机网络 TCP和UDP的区别  IP首部 TCP首部 UDP首部 TCP和UDP的区别 TCP和UDP的应用场景 如何实现可靠的UDP   其中网络接口对应：物理层和数据链路层（数据链路层又包括逻辑链路子层和介质链路子层）  链路层（或者说物理层） 包括操作系统中的驱动程序和计算机网卡还有传输的物理介质，链路层上面的主要协议有以太网协议。 其中，MAC地址集成在网卡  网络层 保证数据从一台主">
<meta name="keywords" content="Note,Network">
<meta property="og:type" content="article">
<meta property="og:title" content="Network_Start_2019Fall">
<meta property="og:url" content="http://yoursite.com/2019/09/29/Network_Start_2019Fall/index.html">
<meta property="og:site_name" content="YDE&#39;s Daily">
<meta property="og:description" content="计算机网络 TCP和UDP的区别  IP首部 TCP首部 UDP首部 TCP和UDP的区别 TCP和UDP的应用场景 如何实现可靠的UDP   其中网络接口对应：物理层和数据链路层（数据链路层又包括逻辑链路子层和介质链路子层）  链路层（或者说物理层） 包括操作系统中的驱动程序和计算机网卡还有传输的物理介质，链路层上面的主要协议有以太网协议。 其中，MAC地址集成在网卡  网络层 保证数据从一台主">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://img-blog.csdn.net/20170331142210728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170331150253865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://yoursite.com/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-08-02%20at%203.46.03%20PM.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170331153055591?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170331155951178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170331202913007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170331203535314?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170401144207398?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170401184822495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170401190108230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170401202825482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170409111209254?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170410161603387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2019-09-30T06:54:55.717Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Network_Start_2019Fall">
<meta name="twitter:description" content="计算机网络 TCP和UDP的区别  IP首部 TCP首部 UDP首部 TCP和UDP的区别 TCP和UDP的应用场景 如何实现可靠的UDP   其中网络接口对应：物理层和数据链路层（数据链路层又包括逻辑链路子层和介质链路子层）  链路层（或者说物理层） 包括操作系统中的驱动程序和计算机网卡还有传输的物理介质，链路层上面的主要协议有以太网协议。 其中，MAC地址集成在网卡  网络层 保证数据从一台主">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170331142210728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/29/Network_Start_2019Fall/">





  <title>Network_Start_2019Fall | YDE's Daily</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YDE's Daily</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Welcome here!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/29/Network_Start_2019Fall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YDE">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YDE's Daily">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Network_Start_2019Fall</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-29T19:29:20+08:00">
                2019-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/201909/" itemprop="url" rel="index">
                    <span itemprop="name">201909</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul>
<li><p>TCP和UDP的区别</p>
<ol>
<li>IP首部 TCP首部 UDP首部</li>
<li>TCP和UDP的区别</li>
<li>TCP和UDP的应用场景</li>
<li>如何实现可靠的UDP</li>
</ol>
<p><img src="https://img-blog.csdn.net/20170331142210728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<p>其中网络接口对应：物理层和数据链路层（数据链路层又包括逻辑链路子层和介质链路子层）</p>
<ul>
<li><p><strong>链路层（或者说物理层）</strong></p>
<p>包括操作系统中的<strong>驱动程序</strong>和<strong>计算机网卡</strong>还有<strong>传输的物理介质</strong>，链路层上面的<strong>主要协议有以太网协议</strong>。</p>
<p>其中，<strong>MAC地址集成在网卡</strong></p>
</li>
<li><p><strong>网络层</strong></p>
<p>保证<strong>数据从一台主机将数据准确的发送到另一台指定的主机</strong>，主要通过指定<strong>IP地址（点分十进制）和端口号（表明应用程序）</strong>来实现，主要的协议有IP协议，ICMP和IGMP作为辅助协议。<strong>路由器属于网络层</strong>。</p>
<p><strong>主机 —&gt; 主机</strong> </p>
<p>点分十进制是一个表达数字数据的形式。 其形式为用句点（.） 分隔的多个十进制数。 将其每8位分为一组，转换为十进制，分别得到127、0、0和1，再将这四个十进制数之间以句点连接，即为127.0.0.1。</p>
</li>
<li><p><strong>传输层</strong></p>
<p><strong>网络层</strong>提供了一种<strong>不可靠的服务</strong>，它只是尽可能快把分组从源端口发送到目的窗口，但是并<strong>不能保证能毫发无损</strong>地<strong>准时</strong>送到</p>
<p>而传输层则利用TCP，UDP协议来保证传输。TCP采用<strong>超时重传，发送</strong>和<strong>接收端分组</strong>等机制来实现可靠传输。主要协议有TCP，UDP，TCP数据和UDP数据基本一致，唯一的区别是UDP传给IP的协议的信息单元称为UDP数据报。</p>
</li>
<li><p><strong>应用层</strong></p>
<p>负责应用程序的具体需求，主要协议有FTP，TELNET，HTTP，HTML，STMP，POP，IMAP，DNS等</p>
</li>
</ul>
<p>MAC地址——物理层</p>
<p>IP地址——网络层</p>
<p>TCP——传输层</p>
<p>HTTP——应用层</p>
<p><strong>IP 地址</strong></p>
<p>网络上<strong>每一个节点</strong>都必须有一个<strong>独立的 IP 地址</strong>，通常使用的 IP 地址是一个 32bit 的数字，被 . 分成 4 组，例如，255.255.255.255 就是一个 IP 地址。<br>有了 IP 地址，用户的计算机就可以发现并连接互联网中的另外一台计算机。</p>
<p><strong>域名（主机名）</strong></p>
<p>用 12 位数字组成的 IP 地址很难记忆，在实际应用时，用户一般不需要记住 IP 地址，互联网给每个 <strong>IP 地址</strong>起了一个<strong>别名</strong>，习惯上称作<strong>域名</strong>。</p>
<p><strong>域名与计算机的 IP 地址相对应</strong>，并把这种<strong>对应关系存储在</strong>域名服务系统 <strong>DNS</strong>(Domain Name System)中，这样用户只需记住域名就可以与指定的计算机进行通信了</p>
<p><strong>数据链路层</strong></p>
<ul>
<li>实现计算机的<strong>二进制数据</strong>与物理介质中的<strong>光或电信号的转化</strong>；</li>
<li>将数据分装为帧，<strong>帧</strong>是数据在<strong>链路层传送的单位</strong>；</li>
<li><strong>控制帧的传输</strong>，校验数据是否完整；</li>
<li>将数据<strong>从一个硬件实体</strong>传输<strong>到另一个硬件实体</strong>；</li>
</ul>
<p>数据链路层最重要的<strong>两个概念</strong>——<strong>mac地址</strong>和<strong>分组交换</strong></p>
<p><strong>mac地址</strong><br>mac地址是网卡的物理地址，mac地址在出厂时都是唯一的。mac地址是数据在链路层传输时使用的地址。对于mac地址获取是通过发送arp包实现。</p>
<p><strong>分组交换</strong></p>
<p>分组交换是指将较大的数据分割为若干个较小的数据，然后依次发送。</p>
<p>原因：不同的数据链路有各自的最大传输单元(MTU: Maximum Transmission Unit)。针对不同的MTU，我们分割的方法也不一样</p>
<p>以以太网(一种数据链路)为例，它的MTU是 1500 字节，也就是通过以太网传输的数据，必须<strong>分割为若干帧</strong>，每个帧的数据长度不超过 1500 字节。如果上层传来的数据超过这个长度，数据链路层需要分割后再发送。</p>
<p><strong>以太网帧</strong></p>
<p><img src="https://img-blog.csdn.net/20170331150253865?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>以太网帧的开头是“前导码(Preamble)”，长度为 8 字节，这一段没什么用，重点在于以太网帧的本体。<br>本体由首部，数据和，FCS 三部分组成：</p>
<p><strong>首部</strong><br><strong>以太网首部包括目标mac地址，源mac地址和类型</strong>。</p>
<p>类型<br>类型部分存储了上层协议的编号，比如上层是 IP 协议，则编号为 0800，ARP协议为0806。</p>
<p>FCS<br>FCS 表示帧校验序列(Frame Check Sequence)，用于判断帧是否在传输过程中有损坏(比如电子噪声干扰)。FCS 保存着发送帧除以某个多项式的余数，接收到的帧也做相同计算，如果得到的值与 FCS 相同则表示没有出错。</p>
<p><strong>交换机</strong><br>交换机是一种在<strong>数据链路层工作</strong>的网络设备，它有<strong>多个端口，可以连接不同的设备</strong>。交换机<strong>根据每个帧中的目标 MAC 地址</strong>决定向哪个端口发送数据，此时它需要<strong>参考“转发表”</strong></p>
<p>转发表并非手动设置，而是交换机自动学习得到的。当某个设备向交换机发送帧时，交换机将帧的源 MAC 地址和接口对应起来，作为一条记录添加到转发表中</p>
<p><strong>全双工与半双工通信</strong></p>
<p> 全双工通信是指可以同时接受数据和发送数据，而半双工是指可以发送数据也可以接受数据，但是两者不能同时进行，实际是采用了单工的通信方式进行分时通信。</p>
<p><strong>网络层</strong><br>简单的理解为一个寄快递的过程，从<strong>源ip地址到目标ip地址</strong></p>
<p>网络层可以简单的理解为一个寄快递过程：源IP地址就是寄件人的地址，目标IP地址就是收件人的地址。IP地址被分成几类，好比快递地址被分成多个省，但是省这个范围太大了，不好找到收件人的具体位置，于是就将省划分为很多市县，这就好比IP划分子网的过程。IP选路过程和快递的发送过程是一样的。假设快递要从A省M市，发往C省N市。快递从A省M市出发，到了A省中转站，发往了B省中转站，然后和目的地址比较，发现不是目的省份，继续往前走。发送到C省中转站，发现是目标省份，继续发送到具体市县的中转站，知道找到N市。<strong>每一个中转站就好比一个路由器，每一站的转发就是一跳。</strong>在发送的过程中发现，包裹太大，每辆车载重有限额的。为了避免超载，于是将包裹分成几车来运输。但是每个司机都按照自己的想法去运送货物，因此他们走的路线可能不一样，有的走了国道被堵死，有的走了高速爽的不行，但是最终都会到达目的地，只是先出发的车不定能先到。所以，在发车前给每辆车按照发车顺序贴了一个序号标签。最后到达目的地后就按车的标签顺序卸货。这其中，车的载重量就好比MTU，<strong>分车装载的过程就好比分片</strong>过程，<strong>车的序号标签好比片偏移</strong>。</p>
<p>几个重要的概念：<strong>路由器</strong> <strong>跳</strong> <strong>分片</strong> <strong>片偏移</strong> <strong>MTU</strong></p>
<p>mac地址：没有规律可循</p>
<p>ip地址：有规律可循 有网络 子网 主机的一级一级的概念 类似于国家/省/市</p>
<p>所以我们<strong>在前面跳的时候使用ip寻址</strong>，<strong>最后一跳使用MAC寻址</strong></p>
<p>ip地址的表示方法：32位 点分十进制</p>
<p>ip地址由<strong>两部分组成</strong>——<strong>网络标识</strong> 和 <strong>主机标识</strong></p>
<p>网络标识：不同网段</p>
<p>主机标识：同一网段下的不同主机，同一网段中不能重复出现</p>
<p>根据<strong>网络段所占位数和主机位数的不同</strong>，氛围ABCD四类，具体如下</p>
<p><img src="/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-08-02%20at%203.46.03%20PM.png" alt="Screen Shot 2019-08-02 at 3.46.03 PM"></p>
<p>这种<strong>固定数目的分类方法</strong>，会造成<strong>IP地址的极大浪费</strong></p>
</li>
</ul>
<p>  这时我们引入<strong>子网掩码</strong></p>
<p>  子网掩码：一段<strong>连续的1</strong>和一段<strong>连续的0</strong>组成，用来<strong>和ip地址按位与</strong></p>
<p>  <img src="https://img-blog.csdn.net/20170331153055591?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  通过<strong>子网掩码</strong>，从<strong>主机位借位给网络位</strong>，这样就<strong>扩大了网络标识</strong></p>
<p>  也可以把借的部分称为<strong>子网位</strong></p>
<p>  <strong>相当于子网掩码重新分配了网络位和主机位 更加灵活</strong></p>
<p>  但是由于通用的还是ABCD，所以我们<strong>需要加个后缀来表示子网掩码</strong></p>
<p>  直观上来看，子网掩码的借位效果，就如同产生了几个<strong>子网</strong>，可以看作是：网络+子网+主机</p>
<p>  <strong>IP路由控制</strong></p>
<p>  对于目前庞大的网络结构，不可能直接相连，而是采用<strong>路由器组建起来的网络拓扑结构</strong></p>
<p>  这样 如何将<strong>数据发往指定的ip地址呢</strong></p>
<p>  ps：MAC寻址是由交换机来完成的，ip寻址是由路由器来完成的</p>
<p>  主机和路由器内部<strong>都有</strong>一张<strong>路由表</strong></p>
<p>  <strong>路由表的搜索过程</strong></p>
<ul>
<li>搜索路由表，如果能找到和目的 IP 地址完全一致的主机，则将 IP 数据报发向该主机；</li>
<li>搜索路由表，如果匹配主机失败，则匹配同子网的路由器(这需要子网掩码的协助)。如果找到路由器，则将 IP 该数据报发向该路由器；</li>
<li>搜索路由表，如果匹配同子网路由器失败，则匹配同网络号路由器，如果找到路由器，则将该 IP 数据报发向该路由器；</li>
<li>如果以上都失败了，就搜索默认路由，如果默认路由存在，则发送给默认路由；</li>
<li>如果都失败了，就丢弃这个包，然后发送一份主机不可达的ICMP报文给源IP地址；</li>
<li>接收到数据报的路由器再按照它自己的路由表继续转发，直到数据报被转发到目的主机；</li>
<li>如果在转发过程中，IP 数据报的 TTL（生命周期）已经被减为 0，则该 IP 数据报就被抛弃，然后发送超时的ICMP报文给源IP地址主机。</li>
</ul>
<p>  <strong>路由表</strong>：<strong>ip地址到路由器地址的映射</strong>，意即如果路由表有这个ip地址，我们就跳到该ip地址对应的路由器</p>
<p>  <strong>简单总结上述的搜索过程</strong></p>
<ul>
<li>先匹配主机ip地址 ，如果有，发送对应路由器 ，没有接下</li>
<li>再匹配子网ip地址，即同子网的路由器 ，如果有，发送，没有接下</li>
<li>再 匹配网络ip地址，即同网络路由器，如果有，发送，没有接下</li>
<li>以上都失败，搜索<strong>默认路由</strong>，存储，发送，没有接下</li>
<li>都失败了——<strong>丢弃这个包</strong>，发送一份<strong>主机不可达的ICMP报文</strong>给<strong>源IP地址</strong></li>
<li><strong>接上</strong>，这时候收到数据报的路由器按照他<strong>自己的路由表继续转发</strong>，<strong>直到</strong>数据报转<strong>发到目的主机</strong></li>
<li><strong>接上</strong>，如果在转发过程中，IP 数据报的 TTL（生命周期）已经被减为 0，则该 IP 数据报就被抛弃，然后发送超时的ICMP报文给源IP地址主机。</li>
</ul>
<p>  <strong>分片与重组</strong></p>
<p>  发送数据太大，超过以太网的MTU，需要分片，<strong>独立寻径</strong>。</p>
<p>  但是<strong>只有第一个分片，包含了传输层的首部</strong></p>
<p>  如何重组：重组<strong>只在最终目的主机进行</strong>。依靠I<strong>P首部中的16位标识和片偏移，实现重组</strong>。只有同<strong>属于一个包的片</strong>才具有<strong>相同的16位标识</strong>。</p>
<p>  如果<strong>一个分片丢失 整个数据报作废</strong>，因为<strong>网络层没有重传机制</strong>，只能<strong>由上层协议实现</strong></p>
<p>  <strong>路径MTU</strong><br>  分片会加重路由器的负担，因此只要条件允许，我们都不希望路由器对IP数据包进行分片处理。另外，如果一个分片丢失，整个IP数据报都会作废，因为网络层没有重传机制，只能由上层协议实现。</p>
<p>  解决以上问题的技术是“路径MTU发现”。主机会首先获取整个路径中所有数据链路的最小MTU，并按照整个大小将数据分片。因此传输过程中的任何一个路由器都不用进行分片工作。</p>
<p>  为了找到路径MTU，主机首先发送整个数据包，并将IP首部的禁止分片标志设为1.这样路由器在遇到需要分片才能处理的包时不会分片，而是直接丢弃数据并通过ICMP协议将整个不可达的消息发回给主机。</p>
<p>  主机将ICMP通知中的MTU设置为当前MTU，根据整个MTU对数据进行分片处理。如此反复下去，直到不再收到ICMP通知，此时的MTU就是路径MTU。</p>
<p>  <strong>路径MTU简介</strong>：</p>
<p>  为了不让路由器分片，我们主机提前吧数据分片好，这时分片对应的大小就是<strong>路径MTU</strong>。</p>
<p>  <strong>不断尝试的过程</strong>，直至找到整个路径MTU</p>
<p>  将IP首部的禁止分片设置为1，这样路由器在需要分片才能处理的包时候不会分片，而是通过ICMP协议发送给主机<strong>数据不可达</strong>的消息。这样主机会按照这个消息里的MTU来对数据分片，并在此发送，<strong>直至没有数据不可达</strong>的消息传回。此时对应的MTU就是路径MTU</p>
<p>  <strong>关于IP报文的组成</strong></p>
<p>  <img src="https://img-blog.csdn.net/20170331155951178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  版本（Version）：由四位bit构成，表示IP的版本信息，如IPv4的版本号为4</p>
<p>  首部长度：表示IP首部的字节长度，如果没有可选字段，则首部长度为20字节</p>
<p>  区分服务：表示服务质量，如延时，吞吐量等</p>
<p>  总长度(Total Length)：表示IP首部与数据部分总的字节数，该段长16比特，所以IP包的最大长度为65535字节(2^16)。虽然不同数据链路的MTU不同，但是IP协议屏蔽了这些区别，通过自己实现的数据分片功能，从上层的角度来看，IP协议总是能够以65535为最大包长进行传输。</p>
<p>  标识（ID：Identification）：用于分片重组。属于同一个分片的帧的ID相同。但即使ID相同，如果目标地址、源地址、上层协议中有任何一个不同，都被认为不属于同一个分片。</p>
<p>  标志（Flags）：由于分片重组，由三个比特构成。</p>
<p>  第一个比特未使用，目前必须是0。</p>
<p>  第二个比特表示是否进行分片，0表示可以分片，1表示不能分片。在路径MTU发现技术中就用到了这个位。</p>
<p>  第三个比特表示在分片时，是否表示最后一个包。1表示不是最后一个包，0表示分配中最后一个包。</p>
<p>  片偏移（FO: Fragment Offset）：由13比特组成，表示被分片的段相对于原始数据的位置。它可以表示8192(2^13)个位置，单位为8字节，所以最大可以表示8 x 8192 = 65536字节的偏移量。</p>
<p>  生存时间（TTL: Time To Live）：表示包可以经过多少个路由器的中转。每经过一个路由器，TTL减1。这样可以避免前文提到的无限传递包的问题。</p>
<p>  协议： 表示IP协议的上层协议使用了哪个协议。比如TCP协议的编号为6，UDP编号为17.</p>
<p>  首部校验和：用于检查IP首部是否损坏</p>
<p>  可选项：仅在试验或诊断时用，可以没有。如果有，需要配合填充（Padding）占满32比特。</p>
<p>  <strong>传输层</strong></p>
<p>  首先，需要传输层的原因/或者说实现了什么</p>
<ol>
<li><p>IP协议不可靠的传输，<strong>数据丢包 数据损害</strong>，IP协议并<strong>不能</strong>提供<strong>解决</strong>办法</p>
</li>
<li><p>应该<strong>由哪个应用程序来接受这个数据包</strong>呢？IP协议没有办法告诉我们</p>
<p>传输层协议有TCP和UDP</p>
<p>TCP是<strong>面向有连接的协议</strong>，也就是<strong>传输数据之前</strong>要在发方和收方之间<strong>先建立连接</strong></p>
<p>一般<strong>建立连接需要三步</strong>，<strong>关闭连接需要四步</strong></p>
</li>
</ol>
<p>  <strong>TCP概述：</strong> TCP 协议是面向有连接的协议，还有数据重传、流量控制等功能，TCP 协议能够正确处理丢包问题，保证接收方能够收到数据，与此同时还能够有效利用网络带宽。然而 TCP 协议中定义了很多<strong>复杂的规范</strong>，因此<strong>效率不如 UDP 协议</strong>，<strong>不适合实时</strong>的视频和音频传输。</p>
<p>  <strong>UDP概述：</strong> UDP 协议是面向无连接的协议，它只会把数据传递给接收端，但是<strong>不会关注接收端是否真的收到了数据</strong>。但是这种特性反而<strong>适合</strong>多播，<strong>实时的视频和音频</strong>传输。因为<strong>个别数据包的丢失并不会影响视频和音频的整体效果</strong>。</p>
<p>  在<strong>IP</strong>中，两大关键要素就是<strong>源IP地址和目标IP地址</strong></p>
<p>  而传输层主要实现<strong>应用程序之间的通信</strong> ，增加了<strong>两个要素</strong>，<strong>源端口号和目标端口号</strong> 再加上<strong>IP首部中的协议号</strong>，</p>
<p>  这五个元素，可以<strong>唯一识别一个通信</strong>——<strong>源IP地址 目标IP地址 源端口号 IP端口号 协议号</strong></p>
<p>  这五个信息<strong>只要有一个不同，都认为是不同的通信</strong></p>
<p>  <strong>端口号</strong>：作用是用于区分<strong>同一台主机</strong>中正在通信的<strong>不同应用程序</strong>，因此也被称为<strong>程序地址</strong>。</p>
<p>  <strong>分为两种：</strong> </p>
<ol>
<li><p>知名端口号：这种端口号是固定的，用于服务器程序，使用对应协议的程序就将端口号设为对应的数字。比如DNS的端口号就是53. </p>
</li>
<li><p>动态端口号：这种端口号是不固定的，用于客户端程序，客户端程序对端口号要求不高，只要该端口号在本机中唯一就行。</p>
<table>
<thead>
<tr>
<th>端口号</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>53</td>
<td>DNS</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
</tr>
<tr>
<td>20</td>
<td>FTP数据</td>
</tr>
<tr>
<td>21</td>
<td>FTP控制</td>
</tr>
<tr>
<td>23</td>
<td>SSH</td>
</tr>
<tr>
<td>25</td>
<td>SMTP</td>
</tr>
</tbody></table>
<p>TCP和UDP的<strong>区别</strong>：</p>
</li>
<li><p>TCP基于有连接，UDP基于无连接（就是<strong>UDP</strong>在发送数据之前，并<strong>不考虑对方能否接收到</strong>，甚至<strong>目的地址可能是无效</strong>）</p>
</li>
<li><p>TCP可以保证可靠传输，UDP不能保证可靠传输。</p>
</li>
<li><p>TCP结构复杂，<strong>消耗资源多</strong>，<strong>建立过程慢 复杂</strong>。</p>
<p>UDP结构<strong>简单</strong>，消耗资源少，<strong>建立过程快</strong></p>
</li>
<li><p><strong>TCP基于流模式</strong>，<strong>UDP基于数据报模式</strong>。</p>
<p>TCP可以通过<strong>发送缓冲区和接受缓冲区</strong>来存储数据流，没有边界，一段传输</p>
<p>UDP<strong>每一个数据报都是一个独立对象</strong>，有着<strong>指定大小</strong>。</p>
</li>
<li><p><strong>TCP连接只能是点到点，而UDP可以一对一，一对多或者多对多</strong>。TCP<strong>只能是点到点</strong>原因很简单，因为T<strong>CP的传输前要先建立连接</strong>。因此，广<strong>播和多播只能采用UDP数据报</strong>的方式。</p>
</li>
<li><p><strong>TCP有确认，重传，拥赛控制机制，UDP在没有建立连接或者对方已经退出的情况下任然会继续发送数据，导致通信流量的浪费</strong>。</p>
<p>TCP和UDP的<strong>用途</strong>：</p>
<p>TCP：用于实现<strong>可靠传输</strong>的情况，文件<strong>非常重要</strong>，对网络拥堵有较高要求的情况。</p>
<p>UDP： </p>
</li>
<li><p>用于高速传输和实时性较高的场合（<strong>即时通信</strong>）。对于采用UDP的实事视频通信，如果出现丢包也只会出现短暂卡顿，但是如果采用TCP丢包后需要重发，会导致很长时间的卡顿。 </p>
</li>
<li><p><strong>包总量较少</strong>的通信（DNS），<strong>客户端较多</strong> </p>
</li>
<li><p><strong>广播通信</strong></p>
</li>
</ol>
<p>  <strong>UDP</strong>首部</p>
<p>  <img src="https://img-blog.csdn.net/20170331202913007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<ul>
<li><strong>源端口号</strong>：表示发送端端口号，不需要时设为0</li>
<li><strong>目标端口号：</strong>表示接收端端口号</li>
<li><strong>包长度：</strong>表示整个UDP包的长度</li>
<li><strong>校验和：</strong>为了提供可靠的UDP首部和数据而设计，只要源IP地址，目标IP地址，源端口号，目标端口号，协议号有一个发生了篡改校验和都会不正确。</li>
</ul>
<p>  <strong>TCP</strong>首部</p>
<p>  <img src="https://img-blog.csdn.net/20170331203535314?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  源端口号：发送端端口号<br>  目标端口号：接受端端口号<br>  序列号：发送数据时，表示<strong>发送数据的位置</strong>，<strong>发送完一次</strong>数据后，序列号的值都<strong>等于原来的</strong>序列号<strong>加上数据的长度</strong><br>  应答号：用于<strong>接受端告诉发送端下次应该从哪个位置开始发送</strong>，表示前面的数据已经都收到了<br>  数据偏移：实际就是TCP首部长度<br>  保留：一般设置为0，用于后续扩展<br>  <strong>控制位</strong>：长度为8，从左到右分别是CWR，ECE，URG，<strong>ACK</strong>，PSH，RST，<strong>SYN</strong>，FIN<br>  窗口大小：能够发送数据的最大值，为0时可以发送探测窗口<br>  校验和：与UDP校验和作用相同<br>  紧急指针：用于处理紧急情况<br>  选项：其他控制设置</p>
<p>  <strong>如何实现可靠的UDP</strong></p>
<p>  solution：<strong>在应用层模仿TCP</strong></p>
<ol>
<li><p>添加seq/ack机制，确保数据发送到端</p>
</li>
<li><p>添加发送和接受缓冲区，主要是用户超时重传</p>
</li>
<li><p>添加超时重传机制</p>
<p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
</li>
</ol>
<p>  <strong>TCP三次握手和四次握手</strong></p>
<p>  TCP保证可靠传输的控制协议和算法：</p>
<ul>
<li>连接管理——三次和四次握手</li>
<li>数据破坏——通过校验和</li>
<li>丢包——应答和超时重发机制</li>
<li>分片乱序——序列号</li>
<li>窗口滑动——提高发送效率，对发送端和接受端流量进行控制</li>
<li>加快通信速度——快速重发，三次收到重发消息进行重发</li>
<li>流控制——避免网络流量浪费</li>
<li>拥塞控制——慢启动算法，拥塞窗口</li>
</ul>
<p>  <strong>TCP中的确认应答机制</strong><br>  在TCP中当发送端的数据达到接受主机时，接受主机端都会返回一个消息，<strong>告诉对方我已经收到了</strong>。这个消息叫<strong>确认应答</strong>。发送确认应答时，<strong>TCP首部中的ACK标志位设1</strong>。</p>
<p>  通过 <strong>序列号</strong> 和 <strong>确认应答号</strong>来实现</p>
<p>  主机A发送第一个包时<strong>序列号为1，数据长度为1000</strong>，那么主机B收到包后发送一个数据包给主机A，在该包中将TCP首部中的<strong>32位确认号设为1001</strong>.相当于<strong>告诉对方</strong>1001之前的我都收到了，<strong>下次从1001开始发</strong></p>
<p>  <strong>经受时延的确认应答</strong></p>
<p>  为了<strong>降低确认应答包的数量</strong>，TCP提出了经受时延的确认应答。接受端在收到数据后<strong>并不立即发送一个应答数据包</strong>，<strong>而是等待一段时间，</strong>如果<strong>有新的数据被接受就更新应答号</strong>，如果<strong>有其他数据要发送就坐上该数据包的顺风车</strong>。在系统的内核中<strong>维持了一个定时器</strong>，一般是200ms<strong>如果定时器溢出，即使没有其他数据到达，也发送该应答数据包。</strong></p>
<p>  经受时延的目的，主要是为了在时延期间内能够搭上一个发送数据的顺风车，当然，这期间如果接受数据也要更新应答号</p>
<p>  <strong>Nagle算法</strong></p>
<p>   TCP是基于流的传输协议，在Rlogin和Telnet传输中会出现<strong>只有一个字节数据的TCP数据包</strong>。而一个<strong>TCP数据包的首部加上IP首部就有40个字节</strong>，很显然发这样的数据包<strong>划不来</strong>。为了减少这样的数据包，有人提出了Nagle算法。</p>
<p>  Nagle算法简单讲就是，等待服务器应答包到达后，再发送下一个数据包。<strong>数据在发送端被缓存</strong>，如果缓存<strong>到达指定大小就将其发送</strong>，<strong>或者上一个数据的应答包到达，将缓存区一次性全部发送</strong>。</p>
<p>  <strong>Nagle算法是从发送端角度考虑减少了数据包的个数</strong>，<strong>时延应答从接收端角度考虑减少了数据包的个数。</strong></p>
<p>  <strong>TCP的连接与断开（三次握手和四次握手）</strong></p>
<p>  <img src="https://img-blog.csdn.net/20170401144207398?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  <strong>建立连接</strong>——<strong>三次握手</strong></p>
<p>  <strong>建立连接</strong></p>
<p>  客户端发送请求包，告诉服务器：“我想和你通信？”数据包中SYN位置为1，假设其序列号为x，客户端状态变成SYN_SENT；<br>  服务器端接受到请求包后也发送一个请求包，告诉客户端：“现在可以建立连接”。数据包中SYN位置位1，假设其序列号为y，注意客户端序列号和服务器端序列号并没有关系，他们是由各自的内核按照一定的规则生成的。但是这个应答包的32位应答号，必须是x+1，之所以加1是因为客户端发过来的包SYN位被认为占一个数据。因此，告诉下一包从x+1开始发。发送后，服务器从监听状态变成SYN_RCVD状态。<br>  客户端发送应答数据包，告诉服务器：“那我们开始发送数据吧”。数据包应答号为y+1。客户端变成ESTABLISHED状态，即可以传输状态。<br>  服务器端接受到应答数据包后，变成ESTABLISHED状态。<br>  <strong>发送数据</strong></p>
<p>  客户端发送一个一个字节的数据，因此序列号为x+1；<br>  服务端发送一个应答包，应答号为x+2，告诉客户端下次从x+2开始发；</p>
<p>  <strong>断开连接——四次握手</strong></p>
<p>  <strong>断开连接</strong></p>
<p>  客户端发送请求断开的数据包，告诉服务器：“数据传完了，我要断开了”。发送一个FIN包，序列号x+2。客户端转移到FIN_WAIT_1状态。<br>  服务器端发送应答包，告诉客户端：“行，我知道了，你断开吧！”。应答号为x+3，服务器进入CLOSE_WAIT状态。客户端收到应答后，转移到FIN_WAIT_2状态。<br>  服务器发送一个断开数据包，告诉客户端：“既然传完了，那我这边的开关也准备关了”。序列号为y+1，发送完后服务器进入LAST_ACK状态。<br>  客户端发送一个应答包，告诉服务器：“好的，我知道你要断开了。”应答号为y+2。客户端进入TIME_WAIT状态。<br>  TIME_WAIT又称为2MSL等待状态，MSL是系统中定义的最大报文生存时间，任何TCP报文在网络中生存时间超过这个值就必须被丢弃。<br>  等待MSL的原因是防止最后一个ACK丢失后可以进行重发，如果ACK丢失后，服务器会重发FIN。</p>
<p>  <strong>总结</strong></p>
<p>  涉及到的<strong>首部部分</strong>：<strong>控制位SYN FIN</strong> 、<strong>序列号seq</strong> 、<strong>确认应答号ACK</strong></p>
<ul>
<li><p>TCP<strong>建立连接三次握手</strong></p>
<ol>
<li><p>客户端向服务端 发送 请求数据包，数据包中<strong>SYN置1</strong>，</p>
<p><strong>发送后 客户端状态</strong>变为<strong>SYN_SENT</strong>，假设<strong>序列号为x</strong></p>
</li>
<li><p>服务端接收到请求包后，也向客户端发送一个请求包，数据包中<strong>SYN置1</strong>，<strong>假设序列号为y</strong>，<strong>应答号为x+1</strong>，发送后服务器从<strong>监听状态变为SYN_RCVD状态</strong></p>
<p>ps：服务端和客户端的序列<strong>没有关联</strong>，由各自内核按照一定规则生成。但是应答号是根据对方的序列号和数据来的。</p>
</li>
<li><p>客户端向服务端发送 应答数据包，数据包<strong>应答号为y+1</strong>，由<strong>SYN_SENT变为ESTABLISHED状态</strong></p>
</li>
</ol>
</li>
<li><p><strong>建立连接后发送数据</strong></p>
<ol>
<li>客户端发送一个一个字节的数据，<strong>序列号为x+1</strong></li>
<li>服务端发送一个应答包，<strong>应答号为x+2</strong>，告诉客户端下次从x+2开始</li>
</ol>
</li>
<li><p>TCP<strong>断开连接四次握手</strong></p>
<ol>
<li><p>客户端发送请求数据包，<strong>FIN置1</strong>，序列号为<strong>x+2</strong>，发送后客户端变为<strong>FIN_WAIT_1</strong>状态</p>
</li>
<li><p>服务端发送应答包，<strong>序列号为y</strong>，<strong>应答号为x+3</strong>，发送后<strong>服务器进入CLOSE_WAIT</strong>状态</p>
<p>客户端收到应答后，转移到<strong>FIN_WAIT_2</strong>状态</p>
</li>
<li><p><strong>服务器发送一个断开数据包</strong>，序列号为<strong>y+1</strong>，发完后<strong>服务器进入LAST_ACK状态</strong></p>
</li>
<li><p><strong>客户端收到后发送一个应答包</strong>，<strong>应答号为y+2</strong>，客户端进入<strong>TIME_WAIT状态</strong></p>
<p>TIME_WAIT又称为2MSL等待状态，MSL是系统中定义的最大报文生存时间，任何TCP报文在网络中生存时间超过这个值就必须被丢弃。<br>等待MSL的原因是防止最后一个ACK丢失后可以进行重发，如果ACK丢失后，服务器会重发FIN。</p>
</li>
</ol>
<p>注意我们连接的时候SYN都是1，应答包时ACK=1，FIN包时FIN=1</p>
</li>
</ul>
<p>  <strong><em>这里需要补充一些知识</em></strong></p>
<p>  TCP层有个<strong>FLAGS字段</strong>，包括这几个标识：</p>
<p>  <strong>SYN</strong> <strong>FIN</strong> <strong>ACK</strong> ** PSH RST URG**</p>
<p>  SYN：表示建立连接</p>
<p>  FIN：表示关闭连接</p>
<p>  ACK：表示响应</p>
<p>  PSH：表示有DATA数据传输</p>
<p>  RST：表示连接重置</p>
<p>  ACK可以与SYN/FIN同时使用，比如SYN和ACK同时为1，表示的就是建立连接之后的响应</p>
<p>  单一的一个SYN 表示的只是建立连接</p>
<p>  TCP的几次握手，就是通过这样的ACK表现出来（和SYN同时为1的ACK）</p>
<p>  <strong>SYN和FIN时不会同时为1</strong>，一个表示建立连接，一个表示断开连接</p>
<p>  RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。</p>
<p>   一般地，当出现FIN包<strong>或</strong>RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN<strong>和</strong>SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。</p>
<p>  <strong>PSH为1</strong>的情况，一般只出现在 <strong>DATA内容不为0</strong>的包中，也就是说PSH为1<strong>表示的是有真正的TCP数据包内容</strong>被传递。</p>
<p>  自己来一遍：</p>
<p>  三次握手建立连接：</p>
<p>  首先客户从CLOSED开始，服务器从LISTEN开始（CLOSED打开后到LISTEN）</p>
<ol>
<li><p>客户端发送SYN包，SYN=1，发送完后，客户端为SYN_SENT状态</p>
<p>序列号为x</p>
</li>
<li><p>服务端收到客户端发送的SYN包，发送SYN+ACK包给客户端，序列号为y，应答号为x+1，发送完后，服务端处于SYN_RCVD状态</p>
</li>
<li><p>客户端收到服务端发送的SYN+ACK包，发送ACK包给服务端，序列号为x+1，应答号为y+1，发送完后客户端处于ESTABLISHED状态。</p>
<p><strong>服务端收到客户端发送的ACK包之后，也处于ESTABLISHED状态</strong></p>
</li>
</ol>
<pre><code>**前两次都有SYN**，最后一次没有，只是一个**ACK包**

之后客户端开始穿数据，序列号是x+1

注意**SYN/SYN+ACK包不能携带数据，但要消耗一个序号**

**ACK包可以携带数据，但是不携带数据就不消耗序号**</code></pre><p>  四次握手断开连接</p>
<p>  一开始两者都处于<strong>ESTABLISHED</strong>状态</p>
<ol>
<li><p>首先客户端想要断开，发送<strong>FIN包</strong>给服务端，发送完之后，客户端处于<strong>FIN_WAIT_1</strong>状态 <strong>seq = x</strong></p>
</li>
<li><p>服务端收得到客户端发过来的FIN包后，发送<strong>ACK包</strong>给客户端，发送完后，进入<strong>CLOSE_WAIT</strong>状态。<strong>seq = y，ack = x+1</strong></p>
<p>客户端收到服务端发来的ACK包之后，进入<strong>FIN_WAIT_2</strong>状态，这个时候，客户端不再向服务端发数据，但是客户端仍要接受服务端的数据，相当于客户端到服务端的连接断开，服务端到客户端的连接还在</p>
<p>同时，这时候TCP服务器进程应该告诉高层应用进程，马上要断开连接，这时候如果还有数据要发送，可以发送。</p>
</li>
<li><p>服务端这边<strong>如果已经没有发送给客户端的数据</strong>，发送一个<strong>FIN包</strong>给客户端，发送完后，服务端进入<strong>LAST_ACK</strong>状态。<strong>seq = u，ack = x+1</strong></p>
</li>
<li><p>客户端收到后，发送一个<strong>ACK包</strong>，发送完后进入<strong>TIME_WAITED</strong>状态，经过<strong>2MSL后没有收到来自服务端的消息后进入CLOSED状态</strong></p>
<p>服务端收到客户端的ACK包后进入<strong>CLOSED</strong></p>
<p><strong>seq = x+1</strong>，<strong>ack = u+1</strong></p>
</li>
</ol>
<p>  <strong>FIN报文不携带数据 也要消耗掉一个序列号</strong></p>
<p>  <strong>2-3服务器可能会发一些数据</strong>，这中间<strong>ack会变</strong>，所以<strong>服务端必须重复上次的ack = x+1</strong></p>
<p>  为什么要<strong>2MSL</strong>，<strong>保证客户端发送的最后一个ack到达服务端</strong></p>
<p>  因为如果没有到达，服务端会在2MSL时间内重发<strong>FIN+ACK</strong>包，这时候继续在此节点上重复前面操作。保证握手的正常进行</p>
<p>  <strong>为什么是三次</strong></p>
<p>  如果客户端的发送的<strong>第一个请求延时</strong>，这个时候会发送第二个，（因为客户端会认为是丢包，故重新发送），假设第二个没有延时，建立连接并断开，之后服务端又接收到第一个请求，这时候会发送确认包给客户端，但客户端并不会接受该数据包并回发。这样服务端会一直等待客户端发送数据，浪费资源</p>
<p>  <strong>为什么是四次</strong></p>
<p>  因为TCP是全双工的通信，需要客户端和服务器端分别关闭。所以需要四次</p>
<p>  <strong>TCP窗口</strong></p>
<p>  <strong>是为了解决应答机制等待时间过长</strong></p>
<p>  如果没有窗口，TCP<strong>每发送一次数据就必须等待应答</strong>，收到后继续发送，如果<strong>没有收到则等待一段时间后重发</strong>，如果<strong>很长时间都没有收到应答则判断为网络断开</strong>。</p>
<p>  使用窗口后，<strong>无需等待应答</strong>可以<strong>连续发送多个数据包</strong></p>
<p>  TCP在<strong>每个传输方向都有两个窗口</strong>——发送端窗口和接受端窗口，TCP是<strong>全双工</strong>，购有<strong>四个窗口</strong></p>
<ul>
<li><p>发送端窗口</p>
<p><img src="https://img-blog.csdn.net/20170401184822495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
</li>
<li><p>接受端窗口</p>
<p><img src="https://img-blog.csdn.net/20170401190108230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
</li>
</ul>
<p>  <strong>发送端的发送窗口</strong>和<strong>接受端的接受窗口</strong>是配对的</p>
<p>  <strong>超时重传RTO</strong></p>
<p>  当一个包被发送后，就开启一个定时器，如果定时时间到了，还未收到能确认该发送包的应答包，就重传一份数据。注意收到的应答包可能是该包也可能是后面包的，但是只要能确认该包被收到就行。另外如果，是因为网络延时造成重传，则接受端<strong>收到重复数据包后丢弃该包</strong>。 </p>
<p>  <strong>快速重传</strong><br>  当如果发送端收到一个包的三次应答包后，立即重传，比超时重传更高效。</p>
<p>  拥塞控制算法：<br>  拥塞控制算法先采用慢启动算法，到达慢启动阀值后采用拥塞避免算法。</p>
<ol>
<li><p>通信开始时，发送方的拥塞窗口大小为 1。每收到一个 ACK 确认后，拥塞窗口大小加1。</p>
</li>
<li><p>由于指数级增长非常快，很快地，就会出现确认包超时，认为发生了拥塞。</p>
</li>
<li><p>此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。</p>
</li>
<li><p>拥堵发生后将拥塞窗口大小设置为 1，重新进入慢启动过程。</p>
</li>
<li><p>由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值后，停止使用慢启动算法，开始采用拥塞避免算法。窗口大小开始线性增加。</p>
</li>
<li><p>随着窗口大小不断增加，如果收到三次重复确认应答，则进入“快速重发”阶段。对于这用拥塞情况，TCP 将“慢启动阈值”设置为当前拥塞窗口大小的一半，再将拥塞窗口大小设置成阈值大小（也有说加 3）。然后采用拥塞避免算法增加窗口大小。</p>
</li>
<li><p>随着窗口大小不断增加，如果发生超时。对于这种拥塞情况，TCP将满启动阀值设置为当前拥塞窗口的一半，然后将拥塞窗口设置为1。</p>
<p><img src="https://img-blog.csdn.net/20170401202825482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
</li>
</ol>
<p>  <strong>知识点学习总结</strong></p>
<p>  若确认号为N，说明到序号N-1为止的所有数据都已正确收到</p>
<p>  <strong>数据偏移</strong>，TCP报文的数据起始处 立 TCP报文的起始处有多远</p>
<p>  确认ACK：<strong>ACK=1</strong>该字段有效。在<strong>连接建立后所有传送的报文段都必须把ACK置1</strong></p>
<p>  同步SYN：<strong>连接建立是</strong>用来同步序号。</p>
<p>  SYN=1:连接请求报文 </p>
<p>  SYN= 1 ACK=1:连接接受报文</p>
<p>  窗口：发送端发送窗口 接受端接受窗口</p>
<p>  最大报文段长度<strong>MSS</strong>指的是<strong>每一个TCP</strong>报文段中的<strong>数据字段</strong>的<strong>最大长度</strong></p>
<p>  所以MSS不是整个的最大长度，因为还有首部</p>
<p>  单工状态下，窗口就是发送端的发送窗口对应接受端的接受窗口，但是TCP是全双工所以有四个窗口。这里我们讨论单工，原理上与双工一致</p>
<p>  客户端A 服务端B</p>
<p>  A收到B的确认报文段来确定发送窗口</p>
<p>  B的报文段：确认号31 窗口是20</p>
<p>  则A的发送窗口是31-50</p>
<p>  31之前的是后沿，已发送并收到确认的部分</p>
<p>  50之后的是前沿，不允许发送的部分</p>
<p>  窗口包含：已发送但未收到确认 ，尚未发送两部分</p>
<p>  <strong>前沿</strong> = 后沿 + 窗口</p>
<p>  后沿的变化：不动（未收到新的确认） 前移（收到了新的确认）</p>
<p>  在<strong>发送窗口中，尚未发送的部分称为可用窗口</strong></p>
<p>  B的接收窗口：和 A对应，或者说发送给A的最近的确认段中给的信息所构成的A的滑动窗口对应</p>
<p>  B中的滑动窗口中会<strong>未按序收到</strong>，只能对<strong>按序收到的最高序号给出确认</strong></p>
<p>  B收到的数据会给到B的应用进程</p>
<p>  <strong>发送缓存</strong>用来暂时存放：</p>
<ol>
<li>发送应用程序 传送给 发送方TCP 准备发送的数据</li>
<li>TCP已发出但尚未收到确认的数据</li>
</ol>
<p>  <strong>接受缓存</strong>用来暂时存放：</p>
<ol>
<li>按序到达的 但是暂未被接受应用程序/进程 读取的数据</li>
<li>未按序到达的数据</li>
</ol>
<p>  <strong>超时重传</strong>的概念</p>
<p>  主要是<strong>隔多久重传</strong>，</p>
<p>  <strong>报文段的往返时间RTT</strong>：一个报文段发出时间到收到相应确认时间的差</p>
<p>  <strong>RTTs</strong>：<strong>RTT的滑动平均</strong></p>
<p>  新的RTTs = (1-a) x (旧的RTTs) + a x (新的RTT样本)</p>
<p>  <strong>超时重传时间RTO</strong></p>
<p>  建议 RTO = RTT<sub>S</sub> + 4 x RTT<sub>D</sub></p>
<p>  <strong>流量控制</strong>就是用我们上述所说的<strong>滑动窗口</strong>来解决的</p>
<p>  <strong>流量控制和拥塞控制</strong></p>
<p>  首先区别这两个概念</p>
<p>  流量控制是点到点、端到端，考虑的是发送端和接受端的速度匹配，网络不构成瓶颈，主机端的读写是瓶颈</p>
<p>  计算机网络中的<strong>链路容量（即带宽）</strong>，<strong>交换节点中的缓存和处理机等</strong>，都是<strong>网络资源</strong></p>
<p>  当我们对资源的需求超过了网络能够提供的资源，就会出现拥塞</p>
<p>  <strong>对网络资源需求的总和 &gt; 可用资源</strong>——<strong>拥塞发生</strong></p>
<p>  所谓<strong>拥塞控制</strong>就是<strong>防止过多的数据注入到网络中</strong>，这样可以使的<strong>网络中的路由器或者链路不致过载</strong>。这是一个全局性的问题</p>
<p>  我们介绍拥塞控制的<strong>四种算法</strong></p>
<p>  <strong>慢开始 拥塞避免 快重传 快恢复</strong></p>
<p>  讨论之前 做两个假定</p>
<ul>
<li><p>数据单方向传送，另一个方向只传送确认</p>
</li>
<li><p>接收方总是有足够大的缓存空间，发送窗口的大小由网络的拥塞程度来决定</p>
<p>发送方维持一个<strong>拥塞窗口</strong>，我们<strong>让发送方自己的发送窗口 = 拥塞窗口</strong></p>
</li>
</ul>
<p>  <strong>慢开始 配合 拥塞避免</strong></p>
<p>  慢开始：</p>
<p>  一开始使用一个MSS，没经过一个传输轮次，double</p>
<p>  拥塞避免：每次➕一个MSS</p>
<p>  两者配合<strong>慢开始门限ssthresh</strong></p>
<p>  一开始使用<strong>慢开始算法</strong>，<strong>到达ssthresh后</strong>，使用<strong>拥塞避免算法</strong>，</p>
<p>  直到<strong>遇到网络拥塞</strong>——<strong>将ssthresh变为当前拥塞窗口的一半</strong>，<strong>初始值变为1MSS</strong>，然后<strong>慢开始，遇到门限变拥塞避免</strong>，周而复始</p>
<p>  <strong><em>注意上面判断拥塞的依据——没有按时收到确认</em></strong></p>
<p>  <strong>快重传 配合 快恢复</strong></p>
<p>  基于如下考虑：发送方设置的<strong>超时计时器时限已到但是还没有收到确认</strong>，不使用快重传的话，会将ssthresh减半然后拥塞窗口cwnd减小到1</p>
<p>  <strong>快重传算法</strong>：</p>
<p>  首先要求<strong>接收端每收到一个失序的报文段</strong>就<strong>立刻发出重复确认</strong>——<strong>而不是等待接收端自己发送数据时进行捎带确认</strong>，——为的是<strong>使发送方及早知道有报文段没有到达对方</strong></p>
<p>  快重传算法<strong>约定</strong>，发送方一连收到（对同一数据）三个重复确认，<strong>就立即重传</strong>对该确认数据的下一数据，比如使确认M2，重传M3（因为确认M2的ack就是M3的数据序号）</p>
<p>  <strong>快恢复</strong>——配合快重传使用</p>
<p>  过程：</p>
<p>  快重传后：</p>
<p>  将sshthresh变为现在cwnd的一半，然后执行拥塞避免算法</p>
<p>  原因：当我们一连接收到三个重复确认，我们会认为这时候网络<strong>很可能没有发生拥塞</strong></p>
<p>   <strong>TCP Server 和 TCP Client（Linux 套接字）</strong></p>
<p>  数据传输过程中，一定有一个<strong>标准化</strong>的过程，从主机a到主机b通信：</p>
<p>  a的固有数据——标准化——转化成b的固有格式</p>
<p>  a或者b的<strong>固有数据存储格式</strong>就是自己的<strong>主机字节序</strong>，上面的<strong>标准化</strong>就是<strong>网络字节序</strong></p>
<p>   a的<strong>主机字节序</strong>——<strong>网络字节序</strong>——b的<strong>主机字节序</strong></p>
<p>   <strong>主机字节序</strong>：就是自己的主机内部，内存中数据的处理方式，可以分为两种：</p>
<ul>
<li>大端字节序：按照内存的增长方向，<strong>高位数据存储在高位内存中</strong></li>
<li>小端字节序：按照内存的增长方向，<strong>高位数据存储在低位内存中</strong></li>
</ul>
<p>   在linux系统中，<strong>内核已经将这些协议实现</strong>，看看linux下<strong>套接字编程的API</strong></p>
<p>  套接字的API分为<strong>服务器端</strong>的部分和<strong>客户端</strong>的部分 </p>
<ul>
<li><p><strong>服务器端</strong></p>
<p>分为五个部分：<strong>创建套接字</strong> <strong>绑定套接字</strong> <strong>监听套接字</strong> <strong>数据传输</strong> <strong>关闭套接字</strong></p>
</li>
</ul>
<pre><code>1. 创建套接字socket函数

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>; 　　　</span><br><span class="line">  　　 　返回：非负描述字－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

   返回的就是**套接字描述符（如果成功）——一个非负描述字**

   现在返回的描述符**仅是部分打开的**，还**不能用于读写**，如何**完成打开的工作**，取决于我们时**客户端还是服务端**

2. 绑定套接字bind函数

   一个**套接字地址（本机IP和端口号）**绑定到**创建的套接字描述符**上，客户端一般不需要，但是对**服务器而言，一般要使用知名端口号**，如果不进行绑定，客户端不知道目的端口号，连接不能完成

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; 　</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * server, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"> 返回：<span class="number">0</span>－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>



3. 监听listen函数

   socket函数创建的套接字是主动套接字，**调用listen变成监听套接字**

   **主动套接字描述符**——&gt;**监听套接字描述符**

   此时TCP状态由**CLOSE跃迁到LISTEN**

   backlog是已完成队列和未完成队列大小之和，对于监听套接字有两个队列，一个是未完成队列，一个是已完成队列。

   这里的已完成和未完成指的是**是否建立了连接**

   未完成队列：客户端发送一个SYN包，服务器收到后变成SYN_RCVD状态，这样的套接字被加入到未完成队列中。
   已完成队列：TCP已经完成了3次握手后，将这个套接字加入到已完成队列，套接字处于ESTABLISHED状态。

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

   ![img](https://img-blog.csdn.net/20170409102055702?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   上图中可以看出，TCP的三次握手是在调用connect函数时完成的，服务器端没有调用函数，但是必须有套接字在某个端口监听，不然会返回客户端RST，终止连接。 

   **4.accept函数** 
   accept函数从**已完成连接的队列**中**取走一个套接字**，如果该**队列为空，则accept函数阻塞**。accept**函数的返回值称为已连接套接字**，已连接的套接字就**建立一个完整的TCP连接**，源IP地址，源端口号，目的IP地址，目的端口号都是唯一确定了。

   ***总结：accept函数从已完成的队列中去走一个套接字（监听套接字），返回一个已连接套接字，这个已连接的套接字建立了一个完整的TCP连接——五元素全部确定（+协议号）***

   **5.数据传输** write read / send recv

   write和read函数：当服务器和客户端的**连接建立起来后**，就可以**进行数据传输（读和写操作）**了，服务器和客户端用各自的套接字描述符进行读/写操作。因为**套接字描述符也是一种文件描述符，所以可以用文件读/写函数write()和read()进行接收和发送操作**。

   **write()函数用于数据的发送**

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; 　　 　 　 　</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;　</span><br><span class="line">  回：非负－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

   sockfd是套接字描述符，对于服务器是accept()函数返回的已连接套接字描述符，对于客户端是调用socket()函数返回的套接字描述符

   buf是指向一个用于发送信息的数据缓冲区；len指明传送数据缓冲区的大小

   **read()函数用于数据的接收**

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; 　　 　 　 　</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf, intlen)</span></span>; 　</span><br><span class="line">  回：非负－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

   参数sockfd是套接字描述符，对于服务器是accept()函数返回的已连接套接字描述符，对于客户端是调用socket()函数返回的套接字描述符；参数buf是指向一个用于接收信息的数据缓冲区；len指明接收数据缓冲区的大小。

    send和recv函数：TCP套接字提供了send()和recv()函数，用来发送和接收操作。这两个函数与write()和read()函数很相似，只是多了一个附加的参数。 
   （1）send()函数用于数据的发送

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; sys/socket.h &gt; 　　 　 　 　</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> send(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags); 　</span><br><span class="line">回：返回写出的字节数－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

   前3个参数与write()相同，参数flags是传输控制标志。 
   （2）recv()函数用于数据的发送。

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; sys/socket.h &gt; 　　 　 　 　</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags); </span><br><span class="line">回：返回读入的字节数－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

   前3个参数与read()相同，参数flags是传输控制标志。

   **6.关闭套接字** close函数
   close函数关闭套接字

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

   参数是：套接字描述符</code></pre><ul>
<li><p><strong>TCP客户端</strong></p>
<ol>
<li><p>创建套接字socket函数</p>
</li>
<li><p>连接服务器connect函数</p>
<p>用connect函数来<strong>建立与TCP服务器的连接</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;　　 　 　</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; 　</span><br><span class="line">返回：<span class="number">0</span>－－－成功　　　<span class="number">-1</span>－－－失败</span><br></pre></td></tr></table></figure>

<p>客户端发送的SYN包可能会遇到失败，可能有以下几种情况： </p>
<ol>
<li>如果客户端没有收到SYN的响应包，根据TCP的超时重发机制进行重发。75秒后还没收到，就返回错误。 </li>
<li>如果目的主机没有监听目的端口号，就会返回一个RST的分节，客户端收到RST后立刻返回错误。 </li>
<li>如果SYN在中间路由遇到目的不可达，客户端收到ICMP报文，客户端保存这个报文信息，并采用第一种情况方案解决，也就是重发。</li>
</ol>
</li>
<li><p>收发数据</p>
</li>
<li><p>关闭套接字</p>
</li>
</ol>
<p><img src="https://img-blog.csdn.net/20170409111209254?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>由上图可以看出：</p>
<p>connect 建立三次握手</p>
<p>close两边分别关闭四次握手</p>
<p>clientfd：套接字描述符——socket函数返回，默认主动套接字</p>
<p>listenfd：监听描述符——listen函数返回，将主动套接字转换为监听套接字</p>
</li>
</ul>
<pre><code>connfd：已连接描述符——accept函数返回

connect：函数成功返回0，出错则返回 -1</code></pre><p>  <strong>UDP Server 和 UDP Client（linux套接字）</strong></p>
<p>  UDP比TCP简洁很多，不需要listen accept 和 connect过程</p>
<p>  <img src="https://img-blog.csdn.net/20170410161603387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  <strong>服务端程序</strong></p>
<ol>
<li><p>socket函数创建套接字描述符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)；</span><br></pre></td></tr></table></figure>

<p>UDP是数据报的形式，因此在创建套接字时，是SOCK_DGRAM，这是与TCP不同的地方</p>
</li>
<li><p>bind函数，绑定服务器地址到套接字上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>bind函数与TCP的使用相同，将服务器的知名端口号和IP地址绑定到服务器套接字地址上，IP地址可能有多个。</p>
</li>
<li><p>sendto函数，发送数据给指定地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br></pre></td></tr></table></figure>

<p>sendto函数比send函数多出两个参数，一个是目的地址，一个是地址长度。告诉发送给哪个IP地址和哪个端口号。</p>
</li>
<li><p>recvfrom函数，接受数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure>

<p>recvfrom函数比recv函数多出两个参数，相当于TCP的accept函数，告诉我们是谁发送了数据过来。</p>
<p>UDP的connect函数<br>UDP的套接字分为已连接的套接字和未连接的套接字，默认的是未连接的套接字，上面的例程采用的是未连接的套接字。</p>
<p>UDP的connect函数形式与TCP的相同，但是作用的实现也是不同的。TCP的connect会完成三次握手，而UDP的connect不会，UDP的connect只是告诉内核保存了对端的IP和端口号，内核以后就将该套接字的数据发给这个对端地址，从这个对端地址收到的数据也会发送给客户程序。</p>
<p>在服务器未启动的情况下，启动客户端并发送消息。对于未连接的套接字而言，客户端不能收到服务器主机传回的ICMP差错报文。而已连接的套接字可以收到。</p>
<p>UDP已连接的套接字只能实现一对一的传输，如果要从多个地方接受数据和发送数据，则只能使用未连接的套接字。因此，UDP客户端多用已连接的套接字，服务端用未连接的套接字。</p>
<p>UDP缺乏流量控制<br>UDP没有TCP那样的窗口通知过程，因此，如果UDP的服务器收到的数据过快，主机来不及处理，就可能导致套接字缓冲区被占满。套接字的缓冲区被填满后，新到达的数据报就会被丢弃，导致大量丢包。</p>
</li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="YDE WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="YDE Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Note/" rel="tag"># Note</a>
          
            <a href="/tags/Network/" rel="tag"># Network</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/29/OS_Start_2019Fall/" rel="next" title="OS_Start_2019Fall">
                <i class="fa fa-chevron-left"></i> OS_Start_2019Fall
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/29/C++_Start_2019Fall/" rel="prev" title="C++_Start_2019Fall">
                C++_Start_2019Fall <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">YDE</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TaoTaoUncle" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">1.</span> <span class="nav-text">计算机网络</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YDE</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
