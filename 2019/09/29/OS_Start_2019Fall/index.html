<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Note,OS,Linux,">










<meta name="description" content="操作系统Linux 进程与线程  进程和线程的区别  进程：资源分配的基本单位 线程：cpu调度/程序执行的最小单位 同一个进程中可以并行运行着多个线程  进程分别有独立的地址空间， 同一进程的线程共享该进程的空间。 linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共">
<meta name="keywords" content="Note,OS,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="OS_Start_2019Fall">
<meta property="og:url" content="http://yoursite.com/2019/09/29/OS_Start_2019Fall/index.html">
<meta property="og:site_name" content="YDE&#39;s Daily">
<meta property="og:description" content="操作系统Linux 进程与线程  进程和线程的区别  进程：资源分配的基本单位 线程：cpu调度/程序执行的最小单位 同一个进程中可以并行运行着多个线程  进程分别有独立的地址空间， 同一进程的线程共享该进程的空间。 linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1504287171069&di=d75055f9303d41fc13a76bbf6b43f465&imgtype=0&src=http://aiyiweb.com/UpLoads/images/linux/20140516040337689677.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20170901224324925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170901232454159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20180922085248936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180922085249110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1492854762388&di=26ad212ce8fa874c1d65f2f69ad81361&imgtype=0&src=http://kjwy.5any.com/czxt/content/czxt03/images/tp-0319.JPG">
<meta property="og:image" content="https://img-blog.csdn.net/20180323193130814?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180323193406237?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180323193524677?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:updated_time" content="2019-09-30T06:55:23.278Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OS_Start_2019Fall">
<meta name="twitter:description" content="操作系统Linux 进程与线程  进程和线程的区别  进程：资源分配的基本单位 线程：cpu调度/程序执行的最小单位 同一个进程中可以并行运行着多个线程  进程分别有独立的地址空间， 同一进程的线程共享该进程的空间。 linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共">
<meta name="twitter:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1504287171069&di=d75055f9303d41fc13a76bbf6b43f465&imgtype=0&src=http://aiyiweb.com/UpLoads/images/linux/20140516040337689677.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/29/OS_Start_2019Fall/">





  <title>OS_Start_2019Fall | YDE's Daily</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YDE's Daily</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Welcome here!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/29/OS_Start_2019Fall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YDE">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YDE's Daily">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OS_Start_2019Fall</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-29T19:29:20+08:00">
                2019-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/201909/" itemprop="url" rel="index">
                    <span itemprop="name">201909</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="操作系统Linux"><a href="#操作系统Linux" class="headerlink" title="操作系统Linux"></a>操作系统Linux</h1><ul>
<li><p>进程与线程</p>
<ul>
<li><p>进程和线程的区别</p>
<ol>
<li><p>进程：<strong>资源分配</strong>的基本单位</p>
<p>线程：cpu调度/程序执行的最小单位</p>
<p>同一个进程中可以并行运行着多个线程</p>
</li>
<li><p>进程分别有独立的地址空间，</p>
<p>同一进程的线程<strong>共享该进程的空间</strong>。</p>
<p>linux下面启动一个新的进程，系统必须<strong>分配给它独立的地址空间</strong>，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种<strong>非常昂贵的多任务</strong>工作方式。而运行<strong>一个进程中的线程</strong>，它们之间<strong>共享大部分数据，使用相同的地址空间</strong>，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的寄存器和堆栈（线程栈）</p>
<p>线程切换比进程更快更高效，开销更小</p>
</li>
</ol>
</li>
<li><p><strong>用户级线程</strong>和<strong>内核级线程</strong>的比较</p>
<p><strong><em>ps：阻塞：暂停并等待某个条件的触发</em></strong></p>
<ol>
<li>用户级线程不需要陷入内核，因此切换速度<strong>更快</strong></li>
<li>用户级线程允许<strong>每个进程有自己定制的调度算法</strong>，因为不是内核的系统调用</li>
<li>用户级线程<strong>跨平台</strong>更方便</li>
<li>用户级线程会面临问题：一是如何实现阻塞 二是没有时钟如何实现调度</li>
</ol>
</li>
<li><p><strong>多进程程序和多线程程序区别，优缺点，使用场合..</strong></p>
<ol>
<li>多进程，一个进程崩溃不影响其他进程，但是进程之间切换和通信代价大</li>
<li>多线程，一个线程崩溃会导致整个进程死掉，其他线程也不能正常工作，但是<strong>数据共享 通信方便</strong></li>
<li>进程需要开辟独立地址空间，对资源消耗很大。线程对资源消耗更小。<strong>对于高并发，只有线程加上IO复用技术才能适应</strong></li>
</ol>
</li>
<li><p><strong>有了进程为什么还要线程</strong> </p>
<ol>
<li>一个任务可以分成多个子任务并行执行，他们是对一个对象在操作。 </li>
<li>线程不需要像进程一样维护那么多信息，因此创建和销毁速度更快，拥有同一个地址空间，访问很容易 ——多线程<strong>更快，占用资源少</strong></li>
<li>任务有CPU密集和IO等待，的过程，最大化利用CPU</li>
</ol>
</li>
<li><p><strong>进程间的通信方式</strong></p>
<p>需要解决的问题有三个：<strong>数据传递 关键部位不会交叉 顺序</strong></p>
<p><strong><em>进程通信适用于线程</em></strong></p>
<p>但有一个地方不同，进程间交换数据在不同的地址空间，但是<strong>线程在同一个地址空间进行，只要知道数据的地址，都可以很方便的访问</strong></p>
<p><strong>七种进程间通信方式</strong></p>
<ol>
<li><p><strong>信号量</strong>：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p>
<p>信号量是一个计数器，可以用来<strong>控制多个进程对共享资源的访问</strong>。它通常作为<strong>一种锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为<strong>进程间以及同一进程内不同线程之间的同步手段</strong></p>
</li>
<li><p><strong>管道( pipe )</strong>：管道是一种<strong>半双工</strong>的通信方式，数据只能单向流动，而且<strong>只能在具有亲缘关系的进程间使用</strong>。进程的亲缘关系通常是指<strong>父子进程</strong>关系。</p>
</li>
<li><p><strong>命/有名管道 (named pipe)</strong> ： 有名管道也是半双工的通信方式，但是它<strong>允许无亲缘关系进程间的通信</strong>。</p>
</li>
<li><p><strong>消息队列( message queue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li><p><strong>信号 ( signal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
<li><p><strong>共享内存( shared memory )</strong> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
</li>
<li><p><strong>套接字( socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>
</li>
</ol>
<p><strong>锁机制</strong>：</p>
<ol>
<li><p>互斥锁</p>
<p>提供了以<strong>排他方式阻止数据结构被并发修改的办法</strong></p>
</li>
<li><p>读写锁</p>
<p>允许多个进程<strong>同时读</strong>，但是<strong>写操作互斥</strong></p>
</li>
<li><p>条件变量</p>
<p>可以以原子变量的方式<strong>阻塞进程，直到某个特定条件为真为止</strong>对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p>
</li>
</ol>
<p><strong>线程与进程相同</strong>，都有<strong>三个基本状态</strong>，——<strong>运行</strong>、<strong>阻塞</strong> 和 <strong>就绪</strong></p>
<p>有<strong>四种转换关系</strong>：</p>
<p>运行—&gt;阻塞 阻塞—&gt;就绪 就绪—&gt;运行 运行—&gt;就绪</p>
<p>只有<strong>运行到就绪可以相互转换</strong></p>
<p><strong>阻塞肯定是从运行来的，到就绪去</strong></p>
</li>
<li><p><strong>多线程有几种实现方法</strong>，都是什么</p>
<ol>
<li>调用<strong>操作系统API</strong>，Linux用POSIX线程，内核级线程</li>
<li>使用<strong>第三方库的库函数</strong>，比如Boost库，实现用户级线程</li>
<li>C/C++库里的函数，$<thread>$头文件，用户级线程</thread></li>
</ol>
</li>
<li><p>多线程<strong>同步和互斥</strong>有几种<strong>方法</strong></p>
<p>首先搞清楚<strong>什么是线程的同步和互斥</strong>——对进程也适用</p>
<ul>
<li><p>互斥</p>
<p>对于线程A和线程B来讲，同一时刻，只允许<strong>一个线程对临界资源进行操作</strong>，A操作则B等待，A退出B才能操作</p>
</li>
<li><p>同步</p>
<p><strong>在互斥的基础上</strong>，实现<strong>线程之间的有序访问</strong>，A和B都可以对缓冲区读写数据，A写的时候B不能拿，B拿的时候A不能写，这是一种制约关系，我们称为<strong>线程的同步关系</strong></p>
</li>
</ul>
<p>那<strong>什么是临界资源和临界区</strong>——适用于线程/进程</p>
<ul>
<li><p>临界资源</p>
<p>能被多个线程共享的数据/资源</p>
</li>
<li><p>临界区</p>
<p><strong>对临界资源进行操作的那一段代码</strong></p>
<p>显然，如果能保证诸进程互斥地进入自己的临界区，便可以实现诸进程/线程对临界资源的<strong>互斥访问</strong></p>
</li>
</ul>
<p><strong>信号量</strong>：对应一个down和up操作（都是原子操作），down使信号量减一，up使信号量加1.如果你信号量大于0，则down后继续执行。down=0，down后睡眠，但是并不会讲信号量减到负数。</p>
<p><strong>互斥量</strong>：互斥量是信号量的一种特例，只有0和1两种状态（解锁和枷锁）</p>
<p><strong>关键区域</strong>：与互斥量类似，但是<strong>最大的区别在于</strong>，<strong>关键区域会进行忙等待，而互斥量如果不能解锁会自动让出cpu</strong></p>
<p>Linux平台下：加锁实现同步和互斥</p>
<ul>
<li><p>互斥锁mutex</p>
<p>访问共享资源之前加锁，访问完成之后解锁</p>
<p>加锁后，任何其他试图在此加锁的线程会被阻塞，直到当前进程解锁</p>
<p>如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， </p>
<p>第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。<br>在这种方式下，只有一个线程能够访问被互斥锁保护的资源。</p>
</li>
<li><p>读写锁rwlock</p>
<p>读写锁有三种状态：<strong>读加锁</strong>状态、<strong>写加锁</strong>状态和<strong>不加锁</strong>状态 </p>
<ol>
<li>写加锁模式下，任何<strong>试图加锁</strong>的进程都会<strong>被阻塞</strong>，直到<strong>写进程对其解锁</strong></li>
<li>读加锁模式下，<strong>任何线程</strong>都可以对其进行<strong>读加锁操作</strong>，但是所以试图<strong>进行写加锁操作</strong>的线程都会<strong>被阻塞</strong>，直到<strong>所有的读进程都解锁</strong></li>
</ol>
<p>所以读写锁<strong>非常适合对数据结构读的次数远远大于写的情况</strong></p>
<p>如果严格按照上述读写锁的操作进行的话，那么<strong>当读者源源不断到来的时候，写者总是得不到读写锁，就会造成不公平的状态</strong>。<br>一种避免这种不公平状态的方法是：<br>当处于<strong>读模式的读写锁接收到一个</strong>试图对其进行<strong>写模式加锁操作时，便会阻塞后面对其进行读模式加锁操作</strong>的线程。<br>这样等到已经加读模式的锁解锁后，写进程能够访问此锁保护的资源。</p>
</li>
<li><p>自旋锁spinlock</p>
<p>使用模式和<strong>互斥锁</strong>很类似</p>
<p>只是在加锁后，<strong>有线程试图再次执行加锁</strong>操作的时候，该线程<strong>不会阻塞</strong>，而<strong>处于循环等待</strong>的忙等状态（CPU不能够做其他事情）。<br>所以自旋锁适用的情况是：<strong>锁被持有的时间较短，而且进程并不希望在重新调度上花费太多的成本。</strong></p>
</li>
<li><p>屏障</p>
</li>
</ul>
</li>
<li><p>进程和线程（POSIX）的系统调用</p>
<table>
<thead>
<tr>
<th>进程原语</th>
<th>线程原语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fork</td>
<td>pthread_create</td>
<td>创建线程或进程</td>
</tr>
<tr>
<td>waitpid</td>
<td>pthread_join</td>
<td>获取线程进程或线程退出状态</td>
</tr>
<tr>
<td>getpid</td>
<td>pthread_self</td>
<td>获取进程ID或线程ID</td>
</tr>
<tr>
<td>exit</td>
<td>pthread_exit</td>
<td>退出进程/线程</td>
</tr>
</tbody></table>
<p>wait()和waitpid()</p>
<p>函数说明</p>
<p>   wait()函数用于使父进程（也就是调用wait()的进程）阻塞，直到一个子进程结束或者该进程接收到了一个指定的信号为止。如果该父进程没有子进程或者它的子进程已经结束，则wait()函数就会立即返回。</p>
<p>   waitpid()的作用和wait()一样，但它并不一定要等待第一个终止的子进程（它可以指定需要等待终止的子进程），它还有若干选项，如可提供一个非阻塞版本的 wait()功能，也能支持作业控制。实际上，wait()函数只是 waitpid()函数的一个特例，在Linux 内部实现 wait()函数时直接调用的就是waitpid()函数。</p>
<p>pthread_join用于<strong>等待一个线程的结束</strong>，也就是主线程中要是加了这段代码，就会在加代码的位置卡主，直到这个线程执行完毕才往下走。</p>
<p>pthread_exit用于强制退出一个线程（非执行完毕退出），一般用于线程内部。</p>
</li>
<li><p><strong>线程池</strong>是什么</p>
<p><strong>预先创建一些线程，并处于阻塞状态</strong>，新来了一个连接时就<strong>从线程池中挑一个为其服务</strong>，服务完毕后<strong>线程也不关闭，重新放回池子</strong>，线程池就是这样采用<strong>一个队列或其他容器，维持一定数量线程</strong></p>
</li>
<li><p>多线程<strong>同步和互斥有何异同</strong>，什么情况下分别使用他们，举例说明</p>
<p>互斥：只某一资源同一时刻只允许一个访问者对其访问，具有唯一性和排他性，但是<strong>无法限制</strong>访问者对资源的<strong>访问顺序</strong>，即访问是<strong>无序的</strong></p>
<p>同步：<strong>在互斥的基础上</strong>，通过<strong>其他机制</strong>实现对资源的<strong>有序访问</strong>。</p>
<p> 少数情况可以允许多个访问者同时访问资源，如第一类读写者模型。</p>
</li>
</ul>
</li>
</ul>
<pre><code>**火车票售票**是互斥还是同步——**互斥**

生产者消费者**主要是同步问题**，**也有互斥**的问题

- 生产者消费者问题？？
- 读者写者问题？</code></pre><ul>
<li><p><strong>进程间通信（IPC）介绍</strong></p>
<p>IPC(InterProcess Communication) 在不同进程之间传播或交换信息</p>
<p>常用方式：<strong>管道</strong>（无名管道和有名管道）、<strong>信号量</strong>、<strong>消息队列</strong>、<strong>共享存储</strong>、<strong>socket</strong>、<strong>Streams</strong></p>
</li>
</ul>
<pre><code>**管道**

通常指无名管道，UNIX系统IPC最古老的姓氏

1. 特点

   - 半双工
   - 用于亲缘关系的进程间通信。**父子进程，兄弟进程**之间
   - 可以看成是**特殊的文件**，对于**管道pipe的读写**可以使用普通的read、write等函数，不属于任何其他文件系统，并且**只存在于内存中**

2. 原型

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;    <span class="comment">// 返回值：若成功返回0，</span></span><br><span class="line"><span class="comment">//失败返回-1</span></span><br></pre></td></tr></table></figure>

   一个管道pipe**建立**时，会创建**两个文件描述符**：fd[0]为读而打开，fd[1]为写而打开

   ![Screen Shot 2019-08-06 at 3.56.32 PM](/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-08-06%20at%203.56.32%20PM.png)

   **关闭管道只需要关闭这两个文件描述符即可**

   **调用pipe的进程接着调用fork**，这样就创建了父子进程之间的IPC通道

   ![Screen Shot 2019-08-06 at 4.01.40 PM](/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-08-06%20at%204.01.40%20PM.png)

   若要数据流从父进程流向子进程，则关闭父进程的读端（`fd[0]`）与子进程的写端（`fd[1]`）；反之，则可以使数据流从子进程流向父进程

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];  <span class="comment">// 两个文件描述符</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(fd) &lt; <span class="number">0</span>)  <span class="comment">// 创建管道</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Create Pipe Error!\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)  <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork Error!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)  <span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        read(fd[<span class="number">0</span>], buff, <span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   ***ps:在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   两个进程的pid不同，与**fork函数特性**有关</span><br><span class="line"></span><br><span class="line">   fork函数的一个奇妙之处就是**仅仅被调用一次，却能够返回两次，可能有三种不同的返回值**：</span><br><span class="line"></span><br><span class="line">   1. **父进程**中，fork返回新创建**子进程的PID**（非负）</span><br><span class="line">   2. **子进程**中，fork返回0</span><br><span class="line">   3. 出现**错误**，返回一个**负值**</span><br><span class="line"></span><br><span class="line">   所以在接下来的代码中**用fork的返回值判断当前进程是父进程还是子进程**</span><br><span class="line"></span><br><span class="line">   &lt;font color=red&gt;其实就相当于链表，进程形成了链表，父进程的pid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其pid为0.&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">   每个进程都有一个独特（互不相同）的进程标识（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值</span><br><span class="line"></span><br><span class="line">   ***注意，fork完之后，父子进程是独立的，子进程会把父进程拷贝一份，变量独立，在不同的地址中，不是共用的。***</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">**FIFO**</span><br><span class="line"></span><br><span class="line">FIFO也称为**命名管道**，是一种**文件类型**</span><br><span class="line"></span><br><span class="line">1. **特点**</span><br><span class="line"></span><br><span class="line">   - FIFO可以在**无关的进程**之间交换数据，与无名管道不同</span><br><span class="line">   - FIFO有路径名与之相关联，以一种特殊设备文件形式存在于**文件系统**中</span><br><span class="line"></span><br><span class="line">2. **原型**</span><br><span class="line"></span><br><span class="line">   ```c++</span><br><span class="line">   #include &lt;sys/stat.h&gt;</span><br><span class="line">   // 返回值：成功返回0，出错返回-1</span><br><span class="line">   int mkfifo(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure>

   其中的 mode 参数与`open`函数中的 mode 相同。一旦创建了一个 FIFO，就可以**用一般的文件I/O函数操作**它。

   当 open 一个FIFO时，是否设置非阻塞标志（`O_NONBLOCK`）的区别：

   - 若没有指定`O_NONBLOCK`（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 open 要阻塞到某个其他进程为读而打开它。
   - 若指定了`O_NONBLOCK`，则只读 open 立即返回。而只写 open 将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其errno置ENXIO。

3. **例子**

   FIFO的通信方式类似于在进程中**使用文件来传输数据**，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且**“先进先出”**。下面的例子演示了使用 FIFO 进行 IPC 的过程：

   ![Screen Shot 2019-08-06 at 4.52.48 PM](/Users/liutao/Desktop/screenshot/Screen%20Shot%202019-08-06%20at%204.52.48%20PM.png)



**消息队列**

是**消息的链表**，存放在**内核中**，一个**消息队列**由一个**标识符即队列ID）**来标识

1. 特点

   - 消息队列面向记录，其中的**消息具有特定的格式和特定的优先级**
   - 消息队列**独立于发送与接收进程**。进程终止时，消息队列及其内容并不会被删除
   - 消息队列**可以实现消息的随机查询**，**不一定要先进先出的次序读取**，可以按消息的类型读取

2. 原型

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="comment">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span></span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="number">4</span> <span class="comment">// 添加消息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="number">6</span> <span class="comment">// 读取消息：成功返回消息数据的长度，失败返回-1</span></span><br><span class="line"><span class="number">7</span> <span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">long</span> type,<span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="number">8</span> <span class="comment">// 控制消息队列：成功返回0，失败返回-1</span></span><br><span class="line"><span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

   在以下两种情况下，`msgget`将创建一个新的消息队列：

   - 如果没有与键值key相对应的消息队列，并且flag中包含了`IPC_CREAT`标志位。
   - key参数为`IPC_PRIVATE`。

   函数`msgrcv`在读取消息队列时，type参数有下面几种情况：

   - `type == 0`，返回队列中的第一个消息；
   - `type &gt; 0`，返回队列中消息类型为 type 的第一个消息；
   - `type &lt; 0`，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。

   可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）



**信号量**

信号量（semaphore）与已经介绍过的IPC结构不同，它是一个**计数器**，用于**实现进程间的互斥与同步**，**而不是用于存储进程间通信数据**

1. **特点**
   - 信号量用于进程间同步，若要在进程间**传递数据需要结合共享内存**
   - 信号量**基于操作系统的PV操作**，程序**对信号量的操作都是原子操作**</code></pre><ul>
<li><p>每次对信号量的PV操作不仅限于对信号量值+1或-1，而且可以<strong>任意加减正整数</strong></p>
<ul>
<li><p>支持信号量组</p>
<p>首先应弄清PV操作的含义：PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：</p>
<pre><code>P（S）：**表示pass**</code></pre><p>①将信号量S的值减1，即<strong>S=S-1</strong>；<br>②如果<strong>S&gt;0，则该进程继续执行</strong>；<strong>否则</strong>该进程<strong>置为等待状态，排入等待队列。</strong></p>
<pre><code>V（S）：**表示释放**</code></pre><p>①将信号量S的值加1，即S=S+1；<br>②<strong>如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。</strong><br>PV操作的意义：我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信</p>
</li>
</ul>
<ol start="2">
<li><p><strong>原型</strong></p>
<p>最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做<strong>二值信号量（Binary Semaphore）</strong>。而可以取多个正整数的信号量被称为<strong>通用信号量</strong>。</p>
<p><strong>Linux</strong>下的信号量函数都是在<strong>通用的信号量数组</strong>上进行操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf semoparray[], <span class="keyword">size_t</span> numops)</span></span>;  </span><br><span class="line"><span class="comment">// 控制信号量的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当<code>semget</code>创建新的信号量集合时，<strong>必须指定集合中信号量的个数（即<code>num_sems</code>），通常为1</strong>； 如果是引用一个现有的集合，则将<code>num_sems</code>指定为 0 </p>
<p>在<code>semop</code>函数中，<code>sembuf</code>结构的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> sem_num; <span class="comment">// 信号量组中对应的序号，0～sem_nums-1</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;  <span class="comment">// 信号量值在一次操作中的改变量</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg; <span class="comment">// IPC_NOWAIT, SEM_UNDO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 sem_op 是一次操作中的信号量的改变量：</p>
<ul>
<li><p>若<code>sem_op &gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们。</p>
</li>
<li><p>若<code>sem_op &lt; 0</code>，请求 sem_op 的绝对值的资源。</p>
<ul>
<li><p>如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</p>
</li>
<li><p>当相应的资源数不能满足请求时，这个操作与</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有关。</span><br><span class="line"></span><br><span class="line">- sem_flg 指定`IPC_NOWAIT`，则semop函数出错返回`EAGAIN`。</span><br><span class="line"></span><br><span class="line">- sem_flg 没有指定</span><br><span class="line"></span><br><span class="line">  ```IPC_NOWAIT</span><br></pre></td></tr></table></figure>

<p>  ，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：</p>
<ol>
<li>当相应的资源数可以满足请求，此信号量的semncnt值减1，该信号量的值减去sem_op的绝对值。成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的semncnt值减1，函数semop出错返回EINTR</li>
</ol>
</li>
</ul>
</li>
<li><p>若<code>sem_op == 0</code>，进程阻塞直到信号量的相应值为0：</p>
<ul>
<li><p>当信号量已经为0，函数立即返回。</p>
</li>
<li><p>如果信号量的值不为0，则依据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">决定函数动作：</span><br><span class="line"></span><br><span class="line">- sem_flg指定`IPC_NOWAIT`，则出错返回`EAGAIN`。</span><br><span class="line"></span><br><span class="line">- sem_flg没有指定</span><br><span class="line"></span><br><span class="line">  ```IPC_NOWAIT</span><br></pre></td></tr></table></figure>

<p>  ，则将该信号量的semncnt值加1，然后进程挂起直到下述情况发生：</p>
<ol>
<li>信号量值为0，将信号量的semzcnt的值减1，函数semop成功返回；</li>
<li>此信号量被删除，函数smeop出错返回EIDRM；</li>
<li>进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的semncnt值减1，函数semop出错返回EINTR</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>在<code>semctl</code>函数中的命令有多种，这里就说两个常用的：</p>
<ul>
<li><code>SETVAL</code>：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。</li>
<li><code>IPC_RMID</code>：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>**共享内存**

共享内存（Shared Memory），指**两个或者多个进程共享一个给定的存储区**

1. **特点**

   - 共享内存时**最快的一种IPC**，因为进程是**直接对内存进行存取**
   - 因为**多个进程可以同时操作**，所以**需要进行同步**
   - **信号量+共享内存**通常**结合在一起**使用，**信号量用来同步**对共享内存的**访问**

2. 原型

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="comment">// 断开与共享内存的连接：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>; </span><br><span class="line"><span class="comment">// 控制共享内存的相关信息：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

   当用`shmget`函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。

   当一段共享内存被创建以后，它并不能被任何进程访问。必须使用`shmat`函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。

   `shmdt`函数是用来断开`shmat`建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。

   `shmctl`函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是`IPC_RMID`（从系统中删除该共享内存）。

   使用**【共享内存+信号量+消息队列】**的组合来实现服务器进程与客户进程间的通信。

   - 共享内存用来传递数据；
   - 信号量用来同步；
   - 消息队列用来 在客户端修改了共享内存后 通知服务器读取。



**匿名管道与命名管道的区别**：匿名管道只能在具有公共祖先的两个进程间使用。

**共享文件映射mmap** 
mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存。

**常见的信号有哪些？**：SIGINT，SIGKILL(不能被捕获)，SIGTERM(可以被捕获)，SIGSEGV，SIGCHLD，SIGALRM</code></pre><ul>
<li><p><strong>内存管理</strong></p>
<p>为什么叫内存的抽象：用户使用的4GB地址空间并不是一一对应着物理内存的4GB，具体的实现被封装了，所以叫做内存抽象</p>
</li>
</ul>
<p>  如果同时运行的程序太多，<strong>物理内存装不下</strong>怎么办？</p>
<p>  因此出现了两种技术：<strong>交换技术</strong>和<strong>虚拟内存</strong></p>
<p>  <strong>交换技术</strong></p>
<p>   就是当<strong>内存满了之后</strong>，就<strong>将一个程序从内存中换出，将另一个程序放入内存，换出的内存数据保存在硬盘上，当该程序再次被换入时，再将硬盘上的数据拷贝到内存</strong></p>
<p>  <strong>虚拟内存</strong></p>
<p>  每次交换一整个进程，速度非常慢，不能够容忍</p>
<p>  <strong>操作系统为了管理内存，给每个进程分配独立的地址空间，对32位系统而言，这个空间的大小时4GB。但这4GB不是实际的物理内存，实际上并不存在，因此称为虚拟内存</strong></p>
<p>  实际物理内存——物理地址</p>
<p>  虚拟内存——逻辑地址</p>
<p>  虚拟地址空间/物理地址空间都被分成大小相同的页，</p>
<p>  虚拟地址的页通过一个<strong>页表映射</strong>物理内存的页</p>
<p>  CPU使用逻辑地址，当<strong>进程要访问</strong>该进程地址空间里的某个<strong>地址</strong>的时候，将该地址<strong>传递给CPU</strong>，<strong>CPU</strong>访问该地址，<strong>经过MMU</strong>将<strong>逻辑地址换为物理地址</strong>，之前说的<strong>页表就保存在MMU中</strong>，<strong>操作系统为每个进程维护一个页表</strong></p>
<p>  <strong>为什么会快？？</strong></p>
<p>  如果<strong>所有数据在页表中都有对应项</strong>，那么虚拟地址没有任何意义了。实际上内存中只有部分数据，在内存中只有部分页面和页框有对应值。<strong>其余的页表的数据保存在硬盘一块固定的地方，Linux中叫swap分区/windows在C盘中</strong>。当访问到某个页面在物理内存中<strong>没有对应的页</strong>时就会<strong>发生缺页中断</strong>，这时候操作系统<strong>就将该页面保存在硬盘中的数据拷贝到物理内存中</strong>，并<strong>更新页表建立该页面和对应页框之间的映射关系</strong></p>
<p>  这样做就实现了每次交换的代价很小，但是物理地址空间还是可能不够用，因此操作系统<strong>交换一些数据进物理内存</strong>的时候，<strong>也会</strong>从物理内存中移除部分页框数据到硬盘上，那到底该移出谁呢？这就涉<strong>及到页面交换算法</strong>了。</p>
<p>   Linux<strong>内存管理简介</strong></p>
<p>  进程具有独立的地址空间，对于32位的系统而言，该地址空间的大小是4GB。<strong>Linux将这4GB的地址空间分为</strong>两部分，一个是<strong>用户地址空间</strong>，一个是<strong>内核地址空间</strong>。内核地址空间的地址范围范围为3G到4G，用户地址空间的地址范围为0G到3G。这里所讲的0G到4G<strong>都是虚拟地址，也称为逻辑地址</strong></p>
<p>  Linux对<strong>内核空间</strong>和<strong>用户空间</strong>是<strong>分别管理的</strong>——因为进程<strong>要么</strong>运行在<strong>用户态</strong>，要么运行在<strong>内核态</strong>，进程通过<strong>系统调用</strong>进入<strong>内核态</strong></p>
<p>  <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1504287171069&di=d75055f9303d41fc13a76bbf6b43f465&imgtype=0&src=http://aiyiweb.com/UpLoads/images/linux/20140516040337689677.jpg" alt="img"></p>
<p>  <strong>内核空间</strong></p>
<p>  内核空间的逻辑地址范围在3GB到4GB，并且<strong>内核空间是线性映射到物理空间的</strong>。何为线性映射，举例说明，内核空间逻辑地址0xc0000000对应的物理地址是0x00000000，逻辑地址0xc0000001对应的物理地址是0x00000001，也就是说逻辑地址到物理都减了一个0xc0000000的偏移量。如果1GB都是这样映射的话，那么内核空间能使用物理地址范围在0x00000000到0x40000000之间，不能访问所有的物理地址了。<strong>线性映射意味着偏移量相同</strong></p>
<p>  为了解决这个问题，内核空间就将物理内存分为三个区：ZONE_DMA，ZONE_NORMAL，ZONE_HIHGEM。DMA区是用于一些特殊设备的，我们不过多追究。主要讨论高端内存(ZONE_HIHGEM)，对于内核空间而言高于896M的空间称为高端内存，低于896M的自然就可以称为低端内存了，低端内存的范围上，逻辑地址与物理地址是线性映射的。对于内核空间896M以上剩余的128M是用来访问高端内存的。这128M里的页面到物理页框随机映射的，和用户空间的映射是一样的。低端内存是自动永久映射的，高端内存可以永久映射也可以零时映射。</p>
<p>  前面两端主要将的是对页表页框的管理，后面再将如何分配内存，也就是如果内核需要一定大小的内存的时，在3GB到4GB的范围里取出拿一块给它。内核空间分配内存可以按页分配，采用alloc_pages()和free_pages()函数分配多个连续页大小的内存，也可以通过kmalloc()分配指定大小的内存。</p>
<p>  内核分配内存时很多时候都是分配固定大小的内存块，比如为每一个进程维护的task_struct结构体等。频繁分配这样的小块，很容易造成内存碎片，自然想到用内存池的方法来解决内存碎片的问题，只不过在Linux中给其取了一个更高大上的名字，叫高速缓存cache与slab层。一个高速缓存中有多个slab，分为三类：满的，部分满，和空的。每个slab就是一个链表，链表的每个节点就是一块固定大小的内存。和内存池是一样的</p>
<p>  <strong>用户空间</strong></p>
<p>  <img src="https://img-blog.csdn.net/20170901224324925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>  这张图解释了，一个<strong>进程将数据分为代码段，数据段，BSS段，堆和栈</strong>。</p>
<p>  <strong><em>PS：BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。</em></strong></p>
<p><strong><em>在采用段式内存管理的架构中，数据段（data segment）通常是指用来存放程序中已初始化且不为0的全局变量的一块内存区域、数据段属于静态内存分配</em></strong></p>
<p>  实际上这些数据分享了0GB到3GB的地址范围。Linux管理这些段采用分区的结构，为每一个段维护一个vm_area_struct的结构体。这些结构体中保存了指向下一个指针因此形成了链表，还有另外一个指针使其构成红黑树，用户快速查找。</p>
<p>  对于用户空间不得不谈到malloc函数，malloc函数是动态分配内存，内存来自用户空间的堆区。操作系统通过链表的形式将堆区的空间贯穿起来，当需要动态分配内存时就去查询该链表，找到空闲块，如果堆区满了，就调用sbrk函数扩大堆的范围。<br>  当分配内存时，操作系统去查询该链表，找到一块能容纳下的地方放进去，将剩余的返还给空闲表。如何找到这个容纳的地方有出现了多种算法：首次适配算法，第二次首次适配，最佳适配算法，最差适配算法。这四个算法你可以去细讲差别，首次适配第一次找到第一个大于需要的地址空间的块，每次都从表头开始找，第二次着从上次找到的位置开始找，最佳适配找一个和需要大小最接近比需要的大的，最差每次早最大的。实际上对于进程内部堆的分配，页可以采取同样类似的办法。具体可以去看malloc的源码。</p>
<p>  另外还有一点很重要的是内存映射文件，内存映射文件通过mmap函数实现，将文件映射到内存中，读写文件通过操作指针就能实现。实际上，内存映射文件并不是调用mmap的时候就将该文件拷贝到内存中，而是建立逻辑地址到文件地址之间的映射关系，但访问这段内存的数据时还是引发缺页中断，然后将该页的数据换到物理地址上。可以直接使用mmap实现进程间内存共享，XSI的内存共享实现的原理也是基于mmap，只是映射一种特殊文件系统的文件到内存中，该文件不能通过read和write调用来访问</p>
<p>  <img src="https://img-blog.csdn.net/20170901232454159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hhbmdoYWlydW94aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<ul>
<li><p><strong>进程调度</strong></p>
<ol>
<li><p>Linux进程分为两种，实时进程和非实时进程（普通进程）；</p>
<p><strong>实时进程的优先级</strong>（0<del>99）<strong>都</strong>比普通进程的优先级（100</del>139）<strong>高</strong></p>
<p><strong>优先级越小——越高</strong></p>
<p><strong>调度策略</strong><br>task_struct-&gt;unsigned long policy;指定调度策略<br>#define SCHED_NORMAL    0       //<strong>非实时进程，CFS</strong><br>#define SCHED_FIFO      1       //<strong>实时进程，先进先出</strong>，它就一直运行直到退出，除非它阻塞才会释放CPU, 或被更高优先级的实时进程抢占。<br>#define SCHED_RR        2       //<strong>实时进程，基于优先级的轮回法</strong>（Round Robin），只有当它的时间片用完，内核会把它放到进程队列的末尾。</p>
</li>
<li><p>优先级分为静态优先级和动态优先级，优先级的范围；</p>
<p>内核代码中有<strong>四种优先级</strong>，<strong>dynamic priority 、normal priority、static priority、</strong>以及实时进程的<strong>rt_priority</strong></p>
<ul>
<li><p>static priority</p>
<p>范围是<strong>100-139</strong></p>
</li>
<li><p>实时进程的rt_priority</p>
<p><strong>每个实时进程都有一与其相关的实时优先级</strong>，范围<strong>0-99</strong></p>
<p>其大小可以通过sched_setscheduler()和__setscheduler_params()来改变。<br>实时进程被一个进程替换，可能的情况有：<br>a)进程被拥有更高优先级的进程抢占。<br>b)进程发生阻塞进入睡眠状态。<br>c)进程被终止（状态为TASK_STOPPED OR TASK_TRACED）或者被杀死（EXIT_DEAD OR EXIT_ZOMBIE）。<br>d)进程通过调用sched_yield()自愿放弃处理器。<br>e)进程是轮回实时（SCHED_RR）且其时间片执行完毕。<br>f)当在SCHED_RR时调用nice()和set_priority()函数并不影响实时优先级，只会影响静态优先级（从而影响基时间片）</p>
</li>
<li><p>normal priority 和 dynamic priority</p>
<p>task_has_rt_policy()用来区分进程是否是实时进程（）<br>如果进程<strong>是普通进程</strong>，那么normal_prio被设置为static_prio，（prio也等于static_prio？），<strong>dynamic priority = normal priority = static priority</strong><br>如果进程<strong>是实时进程</strong>，那么normal_prio被设置成（MAX_RT_PRIO-1 - p-&gt;rt_priority），prio被设置成（MAX_RT_PRIO-1 - p-&gt;rt_priority）。<br>rt_priority的值越大，实时优先级越高。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>调度策略</p>
<ul>
<li><p><strong>先来先服务</strong>调度算法FCFS：进程/作业调度</p>
<p><strong>进程调度</strong>中采用FCFS算法时，则<strong>每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。</strong>该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p>
<p>每次调度都是从后备作业队列中<strong>选择</strong>一个或多个<strong>最先进入</strong>该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</p>
</li>
<li><p>短进程（作业）优先调度算法 <strong>SPF - Short Process First</strong></p>
<p>指对短作业或短进程优先调度的算法</p>
<p>短进程优先(SPF)调度算法则是从就绪队列中<strong>选出一个估计运行时间最短的进程</strong>，将处理机分配给它，使它<strong>立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度</strong>。</p>
</li>
<li><p>高优先权优先调度算法（FPF）</p>
<p>算法<strong>常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。</strong>当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于<strong>进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程</strong>，</p>
<p>该算法又<strong>可进一步分为以下两种</strong>：</p>
<ul>
<li><p>非抢占式优先权算法</p>
<p>系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程</p>
<p>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p>
</li>
<li><p>抢占式优先权算法</p>
<p>抢占式优先权调度算法：在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p>
</li>
</ul>
</li>
<li><p><strong>高响应比优先调度算法</strong></p>
<p>在批处理系统中，<strong>短作业优先</strong>算法是一种比较好的算法，其主要的<strong>不足之处是长作业的运行得不到保证</strong>。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p>
<p><img src="https://img-blog.csdn.net/20180922085248936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>在利用该算法时，每要进行调度之前，都<strong>须先做响应比的计算</strong>，这会<strong>增加系统开销</strong>。</p>
</li>
<li><p><strong>时间片轮转算法</strong></p>
<p>在早期的时间片轮转法中，系统将所有的就绪进程<strong>按先来先服务的原则排成一个队列</strong>，每次调度时，把<strong>CPU 分配给队首进程</strong>，并令其<strong>执行一个时间片</strong>。时间片的大小从几ms 到几百ms。当执行的时间片<strong>用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾</strong>；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以<strong>保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间</strong>。换言之，系统能在给定的时间内响应所有用户的请求。</p>
</li>
<li><p>多级反馈队列调度算法</p>
<p>多级反馈队列调度算法则<strong>不必事先知道</strong>各种进程所需的执行时间，而且还<strong>可以满足各种类型</strong>进程的需要，因而它是<strong>目前被公认的一种较好的</strong>进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述</p>
<p>(1) 应<strong>设置多个就绪队列</strong>，并为各个队列<strong>赋予不同的优先级</strong>。第一个队列的优先级最高，第二个队列次之，其余各队列的<strong>优先权逐个降低</strong>。该算法赋予<strong>各个队列中</strong>进程执行<strong>时间片的大小也各不相同</strong>，在<strong>优先权愈高的队列</strong>中，为每个进程所规定的执行<strong>时间片就愈小</strong>。例如，<strong>第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</strong></p>
<p>(2)当一个新进程进入内存后，首先将它放入<strong>第一队列的末尾</strong>，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该<strong>时间片内完成，便可准备撤离系统</strong>；如果它在一个时间片结束时尚<strong>未完成</strong>，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列<strong>依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行</strong>。</p>
<p>(3) <strong>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行</strong>。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则<strong>此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾</strong>，把处理机分配给新到的高优先权进程。</p>
<p><img src="https://img-blog.csdn.net/20180922085249110?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li>交互进程通过平均睡眠时间而被奖励；</li>
</ol>
<ul>
<li><p><strong>死锁</strong></p>
<ul>
<li><p>死锁的<strong>概念</strong></p>
<p>多个进程<strong>都被阻塞</strong>，并<strong>一直处于这样的状态</strong>，这种状态称为<strong>死锁</strong></p>
</li>
<li><p>死锁的<strong>分类</strong></p>
<p>两类，<strong>资源死锁</strong>和<strong>通信死锁</strong></p>
<p><strong>资源死锁</strong>是由于<strong>多个进程/线程同时获取多个资源时发生</strong></p>
<p><strong>通信死锁</strong>是由于<strong>网络延时或丢包</strong>，导致<strong>两个进程都在等待</strong>对方的数据。可以<strong>通过超时重发机制解决</strong></p>
</li>
<li><p>死锁<strong>四个条件</strong></p>
<ol>
<li><p>互斥条件。——一个资源不能同时被多个进程访问</p>
</li>
<li><p>占有和等待条件——一个资源被另一个进程占用，该进程只能等待</p>
</li>
<li><p>不可抢占。已经分配给某个进程的资源，不能通过调度的方式抢占该资源</p>
</li>
<li><p><strong>环路等待条件</strong>。多个进程和资源组成环路</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1492854762388&di=26ad212ce8fa874c1d65f2f69ad81361&imgtype=0&src=http://kjwy.5any.com/czxt/content/czxt03/images/tp-0319.JPG" alt="img"></p>
<p>如上图中，p1和p2表示两个进程，s1和s2表示资源。有向图成环，发生死锁。<strong>同时占有彼此等待的资源并请求</strong></p>
</li>
</ol>
</li>
<li><p>解决死锁<strong>四种策略</strong></p>
<ol>
<li><p>忽略该问题</p>
</li>
<li><p><strong>检测死锁并恢复</strong>——意思是系统中会产生死锁</p>
<p><strong>检测</strong><br>每种资源只有一个的情况可以通过<strong>判断</strong>资源和进程<strong>构成的有向图是否有环</strong>来判定是否有死锁，每种资源有多个的情况可以通过资源矩阵检测是否存在死锁。</p>
<p><strong>恢复</strong></p>
<ul>
<li><strong>抢占式</strong>恢复。——破坏不可抢占的条件</li>
<li>回滚恢复。恢复到上一个没有占用资源的状态，进程的部分工作丢失——<strong>进程回滚后让出资源，打破环路等待</strong></li>
<li>杀死部分进程。从发生死锁的进程中，杀死部分进程，释放占用的资源——<strong>直接杀死进程来释放资源，打破环路等待条件</strong></li>
</ul>
</li>
<li><p>仔细分配资源</p>
</li>
<li><p><strong>破坏死锁条件</strong></p>
<ul>
<li>破坏互斥条件。通过虚拟技术或者其他，使得资源可以同时被多个进程使用。</li>
<li>破坏占有和等待条件。进程在获取资源前，先判断资源是否都可取，一次性获取所有资源。问题在于，进程并不知道它后面会需要哪些资源。比如还可以用trylock，timelock来代替lock避免永久阻塞。</li>
<li>破坏不可抢占。虚拟化技术</li>
<li>避免成环。按照严格的顺序进行加锁，如果不能获取资源就回滚释放占用的部分资源。比如，所有的地方都按照对1加锁，然后对2加锁，就不会成环了。如果线程先对1加锁成功，然后对2加锁，如果加锁失败，就释放资源1。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>命令行</strong></p>
<p>Linux命令 在一个文件中，倒序打印第二行前100个大写字母</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename | head -n 2 | tail -n 1 | grep &apos;[[:upper:]]&apos; -o | tr -d &apos;\n&apos;| cut -c 1-100 | rev</span><br></pre></td></tr></table></figure>

<ol>
<li><p>与CPU，内存，磁盘相关的命令(top，free, df, fdisk)</p>
<p><strong>top [参数]</strong></p>
<p>​    查看各个进程系统资源的占用情况。类似于windows的任务管理器</p>
<p>​    显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率</p>
<p>​    CPU占用率等</p>
<p>​    命令参数：-b 批处理</p>
<p>​    -c 显示完整的治命令</p>
<p>​    -I 忽略失效过程</p>
<p>​    -s 保密模式</p>
<p>​    -S 累积模式</p>
<p>​    -i&lt;时间&gt; 设置间隔时间</p>
<p>​    -u&lt;用户名&gt; 指定用户名</p>
<p>​    -p&lt;进程号&gt; 指定进程</p>
<p>​    -n&lt;次数&gt; 循环显示的次数    </p>
</li>
</ol>
</li>
</ul>
<pre><code>**free [参数] **

显示系统使用和空闲的**内存情况**，包括物理内存，交互区内存(swap)和内核缓冲区内存。共享内存将被忽略

-b 　以Byte为单位显示内存使用情况。 

-k 　以KB为单位显示内存使用情况。 

-m 　以MB为单位显示内存使用情况。

-g   以GB为单位显示内存使用情况。 

-o 　不显示缓冲区调节列。 

-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 

-t 　显示内存总和列。 

-V 　显示版本信息。 



**df [选项] [文件]**

用来检查linux服务器的**文件系统的磁盘占用情况**。可以利用该命令来获取**硬盘被占用了多少空间，目前还剩下多少空间**等信息。

显示指定磁盘文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示

**必要参数：**

-a 全部文件系统列表

-h 方便阅读方式显示

-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024

-i 显示inode信息

-k 区块为1024字节

-l 只显示本地文件系统

-m 区块为1048576字节

--no-sync 忽略 sync 命令

-P 输出格式为POSIX

--sync 在取得磁盘信息前，先执行sync命令

-T 文件系统类型

**选择参数：**

--block-size=&lt;区块大小&gt; 指定区块大小

-t&lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息

-x&lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息

--help 显示帮助信息

--version 显示版本信息



**fdisk [选项] [参数]**

**fdisk命令**用于观察硬盘实体使用情况，也可对硬盘分区。它采用传统的问答式界面，而非类似DOS fdisk的cfdisk互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。

**必要参数：**

- -l 列出素所有分区表
- -u 与&quot;-l&quot;搭配使用，显示分区数目

**选择参数：**

- -s&lt;分区编号&gt; 指定分区
- -v 版本信息</code></pre><ol start="2">
<li><p>网络相关的命令netstat，tcpdump等</p>
<p><strong>netstat</strong>：</p>
<p>netstat命令用于显示与IP、TCP、UDP和ICMP<strong>协议相关的统计数据</strong>，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>
<p>如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用netstat查一查为什么会出现这些情况了。</p>
<p><strong>命令格式</strong>：<figure class="highlight plain"><figcaption><span>[-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]```</网络类型></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一**般用于检验本机各端口的网络连接**情况。</span><br><span class="line"></span><br><span class="line">**命令参数**</span><br><span class="line"></span><br><span class="line">-a或–all 显示所有连线中的Socket。</span><br><span class="line"></span><br><span class="line">-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</span><br><span class="line"></span><br><span class="line">-c或–continuous 持续列出网络状态。</span><br><span class="line"></span><br><span class="line">-C或–cache 显示路由器配置的快取信息。</span><br><span class="line"></span><br><span class="line">-e或–extend 显示网络其他相关信息。</span><br><span class="line"></span><br><span class="line">-F或–fib 显示FIB。</span><br><span class="line"></span><br><span class="line">-g或–groups 显示多重广播功能群组组员名单。</span><br><span class="line"></span><br><span class="line">-h或–help 在线帮助。</span><br><span class="line"></span><br><span class="line">-i或–interfaces 显示网络界面信息表单。</span><br><span class="line"></span><br><span class="line">-l或–listening 显示监控中的服务器的Socket。</span><br><span class="line"></span><br><span class="line">-M或–masquerade 显示伪装的网络连线。</span><br><span class="line"></span><br><span class="line">-n或–numeric 直接使用IP地址，而不通过域名服务器。</span><br><span class="line"></span><br><span class="line">-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。</span><br><span class="line"></span><br><span class="line">-o或–timers 显示计时器。</span><br><span class="line"></span><br><span class="line">-p或–programs 显示正在使用Socket的程序识别码和程序名称。</span><br><span class="line"></span><br><span class="line">-r或–route 显示Routing Table。</span><br><span class="line"></span><br><span class="line">-s或–statistice 显示网络工作信息统计表。</span><br><span class="line"></span><br><span class="line">-t或–tcp 显示TCP传输协议的连线状况。</span><br><span class="line"></span><br><span class="line">-u或–udp 显示UDP传输协议的连线状况。</span><br><span class="line"></span><br><span class="line">-v或–verbose 显示指令执行过程。</span><br><span class="line"></span><br><span class="line">-V或–version 显示版本信息。</span><br><span class="line"></span><br><span class="line">-w或–raw 显示RAW传输协议的连线状况。</span><br><span class="line"></span><br><span class="line">-x或–unix 此参数的效果和指定”-A unix”参数相同。</span><br><span class="line"></span><br><span class="line">–ip或–inet 此参数的效果和指定”-A inet”参数相同。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**tcpdump：**</span><br><span class="line"></span><br><span class="line">是一个**运行在命令行下的抓包工具**。它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包</span><br><span class="line"></span><br><span class="line">**命令格式**：</span><br></pre></td></tr></table></figure></p>
<p>tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ]<br>[ -i 网络接口 ] [ -r 文件名] [ -s snaplen ][ -T 类型 ]<br>[-w 文件名 ] [表达式 ]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-a 　　　将网络地址和广播地址转变成名字；</span><br><span class="line"></span><br><span class="line">　　　-d 　　　将匹配信息包的代码以人们能够理解的汇编格式给出；</span><br><span class="line"></span><br><span class="line">　　　-dd 　　　将匹配信息包的代码以c语言程序段的格式给出；</span><br><span class="line"></span><br><span class="line">　　　-ddd 　　　将匹配信息包的代码以十进制的形式给出；</span><br><span class="line"></span><br><span class="line">　　　-e 　　　在输出行打印出数据链路层的头部信息，包括源mac和目的mac，以及网络层的协议；</span><br><span class="line"></span><br><span class="line">　　　-f 　　　将外部的Internet地址以数字的形式打印出来；</span><br><span class="line"></span><br><span class="line">　　　-l 　　　使标准输出变为缓冲行形式；</span><br><span class="line"></span><br><span class="line">　　　-n 　　　指定将每个监听到数据包中的域名转换成IP地址后显示，不把网络地址转换成名字；</span><br></pre></td></tr></table></figure>

<p> -nn：    指定将每个监听到的数据包中的域名转换成IP、端口从应用名称转换成端口号后显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     　　　-t 　　　在输出的每一行不打印时间戳；</span><br><span class="line"></span><br><span class="line">     　　　-v 　　　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；</span><br><span class="line"></span><br><span class="line">     　　　-vv 　　　输出详细的报文信息；</span><br><span class="line"></span><br><span class="line">     　　　-c 　　　在收到指定的包的数目后，tcpdump就会停止；</span><br><span class="line"></span><br><span class="line">     　　　-F 　　　从指定的文件中读取表达式,忽略其它的表达式；</span><br><span class="line"></span><br><span class="line">     　　　-i 　　　指定监听的网络接口；</span><br></pre></td></tr></table></figure>

<p>  -p：    将网卡设置为非混杂模式，不能与host或broadcast一起使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     　　　-r 　　　从指定的文件中读取包(这些包一般通过-w选项产生)；</span><br><span class="line"></span><br><span class="line">     　　　-w 　　　直接将包写入文件中，并不分析和打印出来；</span><br></pre></td></tr></table></figure>

<pre><code>-s snaplen         snaplen表示从一个包中截取的字节数。0表示包不截断，抓完整的数据包。默认的话 tcpdump 只显示部分数据包,默认68字节。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     　　　-T 　　　将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议；）</span><br></pre></td></tr></table></figure>

<pre><code>-X            告诉tcpdump命令，需要把协议头和包内容都原原本本的显示出来（tcpdump会以16进制和ASCII的形式显示），这在进行协议分析时是绝对的利器。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. sed, awk, grep三个超强大的命名，分别用与格式化修改，统计，和正则查找</span><br><span class="line"></span><br><span class="line">   **sed**：格式化修改</span><br><span class="line"></span><br><span class="line">   sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等</span><br></pre></td></tr></table></figure>

<p>[root@www ~]# sed [-nefr] [动作]<br>选项与参数：<br>-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。<br>-e ：直接在命令列模式上进行 sed 的动作编辑；<br>-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；<br>-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)<br>-i ：直接修改读取的文件内容，而不是输出到终端。</p>
<p>动作说明： [n1[,n2]]function<br>n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』</p>
<p>function：<br>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～<br>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**awk**：统计</span><br><span class="line"></span><br><span class="line">awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</span><br><span class="line"></span><br><span class="line">awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</span><br><span class="line"></span><br><span class="line">语法：</span><br></pre></td></tr></table></figure>

<p>awk [选项参数] ‘script’ var=value file(s)<br>或<br>awk [选项参数] -f scriptfile var=value file(s)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - -F fs or --field-separator fs</span><br><span class="line">     指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</span><br><span class="line">   - -v var=value or --asign var=value</span><br><span class="line">     赋值一个用户定义变量。</span><br><span class="line">   - -f scripfile or --file scriptfile</span><br><span class="line">     从脚本文件中读取awk命令。</span><br><span class="line">   - -mf nnn and -mr nnn</span><br><span class="line">     对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</span><br><span class="line">   - -W compact or --compat, -W traditional or --traditional</span><br><span class="line">     在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</span><br><span class="line">   - -W copyleft or --copyleft, -W copyright or --copyright</span><br><span class="line">     打印简短的版权信息。</span><br><span class="line">   - -W help or --help, -W usage or --usage</span><br><span class="line">     打印全部awk选项和每个选项的简短说明。</span><br><span class="line">   - -W lint or --lint</span><br><span class="line">     打印不能向传统unix平台移植的结构的警告。</span><br><span class="line">   - -W lint-old or --lint-old</span><br><span class="line">     打印关于不能向传统unix平台移植的结构的警告。</span><br><span class="line">   - -W posix</span><br><span class="line">     打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。</span><br><span class="line">   - -W re-interval or --re-inerval</span><br><span class="line">     允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</span><br><span class="line">   - -W source program-text or --source program-text</span><br><span class="line">     使用program-text作为源代码，可与-f命令混用。</span><br><span class="line">   - -W version or --version</span><br><span class="line">     打印bug报告信息的版本。</span><br><span class="line"></span><br><span class="line">   **grep**：正则查找</span><br><span class="line"></span><br><span class="line">   Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示**全局正则表达式**版本，它的使用权限是所有用户。</span><br><span class="line"></span><br><span class="line">   grep的工作方式是这样的，它在一**个或多个文件中**搜索**字符串模板**。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</span><br><span class="line"></span><br><span class="line">   grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作</span><br><span class="line"></span><br><span class="line">   **命令格式**</span><br><span class="line"></span><br><span class="line">   grep [option] pattern file</span><br><span class="line"></span><br><span class="line">   **命令功能**</span><br><span class="line"></span><br><span class="line">   用于过滤/搜索特定字符。可食用正则表达式 能与多种命令配合使用，十分灵活</span><br><span class="line"></span><br><span class="line">   **命令参数**</span><br><span class="line"></span><br><span class="line">   -a   --text   #不要忽略二进制的数据。   </span><br><span class="line"></span><br><span class="line">   -A&lt;显示行数&gt;   --after-context=&lt;显示行数&gt;   #除了显示符合范本样式的那一列之外，并显示该行之后的内容。   </span><br><span class="line"></span><br><span class="line">   -b   --byte-offset   #在显示符合样式的那一行之前，标示出该行第一个字符的编号。   </span><br><span class="line"></span><br><span class="line">   -B&lt;显示行数&gt;   --before-context=&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前的内容。   </span><br><span class="line"></span><br><span class="line">   -c    --count   #计算符合样式的列数。   </span><br><span class="line"></span><br><span class="line">   -C&lt;显示行数&gt;    --context=&lt;显示行数&gt;或-&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前后的内容。   </span><br><span class="line"></span><br><span class="line">   -d &lt;动作&gt;      --directories=&lt;动作&gt;   #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。   </span><br><span class="line"></span><br><span class="line">   -e&lt;范本样式&gt;  --regexp=&lt;范本样式&gt;   #指定字符串做为查找文件内容的样式。   </span><br><span class="line"></span><br><span class="line">   -E      --extended-regexp   #将样式为延伸的普通表示法来使用。   </span><br><span class="line"></span><br><span class="line">   -f&lt;规则文件&gt;  --file=&lt;规则文件&gt;   #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。   </span><br><span class="line"></span><br><span class="line">   -F   --fixed-regexp   #将样式视为固定字符串的列表。   </span><br><span class="line"></span><br><span class="line">   -G   --basic-regexp   #将样式视为普通的表示法来使用。   </span><br><span class="line"></span><br><span class="line">   -h   --no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称。   </span><br><span class="line"></span><br><span class="line">   -H   --with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。   </span><br><span class="line"></span><br><span class="line">   -i    --ignore-case   #忽略字符大小写的差别。   </span><br><span class="line"></span><br><span class="line">   -l    --file-with-matches   #列出文件内容符合指定的样式的文件名称。   </span><br><span class="line"></span><br><span class="line">   -L   --files-without-match   #列出文件内容不符合指定的样式的文件名称。   </span><br><span class="line"></span><br><span class="line">   -n   --line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。   </span><br><span class="line"></span><br><span class="line">   -q   --quiet或--silent   #不显示任何信息。   </span><br><span class="line"></span><br><span class="line">   -r   --recursive   #此参数的效果和指定“-d recurse”参数相同。   </span><br><span class="line"></span><br><span class="line">   -s   --no-messages   #不显示错误信息。   </span><br><span class="line"></span><br><span class="line">   -v   --revert-match   #显示不包含匹配文本的所有行。   </span><br><span class="line"></span><br><span class="line">   -V   --version   #显示版本信息。   </span><br><span class="line"></span><br><span class="line">   -w   --word-regexp   #只显示全字符合的列。   </span><br><span class="line"></span><br><span class="line">   -x    --line-regexp   #只显示全列符合的列。   </span><br><span class="line"></span><br><span class="line">   -y   #此参数的效果和指定“-i”参数相同。</span><br><span class="line"></span><br><span class="line">   **规则表达式**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ^  #锚定行的开始 如：&apos;^grep&apos;匹配所有以grep开头的行。    </span><br><span class="line"></span><br><span class="line">   ```$  #锚定行的结束 如：&apos;grep$&apos;匹配所有以grep结尾的行。 ```   </span><br><span class="line"></span><br><span class="line">   .  #匹配一个非换行符的字符 如：&apos;gr.p&apos;匹配gr后接一个任意字符，然后是p。    </span><br><span class="line"></span><br><span class="line">   \*  #匹配零个或多个先前字符 如：&apos;*grep&apos;匹配所有一个或多个空格后紧跟grep的行。    </span><br><span class="line"></span><br><span class="line">   .*   #一起用代表任意字符。   </span><br><span class="line"></span><br><span class="line">   []   #匹配一个指定范围内的字符，如&apos;[Gg]rep&apos;匹配Grep和grep。    </span><br><span class="line"></span><br><span class="line">   [^]  #匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    </span><br><span class="line"></span><br><span class="line">   \(..\)  #标记匹配字符，如&apos;\(love\)&apos;，love被标记为1。    </span><br><span class="line"></span><br><span class="line">   \&lt;      #锚定单词的开始，如:&apos;\&lt;grep&apos;匹配包含以grep开头的单词的行。    </span><br><span class="line"></span><br><span class="line">   \&gt;      #锚定单词的结束，如&apos;grep\&gt;&apos;匹配包含以grep结尾的单词的行。    </span><br><span class="line"></span><br><span class="line">   x\&#123;m\&#125;  #重复字符x，m次，如：&apos;0\&#123;5\&#125;&apos;匹配包含5个o的行。    </span><br><span class="line"></span><br><span class="line">   x\&#123;m,\&#125;  #重复字符x,至少m次，如：&apos;o\&#123;5,\&#125;&apos;匹配至少有5个o的行。    </span><br><span class="line"></span><br><span class="line">   x\&#123;m,n\&#125;  #重复字符x，至少m次，不多于n次，如：&apos;o\&#123;5,10\&#125;&apos;匹配5--10个o的行。   </span><br><span class="line"></span><br><span class="line">   \w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&apos;G\w*p&apos;匹配以G后跟零个或多个文字或数字字符，然后是p。   </span><br><span class="line"></span><br><span class="line">   \W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </span><br><span class="line"></span><br><span class="line">   \b    #单词锁定符，如: &apos;\bgrep\b&apos;只匹配grep。  </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   **POSIX字符:**</span><br><span class="line"></span><br><span class="line">   为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   [:alnum:]    #文字数字字符   </span><br><span class="line"></span><br><span class="line">   [:alpha:]    #文字字符   </span><br><span class="line"></span><br><span class="line">   [:digit:]    #数字字符   </span><br><span class="line"></span><br><span class="line">   [:graph:]    #非空字符（非空格、控制字符）   </span><br><span class="line"></span><br><span class="line">   [:lower:]    #小写字符   </span><br><span class="line"></span><br><span class="line">   [:cntrl:]    #控制字符   </span><br><span class="line"></span><br><span class="line">   [:print:]    #非空字符（包括空格）   </span><br><span class="line"></span><br><span class="line">   [:punct:]    #标点符号   </span><br><span class="line"></span><br><span class="line">   [:space:]    #所有空白字符（新行，空格，制表符）   </span><br><span class="line"></span><br><span class="line">   [:upper:]    #大写字符   </span><br><span class="line"></span><br><span class="line">   [:xdigit:]   #十六进制数字（0-9，a-f，A-F）  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. ipcs和ipcrm命令</span><br><span class="line"></span><br><span class="line">   **ipcs**：</span><br><span class="line"></span><br><span class="line">   ipcs是Linux下显示进程间通信设施状态的工具。可以显示消息队列、共享内存和信号量的信息。对于程序员非常有用，普通的系统管理员一般用不到此指令。</span><br><span class="line"></span><br><span class="line">   ipcs [参数]</span><br><span class="line"></span><br><span class="line">   | -a   | 默认的输出信息                         |</span><br><span class="line">   | ---- | -------------------------------------- |</span><br><span class="line">   | -m   | 打印出使用共享内存进行进程间通信的信息 |</span><br><span class="line">   | -q   | 打印出使用消息队列进行进程间通信的信息 |</span><br><span class="line">   | -s   | 打印出使用信号进行进程间通信的信息     |</span><br><span class="line"></span><br><span class="line">   **ipcrm**：</span><br><span class="line"></span><br><span class="line">   **ipcrm命令**用来删除一个或更多的消息队列、信号量集或者共享内存标识。</span><br></pre></td></tr></table></figure>

<p>ipcrm [ -m SharedMemoryID ] [ -M SharedMemoryKey ] [ -q MessageID ] [ -Q MessageKey ] [ -s SemaphoreID ] [ -S SemaphoreKey ]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**选项**</span><br></pre></td></tr></table></figure>

<p>-m SharedMemory id 删除共享内存标识 SharedMemoryID。与 SharedMemoryID 有关联的共享内存段以及数据结构都会在最后一次拆离操作后删除。<br>-M SharedMemoryKey 删除用关键字 SharedMemoryKey 创建的共享内存标识。与其相关的共享内存段和数据结构段都将在最后一次拆离操作后删除。<br>-q MessageID 删除消息队列标识 MessageID 和与其相关的消息队列和数据结构。<br>-Q MessageKey 删除由关键字 MessageKey 创建的消息队列标识和与其相关的消息队列和数据结构。<br>-s SemaphoreID 删除信号量标识 SemaphoreID 和与其相关的信号量集及数据结构。<br>-S SemaphoreKey 删除由关键字 SemaphoreKey 创建的信号标识和与其相关的信号量集和数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  5. 查找当前目录以及字母下以.c结尾的文件，且文件中包含”hello world”的文件的路径</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  6. 创建定时任务</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">- **IO模型**</span><br><span class="line"></span><br><span class="line">  1. 五种IO模型：阻塞IO 非阻塞IO IO复用 信号驱动式IO 异步IO</span><br><span class="line"></span><br><span class="line">     网络环境下，通俗的可以将IO分为两步**等** **数据搬迁**</span><br><span class="line"></span><br><span class="line">     想要**提高IO效率**，需要将**等的时间降低**</span><br><span class="line"></span><br><span class="line">     - **阻塞IO(blocking I/O)**</span><br><span class="line"></span><br><span class="line">       A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。</span><br><span class="line"></span><br><span class="line">       在内核将**数据准备好之前**，**系统调用会一直等待**所有的套接字，**默认的是阻塞方式**。 </span><br><span class="line"></span><br><span class="line">       程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。</span><br><span class="line"></span><br><span class="line">     - **非阻塞IO（noblocking I/O）**</span><br><span class="line"></span><br><span class="line">       B也在河边钓鱼，但是B不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B也在做其他的事情（一会看看书，一会读读报纸，一会又去看其他人的钓鱼等），但B在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。</span><br><span class="line"></span><br><span class="line">       **每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮询。**</span><br><span class="line"></span><br><span class="line">       但是，轮询对于CPU来说是较大的浪费，一般只有在特定的场景下才使用。 </span><br><span class="line"></span><br><span class="line">     - **信号驱动IO（signal blocking I/O）**</span><br><span class="line"></span><br><span class="line">       C也在河边钓鱼，但与A、B不同的是，C比较聪明，他给鱼竿上挂一个铃铛，当有鱼上钩的时候，这个铃铛就会被碰响，C就会将鱼钓上来。 </span><br><span class="line"></span><br><span class="line">       **信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。**</span><br><span class="line"></span><br><span class="line">     - **I/O多路转接 也叫做多路复用IO（I/O multiplexing）**</span><br><span class="line"></span><br><span class="line">       D同样也在河边钓鱼，但是D生活水平比较好，D拿了很多的鱼竿，一次性有很多鱼竿在等，D不断的查看每个鱼竿是否有鱼上钩。增加了效率，减少了等待的时间。 </span><br><span class="line"></span><br><span class="line">       **IO多路转接是多了一个select函数，select函数有一个参数是文件描述符集合，对这些文件描述符进行循环监听，当某个文件描述符就绪时，就对这个文件描述符进行处理。**</span><br><span class="line"></span><br><span class="line">       其中，select只负责等，recvfrom只负责拷贝。 </span><br><span class="line">       IO多路转接是属于阻塞IO，但可以对多个文件描述符进行阻塞监听，所以效率较阻塞IO的高</span><br><span class="line"></span><br><span class="line">     - **异步I/O（asynchronous I/O）**</span><br><span class="line"></span><br><span class="line">       E也想钓鱼，但E有事情，于是他雇来了F，让F帮他等待鱼上钩，一旦有鱼上钩，F就打电话给E，E就会将鱼钓上去。 </span><br><span class="line"></span><br><span class="line">       **当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。**</span><br><span class="line"></span><br><span class="line">       **当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序**</span><br><span class="line"></span><br><span class="line">     可以看出，阻塞程度：阻塞IO&gt;非阻塞IO&gt;多路转接IO&gt;信号驱动IO&gt;异步IO，效率是由低到高的</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">  2. **select poll epoll区别**</span><br><span class="line"></span><br><span class="line">     **都是IO多路复用的机制**</span><br><span class="line"></span><br><span class="line">     I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</span><br><span class="line"></span><br><span class="line">     **但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间</span><br><span class="line"></span><br><span class="line">     1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是**select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。**</span><br><span class="line"></span><br><span class="line">     （2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，**而epoll只要一次拷贝**，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也**能节省不少的开销。**</span><br><span class="line"></span><br><span class="line">- **线程池/内存池自己动手实现一遍**</span><br><span class="line"></span><br><span class="line"># Linux的API</span><br><span class="line"></span><br><span class="line">- **fork与vfork区别**</span><br><span class="line"></span><br><span class="line">  fork和vfork都用于创建子进程。但是vfork创建子进程后，父进程阻塞，直到子进程调用exit()或者exec()。 </span><br><span class="line">  对于内核中过程fork通过调用clone函数，然后clone函数调用do_fork()。do_fork()中调用copy_process()函数先复制task_struct结构体，然后复制其他关于内存，文件，寄存器等信息。fork采用**写时拷贝技术**，因此子进程和父进程的页表指向相同的页框。但是vfork不需要拷贝页表，因为父进程会一直阻塞，直接使用父进程页表。</span><br><span class="line"></span><br><span class="line">  **写时拷贝/写时复制**</span><br><span class="line"></span><br><span class="line">  有人认为这样大批量的复制会导致执行效率过低。其实在复制过程中，linux采用了写时复制的策略。</span><br><span class="line"></span><br><span class="line">  子进程复制了父进程的task_struct，系统堆栈空间和页面表，这意味着上面的程序，我们没有执行count++前，其实子进程和父进程的count指向的是同一块内存。而当子进程改变了变量时候（即对变量进行了写操作），会通过copy_on_write的手段为所涉及的页面建立一个新的副本。</span><br><span class="line"></span><br><span class="line">   所以当我们执行++count后，这时候子进程才新建了一个页面复制原来页面的内容，基本资源的复制是必须的，而且是高效的。整体看上去就像是父进程的独立存储空间也复制了一遍。</span><br><span class="line"></span><br><span class="line">  **写入时复制(Copy-on-write)**是一个被使用在程式设计领域的最佳化策略。其基础的观念是，如果有多个呼叫者(callers)同时要求相同资源，他们会共同取得相同的指标指向相同的资源，直到某个呼叫者(caller)尝试修改资源时，系统才会真正复制一个副本(private copy)给该呼叫者，以避免被修改的资源被直接察觉到，这过程对其他的呼叫只都是通透的(transparently)。此作法主要的优点是如果呼叫者并没有修改该资源，就不会有副本(private copy)被建立。</span><br><span class="line"></span><br><span class="line">  父进程和子进程共享页帧而不是复制页帧。然而，只要页帧被共享，它们就不能被修改，即页帧被保护。无论父进程还是子进程何时试图写一个共享的页帧，就产生一个异常，这时内核就把这个页复制到一个新的页帧中并标记为可写。原来的页帧仍然是写保护的：当其他进程试图写入时，内核检查写进程是否是这个页帧的唯一属主，如果是，就把这个页帧标记为对这个进程是可写的。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  vfork()用法与fork()相似.但是也有区别,具体区别归结为以下3点</span><br><span class="line"></span><br><span class="line">  fork() 子进程拷贝父进程的数据段，代码段. </span><br><span class="line">  vfork() 子进程与父进程共享数据段.|</span><br><span class="line"></span><br><span class="line">fork() 父子进程的执行次序不确定. </span><br><span class="line">  vfork():保证子进程先运行，</span><br><span class="line"></span><br><span class="line">  vfork()保证子进程先运行，在她调用exec或_exit之后父进程才可能被调度运行。如果在 </span><br><span class="line">  调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</span><br><span class="line"></span><br><span class="line">  在调用exec或 ```_exit```之前与父进程数据是共享的,在它调用exec或_exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。当需要改变共享数据段中变量的值，则拷贝父进程</span><br><span class="line"></span><br><span class="line">  vfork用于创建一个新进程，而该新进程的目的是exec一个新进程，vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，不会复制页表。因为子进程会立即调用exec，于是也就不会存放该地址空间。不过在子进程中调用exec或exit之前，他在父进程的空间中运行。</span><br><span class="line"></span><br><span class="line">  如果在调用vfork时子进程依赖于父进程的进一步动作，则会导致死锁。由此可见，这个系统调用是用来启动一个新的应用程序。其次，子进程在vfork()返回后直接运行在父进程的栈空间，并使用父进程的内存和数据。这意味着子进程可能破坏父进程的数据结构或栈，造成失败。</span><br><span class="line"></span><br><span class="line">  为了避免这些问题，需要确保一旦调用vfork()，子进程就不从当前的栈框架中返回，并且如果子进程改变了父进程的数据结构就不能调用exit函数。</span><br><span class="line"></span><br><span class="line">  子进程还必须避免改变全局数据结构或全局变量中的任何信息，因为这些改变都有可能使父进程不能继续。通常，如果应用程序不是在fork()之后立即调用exec()，就有必要在fork()被替换成vfork()之前做仔细的检查。</span><br><span class="line"></span><br><span class="line">**关于vfork**</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>简单的说，vfork()跟fork()类似，都是创建一个子进程，这两个函数的的返回值也具有相同的含义。但是vfork()创建的子进程基本上只能做一件事，那就是立即调用_exit()函数或者exec函数族成员，调用任何其它函数（包括exit()）、修改任何数据（除了保存vfork()返回值的那个变量）、执行任何其它语句（包括return）都是不应该的。此外，调用vfork()之后，父进程会一直阻塞，直到子进程调用_exit()终止，或者调用exec函数族成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**fork和vfork区别**</span><br><span class="line"></span><br><span class="line">1. fork()会复制父进程的页表，而vfork()不会复制，直接让子进程共用父进程的页表；</span><br><span class="line">2. fork()使用了写时复制技术，而vfork()没有，它任何时候都不会复制父进程地址空间。</span><br><span class="line">3. vfork()会阻塞父进程而fork()不会。</span><br><span class="line"></span><br><span class="line">***所以vfork()产生的子进程跟父进程完全共同使用同一个地址空间，甚至共享同一个函数堆栈！也就是子进程中对任何数据变量的修改，不管是局部的还是全局的，都会影响到父进程。而任何一个函数调用都会修改栈空间，这就是为什么vfork()的子进程不能随便调用别的函数。***</span><br><span class="line"></span><br><span class="line">***但需要注意的是，由于vfork()毕竟还是产生一个新的进程，所以子进程拥有自己的进程描述符，拥有自己的寄存器，最重要的是，拥有自己的打开文件列表！***</span><br><span class="line"></span><br><span class="line">注意拥有自己的打开文件列表非常重要，因为如果子进程只是简单地共用父进程的打开文件列表，那么当子进程调用`_exit()`退出时，`_exit()`内部会自动关闭当前进程打开的所有文件描述符，也就是打开文件列表里面的文件，这将导致父进程恢复执行时，无法访问到自己之前已经打开过的文件，包括标准输入、标准输出和标准错误输出。所幸的是这永远不会发生，子进程会复制父进程的打开文件列表，并增加文件引用计数。那为什么vfork()子进程中可以调用`_exit()`，却不可以调用exit()，也不可以直接return</span><br><span class="line"></span><br><span class="line">exit()是对`_exit()`的封装，它自己在调用`_exit()`前会做很多清理工作，其中包括刷新并关闭当前进程使用的流缓冲（比如stdio.h里面的printf等），由于vfork()的子进程完全共享了父进程地址空间，子进程里面的流也是共享的父进程的流，所以子进程里面是不能做这些事的。</span><br><span class="line"></span><br><span class="line">直接return就更不行了，子进程return以后，会从当前函数的外部调用点后面继续执行，这后面子进程可能将会执行很多语句，结果就没法预料了</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">void stack1() &#123;</span><br><span class="line">    vfork();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void stack2() &#123;</span><br><span class="line">    _exit(0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line"> </span><br><span class="line">    stack1();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%d goes 1\n&quot;, getpid());</span><br><span class="line">    stack2();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%d goes 2\n&quot;, getpid());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果父进程pid为1000，子进程pid为1001，那么输出将会是：</p>
<p><strong>1001 goes 1</strong></p>
<p><strong>1000 goes 2</strong></p>
<ul>
<li><p>exit()与_exit()区别</p>
<p>exit()清理后进入内核，_exit()直接陷入内核。<strong>见上</strong></p>
</li>
<li><p><strong>孤儿进程与僵死进程</strong></p>
<p><strong>子进程的结束</strong>和<strong>父进程的运行</strong>是一个<strong>异步过程</strong>,即父进程永远无法预测子进程 到底什么时候结束。 当<strong>一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</strong></p>
<p><strong>孤儿进程</strong>：一个<strong>父进程退出</strong>，而它的<strong>一个或多个子进程还在运行</strong>，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p><strong>僵尸进程</strong>：一个进程使用fork创建子进程，如果<strong>子进程退出</strong>，<strong>而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程</strong>。</p>
<p><strong>问题及危害</strong></p>
<p>unix提供了一种机制可以保证只<strong>要父进程想知道子进程结束时的状态信息， 就可以得到</strong>。这种机制就是: 在<strong>每个进程退出的时候,内核释放该进程所有的资源</strong>,包括打开的文件,占用的内存等。 <strong>但是仍然为其保留一定的信息</strong>(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。<strong>直到父进程通过wait / waitpid来取时才释放</strong>。 但这样就导致了问题，<strong>如果进程不调用wait / waitpid的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是<font color="blue">系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. </font>此即为僵尸进程的危害，应当避免。</strong></p>
<p>　　<strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。<strong><font color="blue">因此孤儿进程并不会有什么危害</font>。</strong></p>
<p>　　<strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p>　　僵尸进程危害场景：</p>
<p>　　例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，<strong><font color="blue">僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）</font></strong>。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。</p>
</li>
</ul>
<p>  <strong>僵尸进程解决办法</strong></p>
<ol>
<li><p><strong>通过信号机制</strong></p>
<p>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示：</p>
</li>
<li><p><strong>结束父进程</strong>，由父进程产生的僵尸进程也会回收处理，因为这时候僵尸进程变为孤儿进程</p>
</li>
<li><p><strong>fork两次</strong></p>
<p>《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
</li>
</ol>
<ol>
<li>孤儿进程是怎么产生的？</li>
<li>僵死进程是怎么产生的？</li>
<li>僵死进程的危害？</li>
<li>如何避免僵死进程的产生？</li>
</ol>
<ul>
<li><p><strong>Linux系统如何避免内存碎片</strong></p>
<p><strong>什么是内存碎片</strong></p>
<p>内存碎片包括<strong>内碎片</strong>和<strong>外碎片</strong></p>
<ol>
<li>内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就产生了内部碎片，通常内部碎片难以完全避免；</li>
<li>外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。</li>
</ol>
</li>
</ul>
<p><strong>外碎片</strong></p>
<p>在<strong>段式虚拟存储系统</strong>中, 作业的地址空间由若干个逻辑分段组成, 每段分配一个连续的内存区, 但各段之间不要求连续, 其内存的分配方式类似于动态分区分配.由此可知, 段式虚拟存储系统中存在<strong>外碎片</strong>.</p>
<p>频繁地请求和释放不同大小的内存，必然导致内存碎片问题的产生，结果就是当再次要求分配连续的内存时，即使整体内存是足够的，也<strong>无法满足连续内存的需求</strong>。该问题也称之为外碎片(external fragmentation)。我们在多次分配内存的时候，不要求多次分配的内存间连续。</p>
<p><strong>内碎片</strong></p>
<p>在<strong>页式虚拟存储系统</strong>中, 用户作业的地址空间被划分成若干大小相等的页面, 存储空间也分成也页大小相等的物理块, 但一般情况下, 作业的大小不可能都是物理块大小的整数倍, 因此作业的最后一页中仍有部分空间被浪费掉了. 由此可知, 页式虚拟存储系统中存在<strong>内碎片</strong>.</p>
<ol>
<li><p>伙伴算法，用于管理物理内存，避免内存碎片/;</p>
<p>伙伴系统(buddy system)<br>Linux采用著名的伙伴系统(buddy system)算法来解决外碎片问题。把所有的空闲页框分组为11个块链表，每个链表分别包含大小为1,2,4,8,16,32,64,128,256,512,1024个连续的页框，对1024个页框的最大请求对应着4MB大小的连续RAM（每页大小为4KB），每个块的第一个页框的物理地址是该块大小的整数倍，例如，大小为16个页框的块，其起始地址是16*2^12的倍数。<br>我们通过一个例子来说明伙伴算法的工作原理，假设现在要请求一个256个页框的块（1MB），算法步骤如下：<br>• 在256个页框的链表中检查是否有一个空闲快，如果没有，查找下一个更大的块，如果有，请求满足。<br>• 在512个页框的链表中检查是否有一个空闲块，如果有，把512个页框的空闲块分为两份，第一份用于满足请求，第二份链接到256个页框的链表中。如果没有空闲块，继续寻找下一个更大的块。<br>下图比较形象地描述了该过程。 </p>
<p><img src="https://img-blog.csdn.net/20180323193130814?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>页的请求<br>以上过程的逆过程，就是页框块的释放过程，也是该算法名字的由来，内核试图把大小为B的一对空闲伙伴块合并为一个2B的单独块，满足以下条件的两个块称之为伙伴：<br>• 两个块具有相同的大小<br>• 他们的物理地址是连续的<br>第一块的第一个页框的物理地址是2 * B * 2^12<br>该算法是递归的，如果它成功合并了B，就会试图去合并2B，以再次试图形成更大的块。</p>
</li>
<li><p>高速缓存Slab层用于管理内核分配内存，避免碎片。</p>
<p>slab是Linux操作系统的一种内存分配机制。其工作是针对一些经常分配并释放的对象，如进程描述符等，这些对象的大小一般比较小，如果直接采用伙伴系统来进行分配和释放，不仅会造成大量的内存碎片，而且处理速度也太慢。<br>而slab分配器是基于对象进行管理的，相同类型的对象归为一类(如进程描述符就是一类)，每当要申请这样一个对象，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免这些内碎片。slab分配器并不丢弃已分配的对象，而是释放并把它们保存在内存中。当以后又要请求新的对象时，就可以从内存直接获取而不用重复初始化。<br>对象高速缓存的组织如右下图所示，高速缓存的内存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，也包含空闲的对象。<br>在cache和object中加入slab分配器，是在时间和空间上的折中方案。 </p>
<p><img src="https://img-blog.csdn.net/20180323193406237?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>另外为了解决多核和NUMA架构下效率问题，slab管理器kmem_cache又把slab page对象分为2层结构，从下往上依次为：</p>
<p>第一层为NUMA node下cpu共享page：管理器为kmem_cache_node，管理node下的slab对象，解决NUMA架构的内存访问效率问题。当本层的空闲page不足时，从伙伴系统申请空闲page；<br>第二层为per-cpu专属page：管理器为kmem_cache_cpu，管理cpu专属的slab对象，解决多核竞争问题。当本层的空闲page不足时，从第一层申请空闲page； </p>
<p><img src="https://img-blog.csdn.net/20180323193524677?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F1cm9yYXlxeg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
</li>
</ol>
<p>slab分配算法<br>slab分配算法采用cache 存储内核对象。当创建cache 时，起初包括若干标记为空闲的对象。对象的数量与slab的大小有关。开始，所有对象都标记为空闲。当需要内核数据结构的对象时，可以直接从cache 上直接获取，并将对象初始化为使用。<br>下面考虑内核如何将slab分配给表示进程描述符的对象。在Linux系统中，进程描述符的类型是struct task_struct ，其大小约为1.7KB。当Linux 内核创建新任务时，它会从cache 中获得struct task_struct 对象所需要的内存。Cache 上会有已分配好的并标记为空闲的struct task_struct 对象来满足请求。<br>Linux 的slab 可有三种状态：<br>满的：slab 中的所有对象被标记为使用。<br>空的：slab 中的所有对象被标记为空闲。<br>部分：slab 中的对象有的被标记为使用，有的被标记为空闲。<br>slab 分配器首先从部分空闲的slab 进行分配。如没有，则从空的slab 进行分配。如没有，则从物理连续页上分配新的slab，并把它赋给一个cache ，然后再从新slab 分配空间。</p>
<ul>
<li><p><strong>共享内存的实现原理</strong></p>
<p>共享内存的使用实现原理（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）</p>
<p><strong>nmap函数要求内核创建一个新额虚拟存储器区域，最好是从地质start开始的一个区域，并将文件描述符fd指定对象的一个连续的片（chunk）映射到这个新的区域。</strong></p>
<p> <strong>SHMMNI为128，表示系统中最多可以有128个共享内存对象。</strong></p>
</li>
</ul>
<p>  共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。</p>
<p>  采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p>
<p>  Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存。linux发行版本如Redhat 8.0支持mmap()系统调用及系统V共享内存，但还没实现Posix共享内存，本文将主要介绍mmap()系统调用及系统V共享内存API的原理及应用。</p>
<p>  一、内核怎样保证各个进程寻址到同一个共享内存区域的内存页面</p>
<p>  1、page cache及swap cache中页面的区分：一个被访问文件的物理页面都驻留在page cache或swap cache中，一个页面的所有信息由struct page来描述。struct page中有一个域为指针mapping ，它指向一个struct address_space类型结构。page cache或swap cache中的所有页面就是根据address_space结构以及一个偏移量来区分的。</p>
<p>  2、文件与address_space结构的对应：一个具体的文件在打开后，内核会在内存中为之建立一个struct inode结构，其中的i_mapping域指向一个address_space结构。这样，一个文件就对应一个address_space结构，一个address_space与一个偏移量能够确定一个page cache 或swap cache中的一个页面。因此，当要寻址某个数据时，很容易根据给定的文件及数据在文件内的偏移量而找到相应的页面。</p>
<p>  3、进程调用mmap()时，只是在进程空间内新增了一块相应大小的缓冲区，并设置了相应的访问标识，但并没有建立进程空间到物理页面的映射。因此，第一次访问该空间时，会引发一个缺页异常。</p>
<p>  4、对于共享内存映射情况，缺页异常处理程序首先在swap cache中寻找目标页（符合address_space以及偏移量的物理页），如果找到，则直接返回地址；如果没有找到，则判断该页是否在交换区(swap area)，如果在，则执行一个换入操作；如果上述两种情况都不满足，处理程序将分配新的物理页面，并把它插入到page cache中。进程最终将更新进程页表。<br>  注：对于映射普通文件情况（非共享映射），缺页异常处理程序首先会在page cache中根据address_space以及数据偏移量寻找相应的页面。如果没有找到，则说明文件数据还没有读入内存，处理程序会从磁盘读入相应的页面，并返回相应地址，同时，进程页表也会更新。</p>
<p>  5、所有进程在映射同一个共享内存区域时，情况都一样，在建立线性地址与物理地址之间的映射之后，不论进程各自的返回地址如何，实际访问的必然是同一个共享内存区域对应的物理页面。<br>  注：一个共享内存区域可以看作是特殊文件系统shm中的一个文件，shm的安装点在交换区上。</p>
<p>  上面涉及到了一些数据结构，围绕数据结构理解问题会容易一些。</p>
<p>  二、mmap()及其相关系统调用</p>
<p>  mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。</p>
<p>  注：实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。</p>
<p>  1、mmap()系统调用形式如下：</p>
  <figure class="highlight plain"><figcaption><span>mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset )```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数fd为即将映射到进程空间的文件描述字，一般由open()返回，同时，fd可以指定为-1，此时须指定flags参数中的MAP_ANON，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信）。len是映射到调用进程地址空间的字节数，它从被映射文件开头offset个字节开始算起。prot 参数指定共享内存的访问权限。可取如下几个值的或：PROT_READ（可读） , PROT_WRITE （可写）, PROT_EXEC （可执行）, PROT_NONE（不可访问）。flags由以下几个常值指定：MAP_SHARED , MAP_PRIVATE , MAP_FIXED，其中，MAP_SHARED , MAP_PRIVATE必选其一，而MAP_FIXED则不推荐使用。offset参数一般设为0，表示从文件头开始映射。参数addr指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。这里不再详细介绍mmap()的参数，读者可参考mmap()手册页获得进一步的信息。</span><br><span class="line"></span><br><span class="line">2、系统调用mmap()用于共享内存的两种方式：</span><br><span class="line"></span><br><span class="line">（1）使用普通文件提供的内存映射：适用于任何进程之间；此时，需要打开或创建一个文件，然后再调用mmap()；典型调用代码如下：</span><br></pre></td></tr></table></figure>

<pre><code>fd=open(name, flag, mode);</code></pre><pre><code>
if(fd&lt;0)
        ...

ptr=mmap(NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED , fd , 0); 通过mmap()实现共享内存的通信方式有许多特点和要注意的地方，我们将在范例中进行具体说明。 

（2）使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间；由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。
对于具有亲缘关系的进程实现共享内存最好的方式应该是采用匿名内存映射的方式。此时，不必指定具体的文件，只要设置相应的标志即可，参见范例2。

3、系统调用munmap()

int munmap( void * addr, size_t len )
该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。

4、系统调用msync()

int msync ( void * addr , size_t len, int flags)
一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。

共享内存允许两个或多个进程共享一给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通信机制。共享内存可以通过mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全通信，往往还与信号灯等同步机制共同使用。

共享内存涉及到了存储管理以及文件系统等方面的知识，深入理解其内部机制有一定的难度，关键还要紧紧抓住内核使用的重要数据结构。系统V共享内存是以文件的形式组织在特殊文件系统shm中的。通过shmget可以创建或获得共享内存的标识符。取得共享内存标识符后，要通过shmat将这个内存区映射到本进程的虚拟地址空间。

1. 互斥锁，自旋锁，信号量，读写锁，屏障
2. 互斥锁与自旋锁的区别：互斥锁得不到资源的时候阻塞，不占用cpu资源。自旋锁得不到资源的时候，不停的查询，而然占用cpu资源。






















</code></pre>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="YDE WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="YDE Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Note/" rel="tag"># Note</a>
          
            <a href="/tags/OS/" rel="tag"># OS</a>
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/29/编程之法：面试和算法心得201909/" rel="next" title="编程之法：面试和算法心得201909">
                <i class="fa fa-chevron-left"></i> 编程之法：面试和算法心得201909
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/29/Network_Start_2019Fall/" rel="prev" title="Network_Start_2019Fall">
                Network_Start_2019Fall <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">YDE</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TaoTaoUncle" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统Linux"><span class="nav-number">1.</span> <span class="nav-text">操作系统Linux</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YDE</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
